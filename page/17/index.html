<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon.png?v=2.1.1" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon.png?v=2.1.1" type="image/png" sizes="32x32"><meta name="description" content="菜">
<meta property="og:type" content="website">
<meta property="og:title" content="Jeff&#39;s blog">
<meta property="og:url" content="http://zjeff-953.gitee.io/zjeff/page/17/index.html">
<meta property="og:site_name" content="Jeff&#39;s blog">
<meta property="og:description" content="菜">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jeffords zuo">
<meta name="twitter:card" content="summary"><title>Jeff's blog</title><link ref="canonical" href="http://zjeff-953.gitee.io/zjeff/page/17/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.1.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":5},
  header: {"enable":true,"showOnPost":false,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Jeff's blog" type="application/atom+xml">
</head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/reading/"><span class="header-nav-menu-item__icon"><i class="fas fa-book"></i></span><span class="header-nav-menu-item__text">阅读</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user-tie"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Jeff's blog</div><div class="header-banner-info__subtitle">Keep Curious , Keep Learning !</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/12/25/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%20-%2007%20UESTC%E8%BD%AF%E5%B7%A5%E5%A4%8D%E4%B9%A0/">软件工程 - 07 UESTC软工复习</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-12-25</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-01-14</span></span></div></header><div class="post-body"><div class="post-excerpt"><h1 id="软件工程-07-UESTC软工复习"   >
          <a href="#软件工程-07-UESTC软工复习" class="heading-link"><i class="fas fa-link"></i></a>软件工程 - 07 UESTC软工复习</h1>
      <p>软工复习</p></div><div class="post-readmore"><a class="post-readmore__link" href="/2020/12/25/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%20-%2007%20UESTC%E8%BD%AF%E5%B7%A5%E5%A4%8D%E4%B9%A0/"><span class="post-readmore__text">阅读全文</span><span class="post-readmore__icon"><i class="fas fa-long-arrow-alt-right"></i></span></a></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/12/23/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%20-%2003%20%E7%AE%80%E7%AD%94%E9%A2%98/">软件工程 - 简答题</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-12-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-12-23</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="《软件工程基础》简答题习题集"   >
          <a href="#《软件工程基础》简答题习题集" class="heading-link"><i class="fas fa-link"></i></a>《软件工程基础》简答题习题集</h1>
      
        <h2 id="第一章-概-述"   >
          <a href="#第一章-概-述" class="heading-link"><i class="fas fa-link"></i></a>第一章    概 述</h2>
      <ol>
<li><p>什么是软件危机，它有哪些典型表现？<br>所谓“软件危机 ”就是，在计算机软件的开发和维护过程中所遇到的一系列严重的问题，概括起来归纳为：如何开发软件，以满足日益增长、日趋复杂的需要；如何维护数量不断膨胀的已有软件。<br>软件危机的典型表现主要有：</p>
<ol>
<li>开发成本和进度不能准确估计</li>
<li>开发出来的软件不能满足用户的要求</li>
<li>软件的可维护性差</li>
<li>软件质量不可靠</li>
<li>软件成本在系统中的比重逐年上升</li>
<li>软件开发生产率的提高速度不够</li>
</ol>
</li>
<li><p>简述产生软件危机的原因和解决的思路。<br>软件危机产生的原因一方面与软件本身的特点有关，另一方面，是与已有软件开发、维护的方法不正确有密切关系。<br>解决软件危机，既要有技术措施    (方法和工具 )，又要有必要的组织管理措施。<br>即采用工程化的原则和方法组织软件开发是摆脱软件危机的一个主要出路。</p>
</li>
<li><p>什么是软件工程？它有哪些本质特性？<br>软件工程是一门研究如何用系统化、规范化、数量化等工程原则和方法进行软件开发和维护的学科。<br>其实质就是用工程的概念、原理、技术和方法，结合有效的管理方法和先进的开发技术，开发与维护软件，以解决软件危机。</p>
</li>
<li><p>软件工程是如何用来消除软件危机的？<br>软件工程是从技术和管理两个方面来研究如何更好地开发和维护计算机软件，从源头上消除软件危机。</p>
</li>
<li><p>简述软件的定义。<br>软件 ＝ 程序 +    数据 +    文档</p>
</li>
<li><p>软件工程的目的是什么？<br>为高质量的软件开发提供一个科学的体系框架。</p>
</li>
<li><p>什么是软件工程方法学？软件工程是一种什么样的技术？包括哪三大要素？分为哪三个分支？<br>软件工程方法学就是指在软件生命周期全过程中使用的一整套管理和开发技术方法的集合。目前， 使用最广泛的软件工程方法学分别是传统方法学和面向对象方法学。<br>软件工程作为一种层次化的技术，有方法、工具和过程三大要素，并由于其涉及学科内容的极为<br>广泛，而分为三个分支：软件开发技术、软件项目管理技术、软件质量管理技术。</p>
</li>
<li><p>简述软件工程的基本原理。 </p>
<p>软件工程有 7 条基本原理：</p>
<ol>
<li>严格按照软件生命周期计划进行管理</li>
<li>坚持进行阶段评审</li>
<li>实行严格的产品控制</li>
<li>采用先进的程序设计技术</li>
<li>结果应能清楚的审查</li>
<li>开发小组成员应少而精</li>
<li>承认不断改进软件工程实践的必要性</li>
</ol>
</li>
<li><p>软件工程的基本开发原则有哪些？ </p>
<p>软件工程的基本开发原则有： </p>
<ol>
<li>模块化</li>
<li>抽象和信息隐蔽</li>
<li>模块的高内聚和低耦合</li>
<li>确定性</li>
<li>一致性</li>
<li>完备性</li>
</ol>
</li>
<li><p>构成软件工程的基本元素有哪些？</p>
<p>软件工程包括三个要素:方法、工具和过程</p>
<p>还应该包括控制和质量保证。这里的控制，即规模控制、成本控制、复杂性控制等。</p>
</li>
<li><p>什么是软件过程？它与软件工程方法学有何关系？</p>
<p>软件过程是指为了获得高质量软件产品，在软件工具支持下，由软件人员完成的一系列软件工程活动。<br>软件过程规定了开发软件所需完成的各项任务步骤。过程步骤的设定与软件生命周期、生命周期<br>模型、软件开发工具，以及参与开发的人员等诸方面因素有关。</p>
</li>
<li><p>什么是软件生命周期？什么是软件生命周期模型？<br>软件如同自然界任何事物一样，都有其孕育、诞生、成长、成熟、衰亡的生存过程。软件的这一过程，称为软件生命周期。<br>软件生命周期模型也称软件开发过程模型，是为了解决产业环境中的实际问题，而提出的开发策<br>略。是反映整个软件生命期中，系统开发、运行、维护等实施活动的一种结构框架。</p>
</li>
<li><p>简述软件生命周期方法学的途径，以及划分阶段步骤的目的和实质。<br>软件生命周期方法学是软件工程的传统途径，划分阶段步骤的目的和实质是：控制开发工作的复杂性，通过有限步骤，把抽象逻辑概念，转化为具体物力实现。</p>
</li>
<li><p>试比较瀑布模型、快速原型模型、增量模型和螺旋模型的优缺点，说明它们各自的适用范围。</p>
</li>
<li><p>瀑布模型。<br>瀑布模型广为人知和历史悠久，其优势是规范及文档驱动的方法。但问题是，往往不能够真正满足用户的需求。<br>适用于传统软件工程领域的结构化开发。</p>
</li>
<li><p>原型模型。<br>是为了克服瀑布模型的缺点而提出来的。通过快速构建一个在机器上可运行的原型系统，让用户试用原型，并收集反馈意见的办法，来获取用户真实的需求。</p>
</li>
<li><p>螺旋模型。<br>螺旋模型适用于大型软件项目，比起之前的其它模型而言，有其一定的优越性，但这些优越性并<br>不是绝对的。主要体现在对开发人员的风险评估经验和专门知识的要求较高。    如果项目风险较大， 而开发人员的水平较低，不能准确的识别和分析风险，则势必造成重大损失。</p>
</li>
<li><p>增量模型。<br>具有在软件开发早期阶段使投资获得明显回报和交易维护的优点，    但是要求软件具有开放的结构。</p>
</li>
</ol>
<p>第二章    可行性研究</p>
<ol>
<li>在软件开发的早期阶段，为什么要进行可行性研究？其目的和任务各是什么？<br>可行性研究的目的是用最小的代价，在尽可能短的时间内确定问题是否可解决，以及是否值得解决。<br>可行性研究的任务不是解决问题，而是确定是否可解/值得解。</li>
</ol>
<ol>
<li>应该从哪些方面研究目标系统的可行性？ 主要从以下几个方面进行可行性研究：</li>
<li>技术可行性。以现有技术，能否在预定时间内完成该系统开发。</li>
<li>经济可行性。通过成本 - 效益分析，估算系统的整体经济效益是否满足要求。</li>
<li>操作可行性。分析系统的运行方式、操作规程是否适应用户应用需要。</li>
<li><p>社会可行性。分析系统在法律、社会、市场等方面的认可度。</p>
</li>
<li><p>可行性研究有哪些工作步骤？<br>(1)    复查定义，确定系统规模和目标。<br>(2)    研究老系统<br>(3)    导出高层逻辑模型 (conceptual design)<br>(4)    重新定义<br>(5)    导出多种解法<br>(6)    推荐行动方针<br>(7)    开发计划 ( 粗略)<br>(8)    审查、存档</p>
</li>
<li><p>简述系统流程图在可行性研究中的作用。<br>系统流程图是概括的描述物理系统的传统工具。系统流程图反映的是信息在系统各部分间流动的情况。<br>系统流程图可以帮助了解和分析系统，以概括的方式表达对系统的认识，并可以描述未来物理系<br>统的概貌。</p>
</li>
<li><p>简述数据流图在可行性研究中的作用和用途。<br>数据流图在可行性分析中可以帮助分析和描绘数据在软件中流动和被处理的逻辑过程，用图形的方式描述系统的逻辑功能，是系统分析员和用户之间理想的通信工具。</p>
</li>
<li><p>简单描述数据字典的内容和定义数据的方法。数据字典主要由下列    4 种元素定义组成： 1．数据流</p>
</li>
<li>数据流分量</li>
<li>数据存储</li>
<li><p>处理<br>除了数据定义外，数据字典还应包含一些关于数据的其它信息。<br>定义数据的方法通常采用自顶向下分解的方式。并由顺序、选择、重复三种基本数据元素类型组成数据。</p>
</li>
<li><p>说明软件计划的内容和目标。<br>软件计划的内容    ＝ 项目任务范围 +    环境资源 +    工作量 +    进度<br>软件计划的目标是为了提供一个框架，以便于管理者对资源、成本和进度等进行合理的估算。</p>
</li>
<li><p>什么是软件范围？定义软件范围需要哪些信息？<br>软件范围就是在技术和管理层面上都是无二义性和可理解的项目范围，是软件开发各阶段的工作依据。<br>定义软件范围需要以下信息：<br>a.    与用户、总体目标及利益相关的问题。<br>b.    有利于系统分析员理解的问题。<br>c.    集中于交流效果的问题。</p>
</li>
<li><p>简述软件开发环境资源的三个层次。<br>软件开发环境资源由三个层次构成：开发环境、软件构件以及最重要的资源——人。</p>
</li>
<li><p>软件环境资源的特征有哪些？它们对制定软件计划都有哪些意义？<br>每一类资源都有四个特征：资源描述、可用性说明和资源提供的时间、资源使用的延续时间。可以为制定软件计划估算软件开发所需的资源。</p>
</li>
<li><p>软件计划中，安排软件开发进度主要可以用哪些工具？都有哪些优缺点？ 编制进度计划的常用工具主要有甘特图和网络计划法。<br>甘特图的优点是简单，能动态地反映开发进展；缺点是难以反映多个任务间的逻辑关系。网络计划法则恰好弥补了甘特图的缺点，最适合反映多个工作之间的逻辑关系。</p>
</li>
<li><p>主要的成本估计技术有哪些？其依据的主要是什么？ 主要有，代码行技术。<br>是一种基于规模的分解估算：<br>D= f(vi)<br>以及基于问题的分解估算：<br>EV＝(Sopt+4Sm+Spess)/6<br>还有功能点技术。这种技术以功能点    (FP)为单位，度量软件的规模。<br>由于项目本身的复杂性，因此，成本估计技术主要采用    “分而治之 ”的分解技术对软件项目进行估<br>算。</p>
</li>
<li><p>为什么说成本估计是不可能精准的？<br>那是由于太多的变化因素——人员、技术、环境、策略、复杂性等等，使得成本估算永远不可能精确。</p>
</li>
<li><p>进行成本 /效益分析的方法主要有哪些？ 常用成本 /效益分析的方法主要有：<br>(1)    货币的时间价值<br>(2)    投资回收期<br>(3)    纯收入<br>(4)    投资回收率</p>
</li>
</ol>
<p>16．如何对制定完成的软件计划进行复审？为什么要复审？<br>软件计划的复审通常涉及有关软件工作范围和软硬件资源问题等。复审应该邀请用户参加，用户可提出建议，并与开发人员最终商定内容。复审内容分为技术和管理两个方面：<br>技术方面需要考虑的问题有：<br>系统的任务是否合理；<br>系统的给你复杂性是否与开发成本、进度以及风险一致； 系统规格说明书是否足够充分；<br>系统性能要求是否恰当管理方面需要考虑的问题有：<br>计划中描述的工作范围是否符合用户需求？ 计划中对资源的描述是否有效、合理？<br>计划中系统的开发成本与进度要求是否合理？<br>计划中人员的安排是否合理？</p>
<p>系统开发存在哪些风险？<br>复审可以尽早发现错误，复审是软件质量保证的重要措施。</p>
<p>第三章    需求分析</p>
<ol>
<li><p>为什么要进行需求分析？通常对软件系统有哪些需求？<br>需求问题是软件工程项目失败的主要原因。一个高质量的软件，很大程度上取决于对要解决的问题的认识，以及如何准确的表达用户的需求。需求分析就是要解决这个问题。<br>通常，对一个软件系统的需求可以有功能需求、性能需求、可靠性和可用性需求、出错处理需求、<br>接口需求等多个方面。</p>
</li>
<li><p>怎样与用户有效地沟通，以获得用户的真实需求？<br>访谈、情景分析，以及面向数据流的自顶向下求精等方法，编制简易的系统规格说明文档，创建原型等，是获取真实需求的有效方法。</p>
</li>
<li><p>需求分析的任务是什么？<br>确定对待开发系统的综合要求。</p>
</li>
<li><p>通常系统的需求可以分为哪几个层次？ 一般可以分成 5 个层次：<br>(1)    功能需求：系统必须做什么？<br>(2)    业务需求：反映客户组织机构对系统高层次的目标要求。<br>(3)    运行需求：运行环境、软硬件配置等。<br>(4)    属性需求：包括用户关心的属性，如效率、灵活性、完整性、可靠性等；开发者关心的属性， 如可维护性、可复用性、可移植性等。<br>(5)    未来可能的扩充需求：如    HDIS各组的合并， 3 维虚拟现实的效果等等。</p>
</li>
<li><p>进行需求分析的步骤有哪些？</p>
</li>
<li>确定系统的综合要求</li>
<li>分析系统的数据要求</li>
<li>导出逻辑模型</li>
<li><p>修正系统开发计划</p>
</li>
<li><p>简述建立原型模型对软件需求分析的作用。<br>可以快速构建旨在演示目标系统主要功能的可运行程序，帮助用户确定及提供更为精准的需求， 以利用户和开发者能够在目标系统应该“做什么”这一问题上尽快达成一致。</p>
</li>
<li><p>解释实体 -联系图及其用途。<br>实体-联系图是按照用户的观点对数据建立的模型。描述从用户角度看到的数据，反映用户的现实环境，并且与在软件系统中的实现方法无关。</p>
</li>
<li><p>说明为什么需要进行需求验证及验证的步骤有哪些？<br>进行需求验证是为了确保软件开发的质量，降低开发成本。通常对需求进行验证的步骤有：验证需求的一致性、验证需求的现实性、验证需求的完整性和有效性。</p>
</li>
</ol>
<p>第四章    总体设计<br>3．简单说明系统总体设计的步骤。<br>典型的总体设计包括以下    9 个步骤：<br>1、确定最佳方案<br>2、选取合理方案<br>3、推荐最佳方案<br>4、功能分解<br>5、软件结构设计<br>6、设计数据库<br>7、制定测试计划<br>8、书写文档<br>9、审查和复审</p>
<ol>
<li><p>为什么要尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，完全不用内容耦合？ 减少模块之间的关联度，提高模块的独立性。<br>因为内容耦合会导致一个模块修改另一个模块的内容，使得程序逻辑发生严重问题。<br>而公共耦合是若干模块通过一个公共数据环境相互作用，公共部分的改动将影响所有调用它的模块，公共部分的数据存取无法控制，并且复杂程度也会随耦合模块的个数增加而增加。<br>控制耦合是一个模块通过传递开关、标志、名字等控制信息，明显地控制选择另一个模块的功能。<br>由于接口单一，因此仍然会影响被控模块的内部逻辑。<br>而数据耦合只是模块间通过数据参数来交换    I/O 信息，因此不会对其它模块产生任何等影响。</p>
</li>
<li><p>为什么模块的规模要适中？<br>过大不易理解；太小则接口开销过大。</p>
</li>
<li><p>请说明为什么模块控制的宽度和深度要适度。<br>深度过大表示分工过细，而宽度过大则表示系统复杂度大，所以模块控制的宽度和深度要适度。</p>
</li>
<li><p>简述面向数据流设计方法的基本思想。<br>将由数据流图描绘的信息在系统中加工和流动的情况映射成软件结构。</p>
</li>
<li><p>常用数据流类型有哪些？ 变换流和事务流。</p>
</li>
</ol>
<ol>
<li>面向数据流的设计方法主要有哪几个步骤？ 主要有下面       7            个步骤： 1．复查基本系统模型</li>
<li>复查并精化数据流图</li>
<li>确定数据流图具有变换特性还是事务特性</li>
<li>确定输入流和输出流动边界，从而孤立出变换中心</li>
<li>完成“第一级分解”</li>
<li>完成“第二级分解”</li>
<li>使用设计度量和启发式规则对第一次分割得到的软件结构进一步精化</li>
</ol>
<p>第五章    详细设计</p>
<ol>
<li><p>详细设计的任务是什么？<br>包括模块的算法设计、模块内的数据结构设计、模块接口设计、其它根据软件特点需要完成的设计、模块测试用例设计、设计文档编写、设计评审。</p>
</li>
<li><p>在对系统做详细设计时，应遵循哪些原则？<br>① 模块的逻辑描述应清晰易读、正确可靠；<br>② 设计的处理过程应该简明易懂；<br>③ 选择恰当的描述工具来描述模块算法。</p>
</li>
<li><p>简述结构化设计的特点。<br>① 自顶向下、逐步求精；<br>② 具有单入、单出的控制结构（取消    GOTO          语句）</p>
</li>
<li><p>结构化程序设计中有哪几种基本控制结构？分别描绘在程序流程图、    盒图和 PDA 图中这些基本控制的图例。<br>(1)    顺序结构<br>(2)    选择结构<br>(3)    先判定型循环结构<br>(4)    后判定型循环结构<br>(5)    多情况选择</p>
</li>
</ol>
<p>7．试说明 ISO 为什么要建议停止使用程序流程图，而推荐使用    PDA 图？<br>由于程序流程图中的    GOTO 语句回严重地损害程序结构，而无法实行结构化设计。    PDA 图则既吸取了程序流程图好学、好用、好懂，方便、灵活的优点，又保留了        N-S  图结构化设计的特点，很好地满足了软结构构设计图形工具的要求，以及    PDA 图所具有的①    结构清晰，层次分明，易读；②    支持逐步求精的设计思想； ③ 容易将 PAD自动转换为高级语言源程序等特点，    因此，ISO要推荐使用 PDA 图。</p>
<p>9．试说明 Jackson 方法是一种怎么样的程序设计方法。它有哪些工作步骤？<br>Jackson 方法是以数据结构 (data    structure)    为基础设计每个模块的处理过程，    将数据结构转化成程序结构。具体工作步骤有：<br>第 1 步：用 Jackson 图描述 I\O    的数据结构<br>第 2 步：在两个图中指出有直接因果关系、可以同时处理的单元</p>
<p>第 3 步：将数据结构映射到程序结构<br>第 4 步：列出所有操作条件，并分配到上幅程序结构图中第 5 步：用 Pseudocode 表示程序</p>
<p>第六章    实现</p>
<ol>
<li><p>说明什么是程序编码？为什么程序设计语言的特点和编码风格会影响到程序的可靠性、可读性、可测试性和可维护性？<br>所谓“编码”，就是将在低级抽象层次得到的详细设计结果，翻译成用某种程序设计语言书写的程序。是软件设计的自然结果。<br>而程序设计语言是否有理想的结构化、模块化机制，是否有可读性好的控制结构和数据结构等特  性，以及程序设计语言提供的编译、    软件工具等， 再加上程序的设计风格会很深刻的影响软件的质量和可维护性、可测试性、可靠性等。</p>
</li>
<li><p>用户界面设计的最一般原则，即所谓“黄金规则”是什么？</p>
</li>
<li><p>置用户于控制之下； 2. 减少用户的记忆负担； 3. 保持界面一致。</p>
</li>
<li><p>软件界面设计包含了哪几个方面的基本内容？<br>界面设计包括三个方面：    1. 软件构件间接口； 2. 软件与其它系统的接口；    3. 软件与操作者之间的接口，即用户界面。</p>
</li>
<li><p>用户界面提供系统服务的方式通常有哪两种？ 命令驱动和屏幕菜单驱动</p>
</li>
<li><p>WIMP界面是屏幕菜单驱动用户界面的一种形式，其设计准则有哪些？<br>(1)    明确的动作：在屏幕上指点并操纵对象<br>(2)    即时反馈：操作结构即见<br>(3)    增量效应：图标应被拖曳连续移动，而非跳跃<br>(4)    可视交互：交互操作与用户概念模型匹配<br>(5)    剥皮式学习：学习系统功能复杂性逐层加深<br>(6)    可逆动作：也即应有退回操作<br>(7)    事先验证：只允许合法操作产生效果</p>
</li>
<li><p>为什么说软件界面设计的质量会直接影响到用户对软件产品的评价？<br>用户界面 (User-interface)    又称人机界面 (man-computer interface)    ，是用户和计算机联系的中间媒介，是系统中最重要、最关键的部分之一。用户界面设计的好坏，直接影响到系统设计的成败。<br>这是因为，如果一个界面设计的不好，也即通常所说的用户界面不友好，可以使用户在使用时感<br>到不便，甚至制造麻烦，系统就难以发挥应有的效益，甚至可能被用户弃用。</p>
</li>
</ol>
<ol>
<li><p>什么是系统响应时间？系统响应时间有哪些重要属性？<br>系统响应时间指从用户完成某个控制动作，到系统给出预期响应的时间。系统响应时间有 2 个重要的属性：长度和易变性。</p>
</li>
<li><p>在设计软件系统的用户帮助设施时，需要注意解决哪些问题？</p>
</li>
<li>在用户与系统交互期间，是否任何时候都能获得关于系统任何功能的帮助信息？</li>
<li>用户怎样请求帮助？</li>
<li>怎样显示帮助信息？</li>
<li>用户怎样返回到正常的交互方式中？</li>
<li><p>怎样组织帮助信息？</p>
</li>
<li><p>软件出错处理设计，即软件安全性设计。一个交互式出错处理程序应该具备哪些功能和属性？</p>
</li>
<li>信息应该使用用户可以理解的术语描述。</li>
<li>信息应该提供有助于从错误中恢复的建设性意见。</li>
<li>信息应该指出错误可能导致的后果。</li>
<li>信息应该伴随感官提示。</li>
<li><p>信息不能带有指责色彩。</p>
</li>
<li><p>测试的最基本目标是什么？<br>以尽可能小的代价，发现尽可能多的错误。</p>
</li>
<li><p>软件测试的原则有哪些？<br>① 应当把“尽早和不断的测试”作为座右铭<br>② 测试应由独立的专业测试机构来完成<br>③ 测试工作要全面，但不可能实现“穷举”<br>④ 只能尽可能查错，不能证明程序中没有错<br>⑤ 软件测试符合 2-8(Pareto)    原理<br>⑥ 应妥善保存测试文档<br>⑦ 制定严格、合理的测试计划<br>⑧ 错误经过修改后，相关的测试必不可少</p>
</li>
<li><p>软件测试的方法有哪几种？ 黑盒测试和白盒测试。</p>
</li>
</ol>
<ol>
<li><p>简单说明什么是白盒测试，什么是黑盒测试。<br>黑盒测试是把程序看成一个黑盒子，完全不考虑程序的内部结构和处理过程的测试方法。黑盒测试又称功能测试。<br>白盒测试是对程序的执行细节进行测试，通过设计测试数据，验证程序模块的每个路径的执行情况。白盒测试又称结构测试。</p>
</li>
<li><p>简述软件测试的步骤。<br>(1)    单元测试    —— 程序设计 &amp;    代码 bugs<br>(2)    子系统测试    —— 模块连接<br>(3)    系统测试    —— 需求确认 &amp;    系统设计<br>(4)    验收测试    —— 用户加入<br>(5)    平行运行    —— 新旧系统比较运行结果</p>
</li>
<li><p>为什么单元测试必须由编程者自己完成？<br>单元测试是对程序逻辑结构的测试。而对程序结构最为熟悉的，莫过于编程者。再者，高质量的程序模块是构造系统的基础，因此编程者必须向下一道工序提交符合质量要求的产品。</p>
</li>
<li><p>单元测试的主要手段有哪些？ 代码审查、计算机测试等。</p>
</li>
<li><p>单元测试主要从哪    5 个方面进行？ 主要测试以下五个方面：</p>
</li>
<li>模块接口</li>
<li>局部数据结构</li>
<li>重要的执行通路</li>
<li>出错处理通路</li>
<li><p>边界条件</p>
</li>
<li><p>为什么人工代码审查十分重要？<br>一次审查可发现多个错误，不必改一个测一个。</p>
</li>
<li><p>集成测试主要有渐增式测试、非渐增式测试两种，试述两种方式的异同点。<br>渐增式测试：可以较早发现模块间的接口错误、出现的错误往往跟最新加入的模块有关、在不断</p>
</li>
</ol>
<p>集成的过程中使模块不断在新的条件下受到新的检测，测试更彻底，但较非渐增式测试费时。<br>非渐增式测试由于最后才组装，因此错误发现得晚、发现错误后难以诊断定位，但可以同时并行测试所有模块，能充分利用人力。</p>
<ol>
<li><p>描述集成测试的两种策略，并比较它们的优缺点。自顶向下测试和自底向上测试两种。<br>自顶向下测试的优点是不需要测试驱动程序，    能够在测试阶段的早期实现并验证系统的主要功能， 在早期发现上层模块的接口错误。主要缺点是需要存根程序，可能遇到与此相联系的测试困难，    底层模块的错误发现较晚，而且对人力的使用也不利。<br>而自底向上测试的优缺点与自顶向下测试的优缺点正好相反。</p>
</li>
<li><p>什么是回归测试？回归测试的测试用例集如何确定？<br>回归测试是指重新执行已经做过的测试的某个子集，以保证系统在发生调试、功能变化等事项后， 没有带来非预期的副作用。<br>回归测试的测试用例集按以下方法确定：</p>
</li>
<li>检测软件全部功能的代表性测试用例。</li>
<li>专门针对可能受修改影响的软件功能的附加测试。</li>
<li><p>针对被修改过的软件成分的测试。</p>
</li>
<li><p>什么是确认测试？确认测试的任务是什么？如何确认其范围？ 验收软件的有效性 ( 功能和性能达标 ) 。<br>确认测试的工作范围主要有：</p>
</li>
<li>按合同规定审查软件配置；</li>
<li>设计测试计划，使通过测试保证软件能满足所有功能、性能要求；</li>
<li>文档与程序一致，具有维护阶段所必须的细节；</li>
<li><p>严格按用户手册操作，以检查手册的完整性和正确性。</p>
</li>
<li><p>设计测试方案的任务有哪些？<br>①预定要测试的功能<br>②设计输入的测试数据<br>③列出预期结果</p>
</li>
<li><p>什么是逻辑覆盖测试法？它主要用于什么测试？<br>逻辑覆盖测试是一种对程序逻辑通路进行覆盖的测试，通常适用于白盒测试。</p>
</li>
</ol>
<ol>
<li><p>什么是等价划分法？它主要用于什么测试？<br>是一种很常用的测试方法。其对测试数据的选择是基于对程序功能的分析，按照程序输入要求和输出要求，选择若干数据进行测试功能的过程。<br>等价划分法主要用于黑盒测试。</p>
</li>
<li><p>什么是边值分析法？它主要用于什么测试？<br>根据经验，在程序处理的边界最容易发生错误的地方进行测试，主要用于黑盒测试。</p>
</li>
<li><p>什么是错误推测法？它主要用于什么测试？<br>利用有经验的测试者对程序可能发生错误的位置的推测进行测试的方法，主要用于黑盒测试。</p>
</li>
<li><p>一个软件的测试策略应该是怎样的？ 黑盒设计    白盒补充<br>① 在任何情况下都应首先使用边界值分析的方法；<br>② 必要时用等价划分法补充；<br>③ 必要时再用错误推测法补充；<br>④ 对照程序逻辑，检查测试方案。</p>
</li>
<li><p>什么是调试？调试和测试有什么不同？ 测试 —— 发现错误<br>调试 —— 改正错误<br>调试与测试的区别在于，调试作为测试的后续工作，主要是解决和排除测试中出现的错误。</p>
</li>
<li><p>简单说明调试的方法和策略。<br>调试过程的关键不是调试技术，而是用来推断错误原因的基本策略。主要有：<br>① 试探法：凭经验猜测。<br>② 回溯法：由症状 (symptom) 最先出现的地方，沿    control flow    向回检查。适用于小型程序。<br>③ 对分法：在关键点插入变量的正确值。<br>④    归纳法：从错误症状中找出规律，推断根源。<br>⑤ 演绎法：普通    特殊</p>
</li>
<li><p>什么是软件的可靠性、可用性和正确性？<br>软件可靠性是指程序在给定的时间间隔内，按照说明书的规定，成功地运行的概率。</p>
</li>
</ol>
<p>软件可用性是指程序在给定的时间点，按照说明书的规定，成功地运行的概率。软件正确性是指程序的功能正确。</p>
<p>第七章    维护</p>
<ol>
<li><p>什么是软件维护？<br>在软件已经交付使用之后，为了改正错误或满足新的需要而修改软件的过程。</p>
</li>
<li><p>软件维护有哪几种类型？<br>①改正性维护：诊断和改正错误；<br>②适应性维护：为了和变化了的环境    ( 如软 硬件升级、新数据库等 ) 适当地配合而修改软件；<br>③完善性维护：为了增加新功能，修改已有功能，改造界面，增加    HELP等，而修改软件；<br>④预防性维护：为了改进未来的可维护性或可靠性，或为了给未来的改进奠定更好的基础而修改软件。</p>
</li>
<li><p>为什么说软件文档维护和代码维护同样重要？<br>这是因为，软件文档是影响软件可维护性的决定因素。</p>
</li>
<li><p>为什么说维护的代价很高？应该怎样做才能降低维护的代价？<br>一般维护的工作量占生存周期    70%以上，维护成本约为开发成本的    4 倍( 满足 8-2 规则) 。维护代价分为：</p>
</li>
<li>有形代价：费用已上升至总预算的    80%；</li>
<li>无形代价：<br>占用资源以致延误开发； 修改不及时引起用户不满；<br>维护引入新错误，降低了软件质量；等等。<br>c-d</li>
<li><p>维护工作量的经验模型：    M = P + K*e<br>降低维护代价的通常认识是：提高程序的可维护性，这也是软件工程学的主要目的。</p>
</li>
<li><p>导致维护成本高企的原因主要有哪些？<br>软件开发途径不好，导致软件可维护性差，原来的开发人员没有参与维护，维护成本日益高涨等， 从维护工作量的经验模型可以看到，维护工作量和成本将呈指数增加。</p>
</li>
<li><p>什么是软件的可维护性？<br>软件可维护性可定性地定义为：维护人员理解、改正、改动和改进这个软件的难易程度。</p>
</li>
<li><p>如何提高软件的可维护性？</p>
</li>
</ol>
<p>可以从提高决定软件可维护性的因素着手，这些因素是：可理解性、可测试性、可修改性、可移植性、可重用性、可靠性、可使用性、效率等。</p>
<ol>
<li><p>为什么说文档是影响软件可维护性的决定因素？<br>由于长期使用的软件系统在使用过程中会有多次修改的经历，    而文档应该记载了这些重要的修改， 所以文档比之代码更为重要。</p>
</li>
<li><p>什么是软件的系统文档？<br>系统文档是指软件系统从问题定义、需求说明、设计、实现到验收测试计划等一系列和系统实现密切相关的技术文档。</p>
</li>
<li><p>什么是软件的用户文档？<br>提供用户了解、使用、操作和安装系统的文档资料。</p>
</li>
<li><p>什么是可重用性？如何通过提高软件的可重用性来提高软件的可维护性？<br>可重用性是指同一事物不加修改或稍加修改，就可以在不同环境多次重复使用。大量使用可重用软件构件，可大幅提高软件的可维护性。主要体现在两个方面：</p>
</li>
<li>可重用构件通常都是组装成功的部件，加上每次重用又都会进一步完善部件，因此可以大幅提<br>高软件的可靠性，而改正性维护要求会降低。</li>
<li><p>很容易修改可重用的软件构件，使之适应新的应用环境，因此软件中使用可重用构件越多，软件的适应性维护和完善性维护也越容易。</p>
</li>
<li><p>为什么要进行软件可维护性复审？ 目的是提高软件的可维护性。<br>可维护性复审在软件开放的不同阶段有不同的重点。例如，在分析阶段的复审重点是：可靠性、<br>可移植性、可用性。而编码阶段则主要是：可理解性、可修改性、可移植性和效率。</p>
</li>
<li><p>什么是软件的逆向工程和再工程？<br>软件逆向工程是指当维护对象缺乏必要的文档资料时，分析已有程序，寻求比源代码更高级的抽象表现形式，恢复软件原有设计的过程。换言之，是一个恢复设计的过程。<br>软件再工程则是以软件工程学为指导，对目标软件进行重新设计、重新编码和测试的过程。</p>
</li>
<li><p>逆向工程与再工程与软件的预防性维护有什么样的关系？<br>预防性维护是为了改进软件未来的可维护性或可靠性，或为了给软件未来的改进奠定更好的基础</p>
</li>
</ol>
<p>而修改软件的过程。<br>预防性维护就是对软件将来可能需要的改动，使用逆向工程与再工程方法对软件进行维护。</p>
<ol>
<li>假设你的任务是对一个已有软件进行重大修改，而且只允许你从以下文档中选取两份：    (a) 程序的规格说明； (b) 程序的详细设计结果 ( 自然语言描述加上某种设计工具表示 ) ； (b) 源程序清单 ( 其中有适当数量的注解 ) 。<br>你将选取哪两份文档？为什么这样选取？你打算如何完成这个任务？ 应该选择 (a) 程序的规格说明和 (b) 程序的详细设计结果。<br>因为是重大修改，所以需要从修改程序规格说明和详细设计开始，对开发文档进行重大修改，而<br>源码也会需要重新编制。</li>
</ol>
<p>第八章    面向对象方法学引论</p>
<ol>
<li><p>为什么要引入面向对象方法学？<br>1、瀑布模型的缺点：僵化<br>2、SA - SD - SP    技术的缺点：本质上是基于过程的设计不易被理解；且功能变化往往引起结构 变化较大，稳定性不好。系统有明确的边界定义，且系统结构依赖于系统边界的定义，这样的系统不易 扩充和修改。数据与操作分开处理，可能造成软构件对具体应用环境的依赖，可重用性    (reusability) 较差。</p>
</li>
<li><p>面向对象方法学有哪    4 个基本要素？ 对象、类、继承、消息</p>
</li>
<li><p>面向对象方法学的优点主要有哪些？</p>
</li>
<li>以 object    为核心，强调对现实概念的模拟而不是算法。</li>
<li>以 object    模拟实体，需求变化不会引起结构的整体变化，因为实体相对稳定，故系统也相应稳定。</li>
<li>一个 class    所有的 instances    都可重用它的代码；由    inheritance    派生出的新的 class    可重用其父类的代码，并且可以修改、扩充而不影响其父类的使用。</li>
<li><p>从稳定性、 Class    的独立性强、继承和多态性、容易理解、容易测试、调试等几方面改善了可维护性。</p>
</li>
<li><p>什么是“对象”？它与传统数据有何不同？<br>对象是封装了数据结构及可以施加在这些数据结构上的操作的封装体，    可以表示为： 对象 Object:<br>= 身 份 ID +    方法 Method +    属性 Attribute+    消息 Message。与传统数据相比，对象有以下特点：<br>① 以数据为中心，不设与数据无关的操作；<br>② Object    主动处理而不    被动地等待被处理，外部只能通过    message请求操作；<br>③ 具有黑盒性：外部操作时，无须知道该    object    内部的数据结构及算法；</p>
</li>
</ol>
<p>④    具有并行性：不同    object    各自独立地处理自身数据，彼此间仅通过传递    message完成通信；<br>⑤    模块独立性好：内聚强 (    ① ) 、耦合松 (    ③ ④ )    </p>
<ol>
<li><p>什么是“类”？<br>具有相同数据和相同操作的一组对象。</p>
</li>
<li><p>什么是“继承”？<br>子类自动共享父类的    attributes    和 methods ，而不必重复定义。</p>
</li>
<li><p>什么是模型？软件开发为什么要建立模型？<br>模型就是为了理解事物而对事物作出的一种抽象，是对事物的一种无歧义的书面描述。<br>软件开发建立模型是为了帮助我们思考问题、定义术语、作出适当的假设，并帮助我们保持定义和假设的一致性。<br>对于较为复杂而不能直接理解的系统，特别需要建立模型，其目的是可以减少复杂性。</p>
</li>
<li><p>什么是对象模型？建立对象模型时主要使用哪些图形符号？这些符号的含义是什么？ 描述系统数据结构。<br>对象模型具体是描述系统的静态结构。</p>
</li>
<li><p>什么是动态模型？建立动态模型时主要使用哪些图形符号？这些符号的含义是什么？ 描述系统控制结构。<br>动态模型具体是表示系统瞬时的控制性质。</p>
</li>
<li><p>什么是功能模型？建立功能模型时主要使用哪些图形符号？ 描述系统功能。<br>功能模型具体描述的是表明系统应该做什么。</p>
</li>
</ol>
<p>第九章    面向对象分析</p>
<ol>
<li><p>进行面向对象分析的基本过程是怎么样的？ 需求陈述    快速原型    模型<br>其中模型    有三个：对象模型、动态模型、功能模型。</p>
</li>
<li><p>建立对象模型有哪几个步骤？<br>1、确定类与对象：<br>第 1 步：列出所有候选对象<br>第 2 步：去粗取精<br>2、确定关联    结构层第 1 步：收集<br>第 2 步：筛选删除<br>第 3 步：完善<br>3、划分主题<br>4、确立属性<br>5、识别继承关系及其它修改</p>
</li>
<li><p>复杂问题的对象模型有哪    5 个层次？<br>主题层、类 &amp;对象层、结构层、属性层、服务层。</p>
</li>
<li><p>建立动态模型的步骤有哪些？<br>1、编写脚本，描述事件序列：<br>事件 =    触发器 +    接收器 +    参数<br>2、设想用户界面    修改原型 .<br>3、画事件跟踪图<br>4、画状态图</p>
</li>
<li><p>如何建立功能模型？</p>
</li>
<li>画出基本系统模型图</li>
<li>画出功能级数据流图</li>
<li>描述处理框功能</li>
</ol>
<p>第十章    面向对象设计</p>
<ol>
<li>面向对象设计应该遵循哪些准则？简述每条准则的内容，并说明遵循该条准则的必要性。</li>
<li>模块化</li>
<li>抽象。抽出事物的本质特性 ,    暂不考虑其细节， 使设计从具体实现方法中超脱。    包括程序抽象、数据抽象、参数抽象。</li>
<li>信息隐蔽。对象封装。</li>
<li>弱耦合。包括交互耦合、继承耦合。</li>
<li>强内聚。包括服务内聚、类内聚、一般    - 特殊内聚。</li>
<li><p>可重用。是提高软件开发生产率和目标系统质量的重要途径。</p>
</li>
<li><p>简述有助于提高面向对象设计质量的每条主要启发式规则的内容和必要性。<br>1、设计结果清晰易懂，应做到：<br>① 用词一致    —— 按习惯用法命名。不同类中相似的方法最好取同一名字。<br>② 使用已有的协议。<br>③ 尽量减少消息模式的数目。<br>④ 避免模糊定义。<br>2、一般 - 特殊结构的深度应适当（约    100 个类, 则设计 7± 2 层）<br>3、设计简单的类（定义不超过一页纸或两屏）    。应注意：<br>① 避免过多属性；<br>② 能用简单的语句描述一个类的任务；<br>③ 对象之间合作关系要简单；<br>④避免过多方法 (    7 个) 。<br>4、使用简单的协议，减少消息中传递的参数<br>5、使用简单的方法 (CASE 可考虑用    继承替代 ) 。<br>6、把设计变动减至最小。</p>
</li>
<li><p>为什么说类构件是目前较为理想的可重用软构件？它有哪些重用方式？ 具备可重用的软构件应有的特点：独立、可塑、接口清晰（文档详尽） 重用方式有：实例重用、继承重用和多态重用。</p>
</li>
<li><p>什么是继承耦合？<br>继承是一般化类和特殊类之间耦合的一种形式。从本质上看，通过继承关系结合起来的基类和派生类，构成了系统中粒度更大的模块。因此，与交互耦合相反，继承的耦合程度会更高。</p>
</li>
</ol>
<p>第十一章    面向对象实现</p>
<ol>
<li><p>面向对象实现应该选用哪种程序设计语言？为什么？<br>应该选择能够更完整、更正确地表达问题域语义的面向对象语言。这是由于面向对象语言相对非面向对象的语言，其突出的优点：一致的表示方法、可重用性、可维护性。</p>
</li>
<li><p>面向对象程序设计语言主要有哪些技术特点？ 面向对象语言的技术特点主要有：<br>a)    支持类与对象概念的机制<br>b)    实现整体—部分结构的机制<br>c)    实现一般—特殊结构的机制<br>d)    实现属性和服务的机制<br>e)    类型检查<br>f)    类库<br>g)    效率<br>h)    持久保存对象<br>i)    参数化类<br>j)    开发环境</p>
</li>
<li><p>选择面向对象程序设计语言时主要应该考虑哪些因素？<br>主要应该着重考虑以下因素：将来能否占主导地位、可重用性、类库和开发环境、其他因素等。</p>
</li>
<li><p>良好的面向对象程序设计风格主要有哪些准则？ 提高可重用性、提高可扩充性、提高健壮性。</p>
</li>
<li><p>测试面向对象软件时，单元测试、集成测试和确认测试各有哪些新特点？<br>单元测试是在类层面上的测试。由于继承和复合，类    ( 或对象) 在很多情况下已不再是单纯意义上的单个操作了。因此，具体的测试将在所有与该操作有关的每个子类语境中进行。<br>集成测试由于面向对象软件中类的成分的直接和间接交互，使得传统测试方法已经失去意义。因此有两种策略可供选择：基于线程的测试和基于使用的测试。<br>确认测试与传统确认测试一样，仍然关注于用户可见的动作和用户可识别的系统输出，但是，基于场景的测试总是主宰面向对象系统的确认测试。</p>
</li>
<li><p>测试面向对象软件时，主要有哪些设计单元测试用例的方法？</p>
</li>
</ol>
<p>随机测试、划分测试和基于故障的测试。</p>
<ol>
<li><p>测试面向对象软件时，主要有哪些设计集成测试用例的方法？<br>多类测试、从动态模型中导出测试用例。也可以采用随机测试、划分测试的方法。</p>
</li>
<li><p>测试面向对象软件时，主要有哪些设计确认测试用例的方法？ 可以采用传统的黑盒方法，也可以采用基于情景的方法。</p>
</li>
</ol>
<p>第十二章    项目管理</p>
<ol>
<li><p>请简单描述有哪些进行软件规模估算的方法。代码行技术和功能点技术。</p>
</li>
<li><p>在工作量估算技术中，动态多变量模型比静态单变量模型有哪些优点？ 可以更精确地进行估算，估算结果更切合被估算对象的实际。</p>
</li>
<li><p>简述 Gantt 图的用途和优缺点。<br>优点：简单，能动态地反映开发进展。 缺点：难以反映多个任务间的逻辑关系。</p>
</li>
<li><p>简述关键路径法    CPM工作步骤<br>(1)    标出持续时间 Lasting Time<br>(2)    标出最早开始    时间 EST: =    从起点始，所有进入事件的    EST+LT 中最大的<br>(3)    标出最迟开始时间    LST: =    从终点 (EST = LST) 始，所有离开事件的    LST    LT 中最小的<br>(4)    标出机动时间 ST: =    终点 LST    起点 EST    LT<br>(5)    标出关键路径 Critical Path:    即 EST = LST 的所有事件组成的路径</p>
</li>
<li><p>目前项目开发时常用的小组组织方法有哪些？<br>民主制程序员组、主程序员组和现代程序员组。</p>
</li>
<li><p>简述主程序员组的优缺点。<br>优点主要有：主程序员广播式发布工作要求，组织管理好、效率高、质量容易保证、成本相对较<br>低。<br>缺点主要有：人员完整配备较难、不利人才脱颖而出。并且，能够在技术和管理两方面都能同时<br>具备优秀品质的主程序员更不多见。</p>
</li>
<li><p>什么是软件质量？<br>软件质量就是软件与明确及隐含的需求相一致的程度。</p>
</li>
<li><p>软件质量保证的措施主要有哪些？<br>⑴ 审查：由组长、作者、    2 位评审员（与评审结果有利害关系的）组成审查小组，进行发现、记录错误的工作，并复查返工结果。</p>
</li>
</ol>
<p>⑵ 复查和管理复审：从技术、管理两方面进行的复查工作。<br>⑶ 测试</p>
<ol>
<li><p>参加软件质量保证活动的人员有哪两类？<br>可以分为两类：参与软件开发的技术人员，以及负责任软件质量保证活动的    SQA小组成员。</p>
</li>
<li><p>简述技术复审的必要性。<br>技术复审能够较早发现软件错误，    防止错误被带入到软件过程的后期阶段，    从而大大降低后续开发和维护的成本。</p>
</li>
<li><p>什么是软件能力成熟度模型？其基本思想是什么？<br>软件能力成熟度模型是用于评价软件开发机构的软件过程能力成熟度的模型，   其基本思想是， 采用能力成熟度模型来帮助软件开发机构建立一个有规律的、 成熟的软件过程， 以开发出质量更好的软件， 免受时间和成本超支之苦。</p>
</li>
<li><p>简述软件能力成熟度模型的 5 个等级。<br>(1)    初始级<br>(2)    可重复级<br>(3)    已定义级<br>(4)    已管理级<br>(5)    优化级</p>
</li>
</ol>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/12/19/%E5%A4%A7%E5%89%8D%E7%AB%AF/React%20-%20%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/">React - 最佳实践资料收集</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-12-19</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-12-19</span></span></div></header><div class="post-body"><div class="post-excerpt"><h1 id="React-最佳实践资料收集"   >
          <a href="#React-最佳实践资料收集" class="heading-link"><i class="fas fa-link"></i></a>React - 最佳实践资料收集</h1>
      <p>React解决方案很多, 那有没有最佳实践呢</p></div><div class="post-readmore"><a class="post-readmore__link" href="/2020/12/19/%E5%A4%A7%E5%89%8D%E7%AB%AF/React%20-%20%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/"><span class="post-readmore__text">阅读全文</span><span class="post-readmore__icon"><i class="fas fa-long-arrow-alt-right"></i></span></a></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/12/18/%E5%A4%A7%E5%89%8D%E7%AB%AF/Flutter%20-%2003%20%E4%BA%86%E8%A7%A3Flutter/">Flutter - 02 初识Flutter项目</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-12-18</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-12-19</span></span></div></header><div class="post-body"><div class="post-excerpt"><h1 id="Flutter-02-初识Flutter项目"   >
          <a href="#Flutter-02-初识Flutter项目" class="heading-link"><i class="fas fa-link"></i></a>Flutter - 02 初识Flutter项目</h1>
      <p>了解flutter和dart</p></div><div class="post-readmore"><a class="post-readmore__link" href="/2020/12/18/%E5%A4%A7%E5%89%8D%E7%AB%AF/Flutter%20-%2003%20%E4%BA%86%E8%A7%A3Flutter/"><span class="post-readmore__text">阅读全文</span><span class="post-readmore__icon"><i class="fas fa-long-arrow-alt-right"></i></span></a></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/12/16/Golang/Go%20-%2001%20-%E5%BC%80%E5%A7%8B%20Go/">Go - 01 - Hello Go Web</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-12-16</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-11-17</span></span></div></header><div class="post-body"><div class="post-excerpt"><h1 id="Go-01-Hello-Go-Web"   >
          <a href="#Go-01-Hello-Go-Web" class="heading-link"><i class="fas fa-link"></i></a>Go - 01 - Hello Go Web</h1>
      <p>在前端开发的过程中, 工作室的后端同学有点憨, 不能部署我打包好的Vue工程然后我找了一下, 找到了一个部署的Go代码, 之前我还学过一段时间Go,现在忘了, 把他捡起来.</p>
<p>Go又名Golang, 谷歌出品, 主攻网络编程, 标准库很方便, 语法很规范, 应用很广泛, 数量第二多的后端语言.</p>
<center> <img src="https://gitee.com/zjeff-953/picsBed/raw/master/image/20201216171103.svg"> </center></div><div class="post-readmore"><a class="post-readmore__link" href="/2020/12/16/Golang/Go%20-%2001%20-%E5%BC%80%E5%A7%8B%20Go/"><span class="post-readmore__text">阅读全文</span><span class="post-readmore__icon"><i class="fas fa-long-arrow-alt-right"></i></span></a></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/12/16/%E6%95%B0%E7%90%86%E5%9F%BA%E7%A1%80/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%20-%20%E8%B6%A3%E5%91%B3%E6%A6%82%E7%8E%87%E8%AE%BA%20-%20%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98js%E6%B1%82%E8%A7%A3/">概率论与数理统计 - 趣味概率论 - 三门问题js求解</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-12-16</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-12-31</span></span></div></header><div class="post-body"><div class="post-excerpt"><h1 id="概率论与数理统计-趣味概率论-三门问题js求解"   >
          <a href="#概率论与数理统计-趣味概率论-三门问题js求解" class="heading-link"><i class="fas fa-link"></i></a>概率论与数理统计 - 趣味概率论 - 三门问题js求解</h1>
      <p>本文对于经典概率论问题三门问题使用了多种方法求解，并基于web技术对于三门问题进行了模拟，便于读者直观的感受和体会三门问题。</p></div><div class="post-readmore"><a class="post-readmore__link" href="/2020/12/16/%E6%95%B0%E7%90%86%E5%9F%BA%E7%A1%80/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%20-%20%E8%B6%A3%E5%91%B3%E6%A6%82%E7%8E%87%E8%AE%BA%20-%20%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98js%E6%B1%82%E8%A7%A3/"><span class="post-readmore__text">阅读全文</span><span class="post-readmore__icon"><i class="fas fa-long-arrow-alt-right"></i></span></a></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/12/15/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%20-%2002%20%E6%85%95%E8%AF%BE%E9%A2%98%20/">软件工程 - 应试知识总结</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-12-15</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-12-26</span></span></div></header><div class="post-body"><div class="post-excerpt"><p><img src="https://gitee.com/zjeff-953/picsBed/raw/master/image/20201204212128.png" alt="image-20201204212128687"></p></div><div class="post-readmore"><a class="post-readmore__link" href="/2020/12/15/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%20-%2002%20%E6%85%95%E8%AF%BE%E9%A2%98%20/"><span class="post-readmore__text">阅读全文</span><span class="post-readmore__icon"><i class="fas fa-long-arrow-alt-right"></i></span></a></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/12/15/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%20-%2004%20%E5%88%86%E6%9E%90%E9%A2%98/">软件工程 - 分析题</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-12-15</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-12-27</span></span></div></header><div class="post-body"><div class="post-excerpt"><h1 id="软件工程-分析题"   >
          <a href="#软件工程-分析题" class="heading-link"><i class="fas fa-link"></i></a>软件工程 - 分析题</h1></div><div class="post-readmore"><a class="post-readmore__link" href="/2020/12/15/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%20-%2004%20%E5%88%86%E6%9E%90%E9%A2%98/"><span class="post-readmore__text">阅读全文</span><span class="post-readmore__icon"><i class="fas fa-long-arrow-alt-right"></i></span></a></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/12/15/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%20-%2006%20%E9%87%8D%E7%82%B9%E9%A2%98%E7%9B%AE/">计算机体系结构 - 重点题目</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-12-15</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-01-11</span></span></div></header><div class="post-body"><div class="post-excerpt"><h1 id="计算机体系结构-重点题目"   >
          <a href="#计算机体系结构-重点题目" class="heading-link"><i class="fas fa-link"></i></a>计算机体系结构 - 重点题目</h1>
      <p>错题,难题</p></div><div class="post-readmore"><a class="post-readmore__link" href="/2020/12/15/%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%20-%2006%20%E9%87%8D%E7%82%B9%E9%A2%98%E7%9B%AE/"><span class="post-readmore__text">阅读全文</span><span class="post-readmore__icon"><i class="fas fa-long-arrow-alt-right"></i></span></a></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/12/09/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94%20-%2005%20%E8%AE%B0%E5%8D%9A%E5%AE%A2%E5%92%8C%E7%AC%94%E8%AE%B0%E7%9A%84%E6%96%B9%E5%BC%8F/">生活随笔 - 05 记博客和笔记的方式</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-12-09</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-01-12</span></span></div></header><div class="post-body"><div class="post-excerpt"><h1 id="随笔-05-记博客和笔记的方式"   >
          <a href="#随笔-05-记博客和笔记的方式" class="heading-link"><i class="fas fa-link"></i></a>随笔 - 05 记博客和笔记的方式</h1>
      <p>记了这么多笔记, 却感觉脑子空空的, 是打开方式不对</p></div><div class="post-readmore"><a class="post-readmore__link" href="/2020/12/09/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94%20-%2005%20%E8%AE%B0%E5%8D%9A%E5%AE%A2%E5%92%8C%E7%AC%94%E8%AE%B0%E7%9A%84%E6%96%B9%E5%BC%8F/"><span class="post-readmore__text">阅读全文</span><span class="post-readmore__icon"><i class="fas fa-long-arrow-alt-right"></i></span></a></div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/16/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/18/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://gitee.com/zjeff-953/picsBed/raw/master/image/cat.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">Keep Curious</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/github" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">知</span></a><a class="sidebar-ov-social-item" href="1572754810" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="https://gitee.com/zjeff-953" target="_blank" rel="noopener" data-popover="码云" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-git"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">195</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">34</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">50</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2021</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Jeffords zuo</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.4.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.1.1</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><link href="//cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" rel="stylesheet" type="text/css"><link href="//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.css" rel="stylesheet" type="text/css"><script src="//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.js"></script><script src="/js/utils.js?v=2.1.1"></script><script src="/js/stun-boot.js?v=2.1.1"></script><script src="/js/scroll.js?v=2.1.1"></script><script src="/js/header.js?v=2.1.1"></script><script src="/js/sidebar.js?v=2.1.1"></script></body></html>