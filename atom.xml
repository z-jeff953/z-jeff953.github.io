<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jeff&#39;s blog</title>
  
  <subtitle>Keep Curious , Keep Learning !</subtitle>
  <link href="http://zjeff-953.gitee.io/zjeff/atom.xml" rel="self"/>
  
  <link href="http://zjeff-953.gitee.io/zjeff/"/>
  <updated>2022-07-20T23:37:38.592Z</updated>
  <id>http://zjeff-953.gitee.io/zjeff/</id>
  
  <author>
    <name>Jeffords zuo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>实习经历 - 字节跳动Data</title>
    <link href="http://zjeff-953.gitee.io/zjeff/2022/07/21/%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86%20-%20%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8Data/"/>
    <id>http://zjeff-953.gitee.io/zjeff/2022/07/21/%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86%20-%20%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8Data/</id>
    <published>2022-07-20T23:29:43.655Z</published>
    <updated>2022-07-20T23:37:38.592Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="实习经历-字节跳动"   >          <a href="#实习经历-字节跳动" class="heading-link"><i class="fas fa-link"></i></a>实习经历 - 字节跳动</h1>      <span id="more"></span><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202207210737061.png" alt="image-20220721073545315"></p>]]></content>
    
    
    <summary type="html">描述</summary>
    
    
    
    <category term="分类" scheme="http://zjeff-953.gitee.io/zjeff/categories/%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="标签" scheme="http://zjeff-953.gitee.io/zjeff/tags/%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>实习经历 - 深圳腾讯CSIG腾讯云</title>
    <link href="http://zjeff-953.gitee.io/zjeff/2022/07/21/%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86%20-%20%E6%B7%B1%E5%9C%B3%E8%85%BE%E8%AE%AFCDG%E8%85%BE%E8%AE%AF%E5%85%AC%E7%9B%8A/"/>
    <id>http://zjeff-953.gitee.io/zjeff/2022/07/21/%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86%20-%20%E6%B7%B1%E5%9C%B3%E8%85%BE%E8%AE%AFCDG%E8%85%BE%E8%AE%AF%E5%85%AC%E7%9B%8A/</id>
    <published>2022-07-20T23:29:41.751Z</published>
    <updated>2022-05-27T02:37:26.143Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="实习经历-深圳腾讯CSIG腾讯云"   >          <a href="#实习经历-深圳腾讯CSIG腾讯云" class="heading-link"><i class="fas fa-link"></i></a>实习经历 - 深圳腾讯CSIG腾讯云</h1>      <span id="more"></span><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112160007957.jpg" alt="0 (6)"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112160007393.jpg" alt="0 (5)"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112160007904.jpg" alt="0 (1)"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112160008595.jpg" alt="0 (4)"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112160007832.jpg" alt="0 (3)"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112160008818.jpg" alt="0 (9)"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112160009636.jpg" alt="0 (10)"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112160004998.jpg" alt="TCA"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112160008242.jpeg" alt="Practitioner"></p>]]></content>
    
    
    <summary type="html">描述</summary>
    
    
    
    <category term="分类" scheme="http://zjeff-953.gitee.io/zjeff/categories/%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="标签" scheme="http://zjeff-953.gitee.io/zjeff/tags/%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>算法 - 09 - 动态规划分类题型</title>
    <link href="http://zjeff-953.gitee.io/zjeff/2022/06/25/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%20-%2009%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%86%E7%B1%BB%E9%A2%98%E5%9E%8B/"/>
    <id>http://zjeff-953.gitee.io/zjeff/2022/06/25/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%20-%2009%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%86%E7%B1%BB%E9%A2%98%E5%9E%8B/</id>
    <published>2022-06-24T16:00:00.000Z</published>
    <updated>2022-06-29T02:43:17.645Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="算法-09-动态规划分类题型"   >          <a href="#算法-09-动态规划分类题型" class="heading-link"><i class="fas fa-link"></i></a>算法 - 09 - 动态规划分类题型</h1>      <span id="more"></span>        <h2 id="动态规划使用场景"   >          <a href="#动态规划使用场景" class="heading-link"><i class="fas fa-link"></i></a>动态规划使用场景</h2>      <ol><li>求最值</li><li>求可行性</li><li>求方案总数</li></ol>        <h2 id="动态规划题型分类"   >          <a href="#动态规划题型分类" class="heading-link"><i class="fas fa-link"></i></a>动态规划题型分类</h2>      <ol><li>坐标型<ol><li>一维坐标</li><li>二维坐标</li></ol></li><li>前缀型<ol><li>划分型</li><li>匹配型</li></ol></li><li>背包型</li><li>区间型</li></ol>        <h2 id="坐标型"   >          <a href="#坐标型" class="heading-link"><i class="fas fa-link"></i></a>坐标型</h2>              <h4 id="120-三角形最小路径和"   >          <a href="#120-三角形最小路径和" class="heading-link"><i class="fas fa-link"></i></a>120. 三角形最小路径和</h4>              <h4 id="118-杨辉三角"   >          <a href="#118-杨辉三角" class="heading-link"><i class="fas fa-link"></i></a>118. 杨辉三角</h4>              <h4 id="119-杨辉三角-II"   >          <a href="#119-杨辉三角-II" class="heading-link"><i class="fas fa-link"></i></a>119. 杨辉三角 II</h4>              <h4 id="62-不同路径"   >          <a href="#62-不同路径" class="heading-link"><i class="fas fa-link"></i></a>62. 不同路径</h4>      <p><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/unique-paths/" >62. 不同路径 - 力扣（LeetCode）</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
    
    
    <summary type="html">算法 - 09 - 动态规划分类题型</summary>
    
    
    
    <category term="分类" scheme="http://zjeff-953.gitee.io/zjeff/categories/%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="算法" scheme="http://zjeff-953.gitee.io/zjeff/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>软件测试 - 04 - 使用postman和jmeter</title>
    <link href="http://zjeff-953.gitee.io/zjeff/2022/06/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%20-%2004%20-%20%E4%BD%BF%E7%94%A8postman%E5%92%8Cjmeter/"/>
    <id>http://zjeff-953.gitee.io/zjeff/2022/06/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%20-%2004%20-%20%E4%BD%BF%E7%94%A8postman%E5%92%8Cjmeter/</id>
    <published>2022-06-02T07:24:10.114Z</published>
    <updated>2022-05-27T02:37:26.150Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="软件测试-04-使用postman和jmeter"   >          <a href="#软件测试-04-使用postman和jmeter" class="heading-link"><i class="fas fa-link"></i></a>软件测试 - 04 - 使用postman和jmeter</h1>      <p>[TOC]</p><span id="more"></span>        <h2 id="1-Postman"   >          <a href="#1-Postman" class="heading-link"><i class="fas fa-link"></i></a>1. Postman</h2>      <p>采用Postman接口测试软件对百度百科（<span class="exturl"><a class="exturl__link"   href="https://baike.baidu.com/）搜索引擎进行接口测试。如对词条“软件工程”返回页面内容进行测试验证，给出请求参数设置、Tests脚本、Body响应结果、Test" >https://baike.baidu.com/）搜索引擎进行接口测试。如对词条“软件工程”返回页面内容进行测试验证，给出请求参数设置、Tests脚本、Body响应结果、Test</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>Results结果说明及运行界面。</p>        <h3 id="参数设置："   >          <a href="#参数设置：" class="heading-link"><i class="fas fa-link"></i></a>参数设置：</h3>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501173312.png" alt="">首先观察百度百科搜索界面的Url,<br>我们可以发现</p><p>百度百科搜索结果采用的是地址定位模式, 查询词条XXX的时候将会定向到路由:<br><span class="exturl"><a class="exturl__link"   href="https://baike.baidu.com/item/XXX" >https://baike.baidu.com/item/XXX</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> , 然后就会加上对应的词条id,<br>而且采用的隐式参数模式我们并不能简单的看到params是什么,<br>所以直接输入这个url发送get请求就可以获取对应的返回体, 返回体应该是一个html页面,<br>所以只需要设置简单的url和选择get方法就可以了。</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501173321.png" alt=""></p><p>经过测试发现地址最后的标识id可以不写也能获取到正确的页面内容，所以我们可以这样进行接口测试</p>        <h3 id="Tests脚本B："   >          <a href="#Tests脚本B：" class="heading-link"><i class="fas fa-link"></i></a>Tests脚本B：</h3>      <p>这是postman中的test脚本的生命期，我们可以对于response进行javascript的<img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501173323.png" alt=""></p><p>脚本处理，我想要验证接口是否能正常调用，返回的内容是不是我们期望的，所以我们要验证他的statuscode是不是200，html内容有没有包含“软件工程”，接口的返回时间是不是小于200ms三件事，所以我们需要编写三段脚本：</p><figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试接口是否可以访问  </span></span><br><span class="line">pm.test(<span class="string">&quot;Status code is 200&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  </span><br><span class="line">pm.response.to.have.status(<span class="number">200</span>);  </span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试接口返回时间  </span></span><br><span class="line">pm.test(<span class="string">&quot;Response time is less than 200ms&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">pm.expect(pm.response.responseTime).to.be.below(<span class="number">200</span>);  </span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试内容是否正确  </span></span><br><span class="line">pm.test(<span class="string">&quot;Body contains 软件工程&quot;</span>,() =\&gt; &#123;  </span><br><span class="line">pm.expect(pm.response.text()).to.include(<span class="string">&quot;软件工程&quot;</span>);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></div></figure>        <h3 id="Test-Results结果说明："   >          <a href="#Test-Results结果说明：" class="heading-link"><i class="fas fa-link"></i></a>Test Results结果说明：</h3>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501173327.png" alt="">运行结果如下：</p><p>这样我们可以看到这个接口能够成功的接受请求发送响应并返回正确的结果<br>，但是响应速度不是很快，不过一次测试可信度不是很高，所以我们可以试验多次查看一下效果：</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501173704.png" alt=""><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501173602.png" alt=""><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501173600.png" alt=""><img src="media/8c9c301424f3388e259703ae09ada77e.png" alt=""></p><p>可以看到经过五次的测试，我们可以看到有两次能够满足200ms内完成响应，还有较大提升空间</p>        <h3 id="Body结果说明："   >          <a href="#Body结果说明：" class="heading-link"><i class="fas fa-link"></i></a>Body结果说明：</h3>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501173559.png" alt=""></p><p>可以看到能够正常返回html页面，结果也正确。（还有部分搜索引擎优化）</p><p>点击preview，也可以观察页面能够成功渲染</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501173557.png" alt=""></p>        <h3 id="运行界面："   >          <a href="#运行界面：" class="heading-link"><i class="fas fa-link"></i></a>运行界面：</h3>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501173555.png" alt=""></p>        <h2 id="2-JMeter"   >          <a href="#2-JMeter" class="heading-link"><i class="fas fa-link"></i></a>2. JMeter</h2>      <p>采用JMeter性能测试软件对百度搜索引擎查询“软件测试”页面内容进行性能测试，给出50、100并发用户的测试过程说明及性能测试运行结果界面。</p>        <h3 id="分析搜索的url"   >          <a href="#分析搜索的url" class="heading-link"><i class="fas fa-link"></i></a>分析搜索的url</h3>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501173552.png" alt=""></p><p>首先对百度搜索结果的的url进行分析，百度采用的是https协议, 除了百度的域名，有s路由标识所搜结果，wd和ie两个params分别标识查询参数和编码类型，然后我们就可以对他进行性能测试。</p>        <h3 id="下载和安装JMeter"   >          <a href="#下载和安装JMeter" class="heading-link"><i class="fas fa-link"></i></a>下载和安装JMeter</h3>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501173718.png" alt="">进入JMeter官网，点击Download下载</p><p>点击下载编译后的版本</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501173721.png" alt=""></p>        <h3 id="运行Jmeter"   >          <a href="#运行Jmeter" class="heading-link"><i class="fas fa-link"></i></a>运行Jmeter</h3>      <p>将文件解压后进入解压后的文件夹目录</p><p>运行 解压目录\apache-jmeter-5.4.1\bin\jmeter.sh</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501173724.png" alt="">之后会运行这个shell脚本,这个shell脚本不能关闭</p><p>然后就会打开JMeter的页面</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501173744.png" alt=""></p><p>这样就安装成功并进入JMeter了</p>        <h3 id="创建测试计划并添加线程组"   >          <a href="#创建测试计划并添加线程组" class="heading-link"><i class="fas fa-link"></i></a>创建测试计划并添加线程组</h3>      <p>首先给测试计划改个名字</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501173749.png" alt=""></p><p>右键测试计划, 添加线程组</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501173804.png" alt=""></p><p>按照前面的分析,填写对应的参数,<br>请求类型, url ,参数, 输入中文的时候要勾选编码项</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501173824.png" alt="">然后设置对应的线程数和循环次数<br>Rame-Up时间表示在多少秒内启动对应线程数的线程,先设置成1试一下能不能成功进行访问</p>        <h3 id="添加http请求"   >          <a href="#添加http请求" class="heading-link"><i class="fas fa-link"></i></a>添加http请求</h3>      <p>然后为线程组添加http请求取样器</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501173820.png" alt=""></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501173926.png" alt=""></p>        <h3 id="添加请求头管理器"   >          <a href="#添加请求头管理器" class="heading-link"><i class="fas fa-link"></i></a>添加请求头管理器</h3>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501173924.png" alt=""></p>        <h3 id="添加查看结果树"   >          <a href="#添加查看结果树" class="heading-link"><i class="fas fa-link"></i></a>添加查看结果树</h3>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501173932.png" alt=""></p>        <h3 id="启动线程组"   >          <a href="#启动线程组" class="heading-link"><i class="fas fa-link"></i></a>启动线程组</h3>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501173934.png" alt=""></p>        <h3 id="验证结果并解决百度反爬"   >          <a href="#验证结果并解决百度反爬" class="heading-link"><i class="fas fa-link"></i></a>验证结果并解决百度反爬</h3>      <p>可以看到触发了百度的反爬机制,不能测试到正确的页面</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501173937.png" alt=""></p><p>参考文章:</p><p><span class="exturl"><a class="exturl__link"   href="https://jingyan.baidu.com/article/e4d08ffdc1225b4ed3f60d3c.html" >https://jingyan.baidu.com/article/e4d08ffdc1225b4ed3f60d3c.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>我们应该设置请求头</p><p>首先打开网页并打开控制台查看需要哪些请求头, 然后将他们全部复制,</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501174000.png" alt=""></p><p>点击请求头管理器,<br>然后从剪贴板添加<img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501174003.png" alt=""></p><p>然后我们就可以获取到所有需要的头了</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501174006.png" alt=""></p><p>运行后查看响应结果</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501174008.png" alt=""></p><p>需要向下滚动查看更多</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501174010.png" alt="">也可搜索查看是否得到正确结果</p>        <h3 id="测试50个线程的结果"   >          <a href="#测试50个线程的结果" class="heading-link"><i class="fas fa-link"></i></a>测试50个线程的结果</h3>      <p>清除一下结果</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501174012.png" alt=""></p><p>然后我们就可以添加一些其他的检测器, 开始性能测试</p><p>修改线程数为50, 点击运行</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501174031.png" alt=""></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501174033.png" alt="">查看结果树</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501174036.png" alt="">查看聚合报告</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501174038.png" alt="">查看汇总报告</p>        <h4 id="聚合报告属性含义"   >          <a href="#聚合报告属性含义" class="heading-link"><i class="fas fa-link"></i></a>聚合报告属性含义</h4>      <p>属性描述</p><p>名称 ：显示的此取样器的描述性名称，可自定义</p><p>文件名：要保存或/读取的测试结果文件名，包含路径</p><p>Label ：执行样品的标签，如HTTP请求的名称，事务控制器名称</p><p>样本<br>：执行的，具有相同标签的样本数量。需要注意，多个样本同名的将被统计在一起，所以在编写脚本时样品命名应该唯一，除非你希望这么做。</p><p>平均值： 一组样本的平均响应时间</p><p>中位数： 一组样本中间的响应时间，50%大于此值，50%小于此值</p><p>90%百分位 ：90％的样品响应时间不超过此时间，剩下的至少需要这么长</p><p>95%百分位 ：95％的样品响应时间不超过此时间，剩下的至少需要这么长</p><p>99%百分位 ：99％的样品响应时间不超过此时间，剩下的至少需要这么长</p><p>最小值 ：一组样本中最短的响应时间</p><p>最大值 ：一组样本中最长的响应时间</p><p>异常% ：执行失败的请求占一组样本的百分比</p><p>吞吐量<br>：以每秒/分钟/小时的请求数衡量。以使显示的速率至少为1.0。代表完成的请求数/秒/分钟/小时，通常可以反应服务器的事务处理能力</p><p>接收/sec： 数据接收速率，反应获取数据的网络使用情况</p><p>发送/sec： 数据发送速率，反应发送数据的网络使用情况</p>        <h4 id="汇总报告属性描述"   >          <a href="#汇总报告属性描述" class="heading-link"><i class="fas fa-link"></i></a>汇总报告属性描述</h4>      <p>名称 ：显示的此取样器的描述性名称，可自定义</p><p>文件名 ：要保存或/读取的测试结果文件名，包含路径</p><p>Label ：执行样品的标签，如HTTP请求的名称，事务控制器名称</p><p>样本：<br>执行的，具有相同标签的样本数量。需要注意，多个样本同名的将被统计在一起，所以在编写脚本时样品命名应该唯一，除非你希望这么做。</p><p>平均值：一组样本的平均响应时间</p><p>最小值： 一组样本中最短的响应时间</p><p>最大值：一组样本中最长的响应时间</p><p>异常%： 执行失败的请求占一组样本的百分比</p><p>吞吐量：<br>以每秒/分钟/小时的请求数衡量。以使显示的速率至少为1.0。代表完成的请求数/秒/分钟/小时，通常可以反应服务器的事务处理能力</p><p>接收/sec： 数据接收速率，反应获取数据的网络使用情况</p><p>发送/sec： 数据发送速率，反应发送数据的网络使用情况</p><p>平均字节数： 样本响应数据的平均大小，以字节为单位</p><p>可以看到百度的搜索性能还是较好的</p>        <h3 id="模拟100个用户并发"   >          <a href="#模拟100个用户并发" class="heading-link"><i class="fas fa-link"></i></a>模拟100个用户并发</h3>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501174051.png" alt="">然后修改线程数为100, 模拟100个用户并发</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501174114.png" alt=""></p><p><img src="media/f289cedb42a8cc3946dbdfb57148bea8.png" alt=""></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210501174134.png" alt=""></p>]]></content>
    
    
    <summary type="html">软件测试 - 04 - 使用postman和jmeter</summary>
    
    
    
    <category term="基础知识" scheme="http://zjeff-953.gitee.io/zjeff/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>软件测试 - 01 软件测试理论</title>
    <link href="http://zjeff-953.gitee.io/zjeff/2022/06/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%20-%2001%20%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    <id>http://zjeff-953.gitee.io/zjeff/2022/06/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%20-%2001%20%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/</id>
    <published>2022-06-02T07:24:10.111Z</published>
    <updated>2022-05-27T02:37:26.150Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="软件测试-01-软件测试理论"   >          <a href="#软件测试-01-软件测试理论" class="heading-link"><i class="fas fa-link"></i></a>软件测试 - 01 软件测试理论</h1>      <span id="more"></span>        <h2 id="软件质量属性"   >          <a href="#软件质量属性" class="heading-link"><i class="fas fa-link"></i></a>软件质量属性</h2>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210627230042.png" alt=""></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210627230047.png" alt="image-20210627230047099"></p>        <h2 id="软件质量标准"   >          <a href="#软件质量标准" class="heading-link"><i class="fas fa-link"></i></a>软件质量标准</h2>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210627230122.png" alt="image-20210627230122617"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210627230640.png" alt="image-20210627230640761"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210627230648.png" alt="image-20210627230647890"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210627230659.png" alt="image-20210627230659006"></p>        <h2 id="软件缺陷"   >          <a href="#软件缺陷" class="heading-link"><i class="fas fa-link"></i></a>软件缺陷</h2>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210627230726.png" alt="image-20210627230726532"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210627230736.png" alt="image-20210627230735744"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210627230800.png" alt="image-20210627230800139"></p>        <h2 id="软件测试"   >          <a href="#软件测试" class="heading-link"><i class="fas fa-link"></i></a>软件测试</h2>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210627230909.png" alt="image-20210627230908790"></p>        <h2 id="测试方法"   >          <a href="#测试方法" class="heading-link"><i class="fas fa-link"></i></a>测试方法</h2>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210627231657.png" alt="image-20210627231656777"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210627234550.png" alt="image-20210627234550713"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210627234646.png" alt="image-20210627234646310"></p><p>白盒测试辨析</p><p><img src="C:\Users\15727\AppData\Roaming\Typora\typora-user-images\image-20210628072427227.png" alt="image-20210628072427227"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628072436.png" alt=""></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628072452.png" alt="image-20210628072452435"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628072501.png" alt="image-20210628072501100"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628072509.png" alt="image-20210628072509770"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628072516.png" alt="image-20210628072516300"></p>        <h2 id="软件测试过程"   >          <a href="#软件测试过程" class="heading-link"><i class="fas fa-link"></i></a>软件测试过程</h2>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628002153.png" alt="image-20210628002152912"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628001920.png" alt="image-20210628001920296"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628001926.png" alt="image-20210628001926173"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628001941.png" alt="image-20210628001941394"></p>        <h2 id="质量保证"   >          <a href="#质量保证" class="heading-link"><i class="fas fa-link"></i></a>质量保证</h2>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628005515.png" alt="image-20210628005514758"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628005522.png" alt="image-20210628005522258"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628005530.png" alt="image-20210628005530629"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628005546.png" alt="image-20210628005545829"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628005556.png" alt="image-20210628005555950"></p>        <h1 id="总结"   >          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h1>      <p>•    软件测试的正向理解<br>o    验证软件的正确性，给用户以信心。<br>•    软件测试的反向理解<br>o    检测程序的错误，发现以前未发现的错误。<br>•    狭义的软件测试<br>o    仅仅指动态测试，运行程序以检测错误，验证软件是否符合用户需求，是否可以正常工作。<br>•    广义的软件测试<br>o    不仅是动态地运行程序，还包括程序代码、设计、文档的审查活动，是静态测试+动态测试。<br>•    测试=V&amp;V<br>o    verification验证：验证程序是否满足文档中说明的需求。<br>o    validation有效性确认：确认软件满足用户的真正需求。<br>•    TestOracle的来源，如何确定预期测试结果<br>o    软件测试结果的正确性，有时不易判断。testoracle的来源主要有用户期望、产品愿景、竞品、常识、数据统计等。当给定一个测试用例的输入时，要把经过该系统的实际输出与测试预言所期望的输出结果作对比。<br>•    黑盒测试<br>o    把一个软件看做一个黑盒，我们不关心程序内部结构，只关心输入数据和输出数据。<br>•    白盒测试<br>o    把盒子打开，分析程序源代码和结构的测试。<br>•    静态测试<br>o    不实际运行程序，而只是静态地对代码、界面和文档进行审查，发现其中的不合理或者错误。<br>•    动态测试<br>o    实际运行程序，给定一个测试用例输入，看程序的输出是否与预期输出相符的测试。<br>•    单元测试<br>o    又称模块测试，针对软件设计中最小的单位——程序模块进行测试，检验其正确性的过程。<br>•    集成测试<br>o    又称组装测试，在单元测试的基础上，将所有的程序模块进行有序的、递增的测试。<br>•    系统测试<br>o    将软件系统看做一个整体进行测试，包括对系统的功能测试、性能测试以及运行系统的软硬件环境的测试。<br>•    验收测试<br>o    根据软件说明书或合同，供需双方所依赖的软件说明书进行测试，甲方可以选择接收或者拒收系统。在系统测试的后期，由用户和测试人员（测试质量保证人员）共同完成的测试。<br>o    验收测试：按照项目任务书或合同，供需双方约定的验收依据文档进行的对整个系统的测试与评审，决定是否接收或拒收系统。在系统测试的后期，以用户测试为主或有测试人员等质量保证人员共同参与的测试。<br>o    阿尔法测试：由用户、开发人员、测试人员共同完成的内部测试。<br>o    贝塔测试：完全由最终用户完成的公测。<br>•    功能测试<br>o    是黑盒测试的一方面，包括逻辑功能测试、界面测试、易用性测试、安装测试、兼容性测试。<br>•    性能测试<br>o    利用自动化测试工具模拟程序在正常、峰值、异常负载下的性能测试指标情况，包括时间性能、空间性能、需求性能测试？？、基准测试、负载测试、压力测试等。<br>o    通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。有时间性能、空间性能、一般性能测试、可靠性测试、负载测试、压力测试<br>o    基准测试：为了得到平衡点，找到平衡点，对一类测试对象的某项性能指标进行定量的和可对比的测试<br>o    负载测试：在一个给定的负载压力下，资源不足的情况下，看系统是否能承受住。指数据在超负荷环境中运行，程序是否能够承担<br>o    压力测试：为了得到临界点，不断提高负载，测试系统的临界负载值。找到临界点， 压力测试（又叫强度测试）也是一种性能测试，它在系统资源特别低的情况下软件系统运行情况，目的是找到系统在哪里失效以及如何失效的地方。<br>•    回归测试<br>o    对程序进行修改后重新做的测试，比如使用原来的测试用例，这样做的目的是确保在调试程序时没有引入新的bug。<br>•    冒烟测试<br>o    在对一个系统做大规模的测试之前，先检查它的基本功能完成情况，确认程序的可测试性？？？<br>•    随机测试<br>o    程序中所有的输入都是随机生成的，用来模拟用户的输入情况，来检测程序的边缘性。<br>•    软件缺陷的定义<br>o    软件未达到产品说明书中指明的功能<br>o    软件出现了产品说明书中标明的不会出现的功能<br>o    软件超出了产品说明书中标明的的范围<br>o    软件未达到产品说明书中标明的应达到的目的<br>o    测试人员认为软件难以理解，运行速度慢，或最终用户觉得软件不好<br>o    满足以上任意一种情况，即可认为软件有缺陷<br>•    软件缺陷的属性<br>o    ID<br>o    标题<br>o    测试环境<br>o    严重等级<br>o    优先级<br>o    类别<br>o    状态<br>o    描述信息<br>o    重现步骤<br>o    附件<br>o    测试人员<br>o    处理人员<br>•    软件缺陷的级别<br>o    1严重缺陷 不能执行程序基本功能 无法更改 或者严重危及人身安全<br>o    2较大缺陷 严重影响程序基本功能 可以更改<br>o    3较小缺陷 影响程序<br>o    4轻微缺陷 影响使用人员操作 但不影响基本功能使用<br>o    5其他缺陷 其他<br>•    软件缺陷的生命周期<br>o    提交（打开）缺陷<br>o    指派（转交）缺陷<br>o    推迟处理<br>o    确认缺陷<br>o    处理缺陷<br>o    固定<br>o    回归缺陷<br>o    关闭缺陷<br>o    重新打开<br>•    软件测试的充分性的定义和度量<br>o    用来度量一个给定的软件测试集T是否能验证软件P满足需求R<br>o    度量    测试充分性准则C是他的度量。充分性的测试依赖一个测试机T？？？？<br>o    是相对于具体的测试充分性准则C的。测试集的充分性评估是由一个有限集来度量，根据所依赖的充分性准则，有限集中的元素由软件需求或代码导出。对于每一个测试准则C,我们都可以得到一个有限集，称之为覆盖域Ce. </p><p>•    软件测试终止准则<br>o    基于测试阶段的原则<br>o    根据测试用例的原则<br>o    基于缺陷收敛趋势和缺陷修复率的原则<br>o    根据验收测试的原则<br>o    软件项目暂停或终止，则对应的测试也暂停或终止<br>•    测试用例的作用<br>o    测试用例是测试工作的指导，是软件测试必须遵守的准则，更是软件测试质量稳定的根本保障。<br>•    测试用例的准则<br>o    用户需求<br>•    测试用例的原则<br>o    使用成熟的测试用例设计方法设计测试用例<br>o    测试用例的针对性<br>o    测试用例的代表性<br>o    测试用例的可判断性<br>o    测试用例的可重现性<br>o    足够详细、准确、清晰的步骤<br>o    测试用例必须符合内部的规范和要求<br>•    测试用例的特性<br>o    针对性<br>o    代表性<br>o    可判断性<br>o    可重现性<br>•    测试用例的组成元素<br>测试用例编号<br>测试用例名称<br>测试用例设计者<br>软件版本<br>测试目的<br>参考信息</p><p>o    测试用例编号<br>o    测试用例名称<br>o    测试用例设计者<br>o    软件版本号<br>o    测试目的<br>o    参考信息<br>o    测试条件<br>o    测试环境<br>o    输入数据<br>o    操作步骤<br>o    预期结果</p><p>•    测试用例分类<br>o    接口测试用例、路径测试用例、功能测试用例<br>o    容错能力、性能、界面测试用例<br>o    安全性、压力、可靠性、安装/反安装测试用例<br>•    面向对象覆盖<br>o    上下文覆盖<br>o    ？？？？<br>o    继承上下文覆盖<br>o    基于状态的上下文覆盖<br>•    正交试验设计法<br>o    是一种成对测试交互的系统的统计方法。它提供了一种能对所有变量对的组合进行典型覆盖（均匀分布）的方法。<br>•    软件测试的各个阶段<br>o    明确测试需求和目的<br>o    测试计划<br>o    测试设计<br>o    测试执行<br>o    测试记录和缺陷跟踪<br>o    回归测试<br>o    测试总结和报告<br>o    plan do check action PDCA<br>•    软件测试度量的目的和原则<br>o    为了保证软件质量，提高开发测试效率<br>o    改进软件测试的质量，提高测试效率<br>o    严格遵守软件测试规范要制定明确的度量目标<br>o    测试标准的定义应该具有一致性、客观性<br>o    测试方法应该尽可能简单，可计算<br>o    测试数据的收集应该尽可能自动化<br>•    影响软件产品质量的各个因素<br>o    软件复杂度<br>o    采用的设计架构<br>o    源代码控制<br>o    代码审查<br>o    软件测试<br>o    开发的语言和工具<br>o    外部组建的质量<br>o    需求变更控制<br>o    进度控制<br>o    开发资源的投入<br>•    bug综合评价模型包括哪些因素<br>o    数量 测试过程 定量 质量 测试人员 定性<br>•    第三方测试的概念<br>o    由用户、开发人员以外的第三方进行的软件测试，目的是为了保证测试的客观性<br>•    第三方测试的模式<br>o    以顾客为桥梁<br>o    以开发人员为桥梁<br>•    第三方测试的职责<br>o    验证软件是否符合产品说明书的需求<br>o    检测错误<br>o    对错误进行分类分析，将分析结果反馈给开发人员以促进开发过程管理<br>•    软件能力成熟度模型CMMI概念<br>o    capability maturity model integration<br>o    是一个多学科融合、可扩充的软件产品集合<br>o    用于帮助软件企业管理开发和控制过程，增强开发和控制能力，以在规定时间内，不超过预算的情况下开发出高质量的软件产品。<br>•    四类软件测试<br>o    开发者测试<br>    将Junit包引入被测程序中<br>    生成Junit框架<br>    运行测试代码<br>o    移动测试<br>    appium是一个集成测试框架<br>    uiautomatorviewer是用来查看app控件的<br>o    嵌入式测试<br>    Etest模拟外围环境进行测试<br>o    web测试<br>    selenium 记录<br>o    安全测试<br>    IT软件产品生命周期中 验证软件是否符合安全需求的过程</p>        <h1 id="课堂练习"   >          <a href="#课堂练习" class="heading-link"><i class="fas fa-link"></i></a>课堂练习</h1>      <p>感谢@dwy救命</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628004812.png" alt="image-20210628004812211"></p><p>测试只是质量保证工作中的一个环节。软件测试和软件质量保证是软件质量工程的两个不同层面的工作。<br>质量保证（QA）：质量保证的重要工作通过预防、检查与改进来保证软件质量。所关注的是软件质量的检查与测量。QA的工作是软件生命周期的管理以及验证软件是否满足规定的质量和用户的需求，因此主要着眼于软件开发活动中的过程、步骤和产物，而不是对软件进行剖析找出问题或评估。<br>软件测试：测试关心的不是过程的活动，而是对过程的产物以及开发出的软件进行剖析。测试人员要“执行”软件，对过程中的产物——开发文档和源代码进行走查，运行软件，以找出问题，报告质量。对测试中发现的问题的分析、追踪与回归测试也是软件测试中的重要工作，因此软件测试是保证软件质量的一个重要环节。</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628004940.png" alt="image-20210628004940668"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628004952.png" alt="image-20210628004952506"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628005005.png" alt="image-20210628005005507"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628005041.png" alt="image-20210628005041520"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628005101.png" alt="image-20210628005101282"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628005131.png" alt="image-20210628005130937"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628005149.png" alt="image-20210628005148802"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628005201.png" alt="image-20210628005201118"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628005215.png" alt="image-20210628005215637"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628005224.png" alt="image-20210628005224657"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628005235.png" alt="image-20210628005235063"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628005246.png" alt="image-20210628005246316"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628005257.png" alt="image-20210628005257056"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628005330.png" alt="image-20210628005329923"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628005337.png" alt="image-20210628005336860"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628005348.png" alt="image-20210628005347812"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628005358.png" alt="image-20210628005358360"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628005811.png" alt="image-20210628005811625"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628005836.png" alt="image-20210628005836218"></p>        <h1 id="单元测试"   >          <a href="#单元测试" class="heading-link"><i class="fas fa-link"></i></a>单元测试</h1>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628004714.jpg" alt="img"><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628004729.jpg" alt="img"><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628004703.jpg" alt="1"></p>        <h1 id="往届习题"   >          <a href="#往届习题" class="heading-link"><i class="fas fa-link"></i></a>往届习题</h1>      <div class="table-container"><div class="table-container"><table><thead><tr><th>piSeq</th><th>piContent</th><th>optionA</th><th>optionB</th><th>optionC</th><th>optionD</th><th>piAnswer</th></tr></thead><tbody><tr><td></td><td>CM1CM2</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>1</td><td>下面哪项活动不在软件测试范围 ？</td><td>A.需求文档评审</td><td>B.设计评审</td><td>C.代码测试</td><td>D.过程评审</td><td>D</td></tr><tr><td>2</td><td>软件测试的对象包括</td><td>A.目标程序和相关文档</td><td>B.源程序、目标程序、数据及相关文档</td><td>C.目标程序、操作系统和平台软件</td><td>D.源程序和目标程序</td><td>B</td></tr><tr><td>3</td><td>在软件开发接近完成时，执行下面哪种测试？</td><td>A.验收测试</td><td>B.α测试</td><td>C.β测试</td><td>D.系统测试</td><td>B</td></tr><tr><td>4</td><td>软件测试类型按开发阶段划分为</td><td>A.需求、单元、集成、验证测试</td><td>B.单元、集成、系统、验收测试</td><td>C.单元、集成、确认、验收测试</td><td>D.调试、单元、集成、用户测试</td><td>B</td></tr><tr><td>5</td><td>在软件质量模型中，可维护性属性不包括下面哪个子特性</td><td>A.适应性</td><td>B.易安装性</td><td>C.兼容性</td><td>D.一致性</td><td>C</td></tr><tr><td>6</td><td>软件质量是指</td><td>A.软件具有功能性 可靠性</td><td>B.最大限度满足用户需求</td><td>C.软件没有错误</td><td>D.软件满足用户需求的能力</td><td>D</td></tr><tr><td></td><td></td><td>可维护性 可移植性</td><td></td><td></td><td>和产品的固有特性</td><td></td></tr><tr><td>7</td><td>在所有软件缺陷中，哪类缺陷比例最高？</td><td>A.程序代码错误</td><td>B.软件设计错误</td><td>C.需求分析错误</td><td>D.其它</td><td>C</td></tr><tr><td>8</td><td>修复哪个阶段的软件缺陷，其成本最低？</td><td>A.需求分析阶段</td><td>B.系统设计阶段</td><td>C.程序编码阶段</td><td>D.软件发布阶段</td><td>A</td></tr><tr><td>9</td><td><strong>最基础的软件测试是什么？</strong></td><td>A.静态测试</td><td>B.动态测试</td><td>C.单元测试</td><td>D.集成测试</td><td>C</td></tr><tr><td>10</td><td>软件测试的主要目的是</td><td></td><td></td><td></td><td></td><td>BC</td></tr><tr><td></td><td>CM3</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>1</td><td>下面哪个方法属于白盒测试方法？</td><td>A.路径测试</td><td>B.等价类</td><td>C.因果图</td><td>D.归纳测试</td><td>A</td></tr><tr><td>2</td><td>等价类划分法设计8位宽度数字类型数据作用户登录账号，有多少种测试用例方案？</td><td>A.2</td><td>B.3</td><td>C.4</td><td>D.6</td><td>C</td></tr><tr><td>3</td><td>假定X为整数类型变量，X&gt;=1并且X&lt;=10，采用边界值法进行测试，其方案是</td><td>A.1，10</td><td>B.0，1，10，11</td><td>C.0，1，2，9，10，11</td><td>D.0，11</td><td>C</td></tr><tr><td>4</td><td>根据输出对输入的依赖关系设计测试用例的方法是</td><td>A.路径测试</td><td>B.等价类</td><td>C.因果图</td><td>D.归纳测试</td><td>C</td></tr><tr><td>5</td><td>在黑盒测试中，着重检查输入条件组合的方法是</td><td>A.等价类划分法</td><td>B.边界值分析法</td><td>C.错误推测法</td><td>D.判定表法</td><td>D</td></tr><tr><td>6</td><td>不属于白盒测试的技术是</td><td>A.判定表法</td><td>B.判定覆盖</td><td>C.条件覆盖</td><td>D.路径覆盖</td><td>A</td></tr><tr><td>7</td><td>下面那种方法能够有效地检测输入条件的各种组合可能引起的错误</td><td>A.错误推测</td><td>B.等价类划分</td><td>C.判定覆盖</td><td>D.因果图</td><td>D</td></tr><tr><td>8</td><td>以下哪种方法不是黑盒测试用例的设计方法</td><td>A.场景法</td><td>B.边界值法</td><td>C.因果图法</td><td>D.路径法</td><td>D</td></tr><tr><td>9</td><td>下列几种逻辑覆盖标准中，查错能力最强的是</td><td>A.语句覆盖</td><td>B.判定覆盖</td><td>C.条件覆盖</td><td>D.条件组合覆盖</td><td>D</td></tr><tr><td>10</td><td>发现错误能力最弱的是</td><td>A.语句覆盖</td><td>B.判定覆盖</td><td>C.条件覆盖</td><td>D.路径覆盖</td><td>A</td></tr><tr><td>10</td><td>查找程序是否有内存泄露，可采用的软件测试是</td><td>A.静态测试</td><td>B.动态测试</td><td>C.单元测试</td><td>D.集成测试</td><td>B</td></tr><tr><td></td><td>CM4</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>1</td><td>从软件工程角度，软件测试分为几个阶段。</td><td>A.3</td><td>B.4</td><td>C.5</td><td>D.6</td><td>D</td></tr><tr><td>2</td><td>在W模型中，程序设计与下面哪项测试可以同步？</td><td>A.需求评审</td><td>B.设计评审</td><td>C.功能测试用例设计</td><td>D.单元测试</td><td>C</td></tr><tr><td>3</td><td>当软件开发机构具有独立的测试部门，该机构测试成熟度至少达到下面哪个级别？</td><td>A.TMM2</td><td>B.TMM3</td><td>C.TMM4</td><td>D.TMM5</td><td>B</td></tr><tr><td>4</td><td>按照软件测试规范，执行单元测试是由哪类人员来进行？</td><td>A.测试分析人员</td><td>B.测试人员</td><td>C.设计人员</td><td>D.编程人员</td><td>D</td></tr><tr><td>5</td><td>下面哪项不属于测试项目管理的内容</td><td>A.测试设计</td><td>B.单元测试</td><td>C.测试执行</td><td>D.测试结果分析</td><td>B</td></tr><tr><td>6</td><td>按照软件测试规范，在以下哪个测试阶段制定测试策略？</td><td>A.测试计划</td><td>B.测试设计</td><td>C.测试实施</td><td>D.测试评估</td><td>A</td></tr><tr><td>7</td><td>按照软件测试规范，下面哪项评审需要项目经理参加？</td><td>A.测试计划评审</td><td>B.测试用例评审</td><td>C.测试过程评审</td><td>D.测试结果评估</td><td>A</td></tr><tr><td>8</td><td>在敏捷测试中，应主要采用探索式测试</td><td>对</td><td></td><td></td><td></td><td></td></tr><tr><td>9</td><td>在软件开发的  W模型中，测试过程与开发过程同步进行</td><td>对</td><td></td><td></td><td></td><td></td></tr><tr><td>10</td><td>测试结果的评估应由SQA人员来完成</td><td>错</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>CM5</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>1</td><td>下面哪个测试内容不属于单元测试（ ）</td><td>A.接口数据测试</td><td>B.局部数据测试</td><td>C.模块间时序测试</td><td>D.全局数据测试</td><td>C</td></tr><tr><td>2</td><td>以下关于集成测试的正确描述是（）</td><td>A.在把各个模块连接起来的时候，</td><td>B.一个模块的功能是否会对另一个模块</td><td>C.全局数据结构是否有问题</td><td>D.以上都是</td><td>D</td></tr><tr><td></td><td></td><td>穿越模块接口的数据是否会丢失</td><td>的功能产生不利的影响</td><td></td><td></td><td></td></tr><tr><td>3</td><td>在集成测试时，能较早发现高层模块接口错误的测试方法为。</td><td>A.自顶向下渐增式测试</td><td>B.自底向上渐增式测试</td><td>C.非渐增式测试</td><td>D.系统测试</td><td>A</td></tr><tr><td>4</td><td>Web应用系统负载测试中，以下哪个不是衡量业务执行效率的指标。</td><td>A.事务并发请求数</td><td>B.CPU执行占用率</td><td>C.事务吞吐量</td><td>D.事务响应时间</td><td>B</td></tr><tr><td>5</td><td>性能测试脚本执行，是在性能测试过程的第几阶段实施。</td><td>A.2</td><td>B.3</td><td>C.4</td><td>D.5</td><td>C</td></tr><tr><td>6</td><td>以下哪类系统可靠性最高。</td><td>A.单机系统</td><td>B.C/S系统</td><td>C.B/S系统</td><td>D.P2P系统</td><td>D</td></tr><tr><td>7</td><td>验证系统部件失效后的处理能力是属于以下哪种测试</td><td>A.系统性能测试</td><td>B.系统可靠性测试</td><td>C.系统容错测试</td><td>D.系统功能测试</td><td>C</td></tr><tr><td>8</td><td>下面哪种负载模式更接近实际系统运行情况</td><td>A.一次性加载</td><td>B.递增加载</td><td>C.高低变更加载</td><td>D.随机加载</td><td>D</td></tr><tr><td>9</td><td>下面哪种情况不是导致系统性能问题的原因</td><td>A.CPU使用率过高</td><td>B.内存泄露</td><td>C.系统响应时间长</td><td>D.连接资源稀少</td><td>C</td></tr><tr><td>10</td><td>以下哪个测试工具是使用最广泛的性能测试产品工具。</td><td>A.Load Runner</td><td>B.Selenium</td><td>C.JMeter</td><td>D.Quick Test  Professional</td><td>A</td></tr><tr><td></td><td>CM6</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>1</td><td>下面哪项不是软件度量的目标（）</td><td>A.用数据指标表明验收标准</td><td>B.分配资源时进行量化均衡</td><td>C.便于对软件质量进行评价</td><td>D.发现软件中的缺陷数量</td><td>D</td></tr><tr><td>2</td><td>下面哪项不是软件度量的用途?</td><td>A.衡量软件过程质量</td><td>B.项目度量</td><td>C.开发人员成效度量</td><td>D.产品质量度量</td><td>C</td></tr><tr><td>3</td><td>下面项类质量数据不能用于评估软件稳定性?</td><td>A.正确性</td><td>B.可靠性</td><td>C.可维护性</td><td>D.可用性</td><td>A</td></tr><tr><td>4</td><td>下面哪项活动是软件度量的阶段活动?</td><td>A.识别目标</td><td>B.定义度量过程</td><td>C.数据分析与反馈</td><td>D.以上都是</td><td>D</td></tr><tr><td>5</td><td>软件度量的维度是下面哪项？</td><td>A.项目度量</td><td>B.产品度量</td><td>C.过程度量</td><td>D.以上都是</td><td>D</td></tr><tr><td>6</td><td>下面哪项工作需要SQA人员来完成？</td><td>A.需求评审</td><td>B.过程评审</td><td>C.设计评审</td><td>D.系统测试</td><td>B</td></tr><tr><td>7</td><td>下面哪项工作需要SQA人员来完成？</td><td>A.制定SQA计划</td><td>B.审查软件过程</td><td>C.软件测试过程监督</td><td>D.以上都是</td><td>D</td></tr><tr><td>8</td><td>测试计划不包括下面哪项工作？</td><td>A.测试计划安排</td><td>B.测试风险识别</td><td>C.测试流程审计</td><td>D.测试资源安排</td><td>C</td></tr><tr><td>9</td><td>SQA在项目早期要根据项目计划制定与其对应的SQA计划</td><td>对</td><td></td><td></td><td></td><td></td></tr><tr><td>10</td><td>SQA是贯穿整个软件过程的第三方独立审查活动</td><td>对</td><td></td><td></td><td></td></tr></tbody></table></div></div>        <h1 id="作业大题"   >          <a href="#作业大题" class="heading-link"><i class="fas fa-link"></i></a>作业大题</h1>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628010850.png" alt="image-20210628010850526"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628010901.png" alt="image-20210628010901174"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628010909.png" alt=""></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628010918.png" alt="image-20210628010918247"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628010924.png" alt="image-20210628010924577"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628010933.png" alt="image-20210628010933038"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628010942.png" alt="image-20210628010941998"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628010953.png" alt="image-20210628010953483"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628011005.png" alt="image-20210628011005058"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628011030.png" alt="image-20210628011030646"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628011039.png" alt="image-20210628011039596"></p>        <h1 id="简答题预测"   >          <a href="#简答题预测" class="heading-link"><i class="fas fa-link"></i></a>简答题预测</h1>      <p><span class="exturl"><a class="exturl__link"   href="https://blog.csdn.net/xinyuebaihe/article/details/105936178" >https://blog.csdn.net/xinyuebaihe/article/details/105936178</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h2 id="2-软件的6大质量特性："   >          <a href="#2-软件的6大质量特性：" class="heading-link"><i class="fas fa-link"></i></a>2.软件的6大质量特性：</h2>      <p>ISO9126质量模型：软件质量模型的6大特性和27个子特性。</p><p>ISO9126软件质量模型是评价软件质量的国际标准，由6个特性和27个子特性组成，建议大家深入理解各特性、子特性的含义和区别，在测试工作需要从这6个特性和27个子特性去测试、评价一个软件。这个模型是软件质量标准的核心，对于大部分的软件，都可以考虑从这几个方面着手进行测评。</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210628074321.png" alt="image-20210628074321110"></p><p>2qw一、功能性<br>1、适合性：提供了相应的功能<br>2、准确性：正确（用户需要的）<br>3、互操作性：产品与产品之间交互数据的能力<br>4、保密安全性：允许经过授权的用户和系统能够正常的访问相应的数据和信息，禁止未授权的用户访问…….<br>5、功能性的依从性：国际/国家/行业/企业 标准规范一致性<br>二、可靠性：产品在规定的条件下，在规定的时间内完成规定功能的能力<br>1、成熟性：防止内部错误导致软件失效的能力<br>2、容错性：软件出现故障，自我处理能力<br>3、易恢复性：失效情况下的恢复能力<br>4、可靠性的依从性<br>三、易用性：在指定使用条件下，产品被理解、 学习、使用和吸引用户的能力<br>1、易理解性<br>2、易学性<br>3、易操作性<br>4、吸引性<br>5、易用性的依从性<br>四、效率性：在规定台条件下，相对于所用资源的数量，软件产品可提供适当性能的能力<br>1、时间特性：平均事务响应时间，吞吐率，TPS（每秒事务数）<br>2、资源利用性：CPU 内存 磁盘 IO 网络带宽 队列 共享内存<br>3、效率依从性<br>五、软件维护性：”四规”， 在规定条件下，规定的时间内，使用规定的工具或方法修复规定功能的能力<br>1、易分析性：分析定位问题的难易程度<br>2、易改变性：软件产品使指定的修改可以被实现的能力<br>3、稳定性：防止意外修改导致程序失效<br>4、易 测试性：使已修改软件能被确认的能力<br>5、维护性的依从性<br>六、软件可移植性：从一种环境迁移到另一种环境的能力<br>1、适应性：适应不同平台<br>2、易安装性：被安装的能力<br>3、共存性<br>4、易替换性<br>5、可移植性的依从性</p>        <h2 id="3-Alpha测试与beta的区别"   >          <a href="#3-Alpha测试与beta的区别" class="heading-link"><i class="fas fa-link"></i></a>3.Alpha测试与beta的区别</h2>      <p>alpha测试版，有点相当于内部测试，一般开发人员在场   ，是由用户做测试，但开发人员在场，一般是请用户到开发现场去测试<br>beta测试版，完全交给用户，由用户做测试，返回测试报告，相当于发行前的一个版本   </p><p>Alpha测试 在系统开发接近完成时对应用系统的测试；测试后仍然会有少量的设计变更。这种测试一般由最终用户或其它人员完成，不能由程序或测试员完成。<br>Beta测试 当开发和测试根本完成时所做的测试，最终的错误和问题需要在最终发行前找到。这种测试一般由最终用户或其它人员完成，不能由程序员或测试员完成。</p><p>1、测试时间不同：</p><p>Beta测试是百软件产品完成了功能测试和系统测试之后，在产品发布之前所进行的软件测试活动，它是技术测试的最后一个阶段。</p><p>alpha测试简称“α测试”，可以从软件产品编码结束之时开始，或在模块(子系统)测试完成之后开始，也可以在确认测试过程中产品达到一定的稳定和可靠程度度之后再开始。</p><p>2、测试的目的不同：</p><p>α测试的目的是评价软件产品的FLURPS（即功能、局域化、知可用性、可靠性、性能和支持）。尤其注重产品的界面和特色。α测试即为非正式验收道测试。</p><p>Beta测试是一种验收测试，通过了验收测试，产品就会进入发布阶段。</p><p>3、测试人员及场所不同：</p><p>α测试是由一个用户在开发环境下进行的测试，也可以是公司内部的用户在模拟实际操作环境下进行的受控测试，α测试不能由程序版员或测试员完成。α测试发现的错误，可以在测试现场立刻反馈给开发人员，由开发人员及时分析和处理。</p><p>Beta测试由软件的最终用户们在一个或多个客户场所进行。开发者通常不在Beta测试的现场，因Beta测试是软件在开发者不能控制的环境中的“真实”应用。</p>        <h2 id="4-软件缺陷等级划分"   >          <a href="#4-软件缺陷等级划分" class="heading-link"><i class="fas fa-link"></i></a>4.软件缺陷等级划分</h2>      <p>A类—严重错误，包括以下各种错误： 1.由于程序所引起的死机,非法退出 2.死循环 3.数据库发生死锁 4.因错误操作导致的程序中断 5.功能错误 6.与数据库连接错误 7.数据通讯错误</p><p>B类—较严重错误，包括以下各种错误： 1.程序错误 2.程序接口错误 3.数据库的表、业务规则、缺省值未加完整性等约束条件</p><p>C类—一般性错误，包括以下各种错误： 1.操作界面错误(包括数据窗口内列名定义、含义是否一致) 2.打印内容、格式错误 3.简单的输入限制未放在前台进行控制 4.删除操作未给出提示 5.数据库表中有过多的空字段</p><p>D类—较小错误，包括以下各种错误： 1.界面不规范 2.辅助说明描述不清楚 3.输入输出不规范 4.长操作未给用户提示 5.提示窗口文字未采用行业术语 6.可输入区域和只读区域没有明显的区分标志</p><p>E类—测试建议</p>        <h2 id="6-测试分为那几个阶段？并对每个阶段详细说明"   >          <a href="#6-测试分为那几个阶段？并对每个阶段详细说明" class="heading-link"><i class="fas fa-link"></i></a>6.测试分为那几个阶段？并对每个阶段详细说明</h2>      <p>按照开发阶段划分，软件测试可分为单元测试、集成测试、系统测试和验收测试</p><p>集成测试：针对每个单元的测试，以确保每个模块能正常工作为目标</p><p>集成测试：对已经测试过的模块进行组装，进行集成测试。目的就是在于检验与软件设计相关的程序结构问题。</p><p>系统测试：检验软件产品能够与系统的其他部分（比如：硬件、数据库及操作人员）协调工作。</p><p>验收测试：检验软件产品质量的最后一道工序，主要突出用户的作用，同时软件开发人员也有一定程度的参与。</p>        <h2 id="7-什么是软件测试？软件测试的目的与原则"   >          <a href="#7-什么是软件测试？软件测试的目的与原则" class="heading-link"><i class="fas fa-link"></i></a>7.什么是软件测试？软件测试的目的与原则</h2>      <p>在规定的条件下对程序进行操作，以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程。</p><p>软件测试的目的：</p><p>测试是程序的执行过程，目的在于发现错误<br>一个成功的测试用例在于发现至今未发现的错误<br>一个成功的测试是发现了至今未发现的错误的测试<br>确保产品完成了它所承诺或公布的功能，并且用户可以访问到的功能都有明确的书面说明。<br>确保产品满足性能和效率的要求<br>确保产品是健壮的和适应用户环境的</p><pre><code>    1）软件测试是为了发现错误而执行程序的过程。    2）测试是为了证明程序有错，而不是证明程序无错。（发现错误不是唯一目的）    3）一个好的测试用例在于它发现至今未发现的错误。    4）一个成功的测试是发现了至今未发现的错误的测试。</code></pre><p>注意：</p><pre><code>    1、测试并不仅仅是为了要找出错误。通过分析错误产生的原因和错误的分布特征。可以帮助项目管理者发现当前所采用的软件过程的缺陷，以便改进。同时，通过分析也能帮助我们设计出有针对性的检测方法，改善测试的有效性。    2、没有发现错误的测试也是有价值的，完整的测试是评定测试质量的一种方法。详细而严谨的可靠性增长模型可以证明这一点。例如Bev Littlewood发现一个经过测试而正常运行了n个小时的系统有继续正常运行n个小时的概率。</code></pre><p>软件测试的原则：</p><p>测试用例中一个必须部分是对预期输出或接过进行定义<br>程序员应避免测试自己编写的程序<br>编写软件的组织不应当测试自己编写的软件<br>应当彻底检查每个测试的执行结果<br>测试用例的编写不仅应当根据有效和预料到的输入情况，而且也应当根据无效和未预料到的输入情况<br>检擦程序是否“未做其应该做的”仅是测试的一半，测试的另一半是检查程序是否“做了其不应该做的”<br>应避免测试用例用后即弃，除非软件本身就是个一次性的软件<br>计划测试工作时不应默许假定不会发现错误<br>程序某部分存在更多错误的可能性，与该部分已经发现错误的数量成正比<br>软件测试是一项极富创造性，极具智力的挑战性的工作</p><pre><code>   1）应当把“尽早地不断地进行软件测试“作为软件开发者的座右铭。   2）测试用例应由测试数据和与之对应的预期输出结果这两部分组成。   3）程序员应避免检查自己的程序。   4）在设计测试用例时，应当包括合理的输入条件和不合理的输入条件。   5）充分注意测试中的群集现象。   6）严格执行测试计划，排除测试的随意性。   7）应当对每一个测试结果做全面的检查。   8）妥善保存测试计划、测试用例、出错统计和最终分析报告，为维护提供方便。</code></pre><p>一、Testing shows presence of defects<br>       测试显示软件存在缺陷<br>       测试只能证明软件中存在缺陷，但并不能证明软件中不存在缺陷。软件测试是为了降低存在缺陷的可能性，即便是没有找到缺陷，也不能证明软件是完美的。<br>二、Exhaustive testing is impossible<br>       穷尽测试是不可能的<br>       现在软件的规模越来越大，复杂度越来越高，想做到完全性的测试是不可能的。在测试阶段，测试人员可以根据风险和优先级来进行集中和高强度的测试，从而保证软件的质量。<br>三、Testing early<br>       测试尽早介入<br>       为什么测试要尽早介入呢，简单的说就是保证软件质量，降低风险和成本。测试人员一般在需求阶段就开始介入，使缺陷在需求或设计阶段就被发现，缺陷发现越早，修复的成本就越小。<br>四、Defect clustering<br>       缺陷集群性（2/8原则）<br>       缺陷集群性表明小部分模块包含大部分的缺陷。软件测试中存在Pareto原则：80%的缺陷发现在20%的模块中。<br>       一个功能模块发现的缺陷越高，那存在的未被发现的缺陷也越高，故发现的缺陷与未发现的缺陷成正比。<br>五、Pesticide Paradox<br>      杀虫剂悖论<br>      反复使用相同的杀虫剂会导致害虫对杀虫剂产生免疫而无法杀死害虫。软件测试也一样。如果一直使用相同的测试方法或手段，可能无法发现新的bug。<br>      为了解决这个问题，测试用例应当定期修订和评审，增加新的或不同的测试用例帮助发现更多的缺陷。<br>      测试人员不能一直依赖于现有的测试技术，而要不断的提升测试方法以提高测试效率。<br>六、Testing is context dependent<br>      测试活动依赖于测试内容<br>      根据业务的不同，软件测试内部也分为不同的行业，比如游戏行业、电商行业、金融行业。不同的行业，测试活动的开展都有所不同，比如测试技术、测试工具的选择，测试流程都不尽相同，所以软件测试的活动开展依赖于所测试的内容。<br>七、Absence of error - fallacy<br>       没有错误是好是谬论<br>      有可能99%没有bug的软件也是不能使用的。如果对错误的需求进行了彻底的测试，这种情况就发生了。软件测试不仅是找出缺陷，同时也需要确认软件是否满足需求。如果开发出来的产品不满足用户的需求，即便找到和修复了缺陷也作用不大。</p>        <h2 id="8-系统测试的策略有哪些-列出任意10种即可"   >          <a href="#8-系统测试的策略有哪些-列出任意10种即可" class="heading-link"><i class="fas fa-link"></i></a>8.系统测试的策略有哪些?列出任意10种即可</h2>      <p>功能测试，性能测试，可靠性测试，负载测试，易用性测试，强度测试，安全测试，配置测试，安装测试，卸载测试，文挡测试，故障恢复测试，界面测试，容量测试，兼容性测试，分布测试，可用性测试</p>        <h2 id="10-为什么说单元测试能发现约80-的软件缺陷"   >          <a href="#10-为什么说单元测试能发现约80-的软件缺陷" class="heading-link"><i class="fas fa-link"></i></a>10.为什么说单元测试能发现约80%的软件缺陷</h2>      <p>这是软件工程长期的历史数据统计和测试zd经验总结得来的，没听说过有典故或理由。当然要发现这80%的缺陷也版是要依靠设计出良好的测试用例，另外顺便提下，软件测试行业有个二八原则，就是软件80%的缺陷权存在与20%的代码中</p><p>因为缺陷放大理论，在单元测试阶段发现的bug会在系统测试阶段被放大，放大倍数完全符合80/20理论</p>        <h2 id="13-怎样进行文档测试"   >          <a href="#13-怎样进行文档测试" class="heading-link"><i class="fas fa-link"></i></a>13.怎样进行文档测试</h2>      <p>　　非代码的文档测试主要检查文档的正确性、完备性和可理解性。软件驱动的文档还得像程序一样运行测试。</p><p>　　正确性是指不要把软件的功能和操作写错，也不允许文档内容前后矛盾。</p><p>　　完备性是指文档不可以“虎头蛇尾”，更不许漏掉关键内容。文档中很多内容对开发者可能是“显然”的，但对用户而言不见得都是“显然”的。</p><p>　　文档要让大众用户看得懂，能理解。术语、缩写用户是否理解？内容和主题是否一致？</p><p>　　很多程序员能编写出好程序，却写不出清晰的文档。与文档作者密切合作，对文档仔细阅读，跟随每个步骤，检查每个图形，尝试每个示例是进行文档测试的基本方法。</p>]]></content>
    
    
    <summary type="html">描述</summary>
    
    
    
    <category term="分类" scheme="http://zjeff-953.gitee.io/zjeff/categories/%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="标签" scheme="http://zjeff-953.gitee.io/zjeff/tags/%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>软件安全 - 03 [前端实践] 位运算和权限设计</title>
    <link href="http://zjeff-953.gitee.io/zjeff/2022/06/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%20-%2003%20[%E5%89%8D%E7%AB%AF%E5%AE%9E%E8%B7%B5]%20%E4%BD%8D%E8%BF%90%E7%AE%97%E5%92%8C%E6%9D%83%E9%99%90%E8%AE%BE%E8%AE%A1/"/>
    <id>http://zjeff-953.gitee.io/zjeff/2022/06/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%20-%2003%20[%E5%89%8D%E7%AB%AF%E5%AE%9E%E8%B7%B5]%20%E4%BD%8D%E8%BF%90%E7%AE%97%E5%92%8C%E6%9D%83%E9%99%90%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-06-02T07:24:10.073Z</published>
    <updated>2021-05-06T11:34:20.000Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="软件安全-03-前端实践-位运算和权限设计"   >          <a href="#软件安全-03-前端实践-位运算和权限设计" class="heading-link"><i class="fas fa-link"></i></a>软件安全 - 03 [前端实践] 位运算和权限设计</h1>      <span id="more"></span><p><span class="exturl"><a class="exturl__link"   href="https://segmentfault.com/a/1190000020930961" >https://segmentfault.com/a/1190000020930961</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
    
    
    <summary type="html">软件安全 - 03 [前端实践] 位运算和权限设计</summary>
    
    
    
    <category term="网络安全" scheme="http://zjeff-953.gitee.io/zjeff/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="标签" scheme="http://zjeff-953.gitee.io/zjeff/tags/%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>软件安全 - 02 [Web安全策略] 实现WEB攻击</title>
    <link href="http://zjeff-953.gitee.io/zjeff/2022/06/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%20-%2002%20[Web%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5]%20%E5%AE%9E%E7%8E%B0WEB%E6%94%BB%E5%87%BB/"/>
    <id>http://zjeff-953.gitee.io/zjeff/2022/06/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%20-%2002%20[Web%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5]%20%E5%AE%9E%E7%8E%B0WEB%E6%94%BB%E5%87%BB/</id>
    <published>2022-06-02T07:24:10.070Z</published>
    <updated>2021-06-01T07:00:20.000Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="软件安全-02-Web安全策略-实现WEB攻击"   >          <a href="#软件安全-02-Web安全策略-实现WEB攻击" class="heading-link"><i class="fas fa-link"></i></a>软件安全 - 02 [Web安全策略] 实现WEB攻击</h1>      <span id="more"></span><p><span class="exturl"><a class="exturl__link"   href="https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" >https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h2 id="尝试XSS攻击"   >          <a href="#尝试XSS攻击" class="heading-link"><i class="fas fa-link"></i></a>尝试XSS攻击</h2>              <h2 id="尝试CSRF攻击"   >          <a href="#尝试CSRF攻击" class="heading-link"><i class="fas fa-link"></i></a>尝试CSRF攻击</h2>              <h3 id="GET和Img标签"   >          <a href="#GET和Img标签" class="heading-link"><i class="fas fa-link"></i></a>GET和Img标签</h3>      <p>银行网站A，它以GET请求来完成银行转账的操作，如：<span class="exturl"><a class="exturl__link"   href="http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000" >http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>　　危险网站B，它里面有一段HTML的代码如下：</p><p>　　<code>&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt;</code></p><p>　　首先，你登录了银行网站A，然后访问危险网站B，噢，这时你会发现你的银行账户少了1000块……</p><p>　　为什么会这样呢？原因是银行网站A违反了HTTP规范，使用GET请求更新资源。在访问危险网站B的之前，你已经登录了银行网站A，而B中的\<img\>以GET的方式请求第三方资源（这里的第三方就是指银行网站了，原本这是一个合法的请求，但这里被不法分子利用了），所以你的浏览器会带上你的银行网站A的Cookie发出Get请求，去获取资源“<span class="exturl"><a class="exturl__link"   href="http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000”，结果银行网站服务器收到请求后，认为这是一个更新资源操作（转账操作），所以就立刻进行转账操作" >http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000”，结果银行网站服务器收到请求后，认为这是一个更新资源操作（转账操作），所以就立刻进行转账操作</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>……</p>        <h3 id="POST但是没有完全POST"   >          <a href="#POST但是没有完全POST" class="heading-link"><i class="fas fa-link"></i></a>POST但是没有完全POST</h3>      <p>为了杜绝上面的问题，银行决定改用POST请求完成转账操作。</p><p>　　银行网站A的WEB表单如下：　　<br><figure class="highlight html"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;Transfer.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span>　　　　<span class="tag">&lt;<span class="name">p</span>&gt;</span>ToBankId: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;toBankId&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span>　　　　<span class="tag">&lt;<span class="name">p</span>&gt;</span>Money: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;money&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span>　　　　<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Transfer&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span>　　<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></div></figure><br>　　后台处理页面Transfer.php如下：</p><figure class="highlight php"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="meta">&lt;?php</span></span><br><span class="line">　　　　session_start();</span><br><span class="line">　　　　<span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;toBankId&#x27;</span>] &amp;&amp;　<span class="keyword">isset</span>(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;money&#x27;</span>]))</span><br><span class="line">　　　　&#123;</span><br><span class="line">　　　　    buy_stocks(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;toBankId&#x27;</span>],　<span class="variable">$_REQUEST</span>[<span class="string">&#x27;money&#x27;</span>]);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　<span class="meta">?&gt;</span></span><br></pre></td></tr></table></div></figure><p>和示例1中的操作一样，你首先登录了银行网站A，然后访问危险网站B，结果…..和示例1一样，你再次没了1000块～T_T，这次事故的原因是：银行后台使用了$_REQUEST去获取请求的数据，而$_REQUEST既可以获取GET请求的数据，也可以获取POST请求的数据，这就造成了在后台处理程序无法区分这到底是GET请求的数据还是POST请求的数据。在PHP中，可以使用$_GET和$_POST分别获取GET请求和POST请求的数据。在JAVA中，用于获取请求数据request一样存在不能区分GET请求数据和POST数据的问题。</p>        <h3 id="POST和虚假表单"   >          <a href="#POST和虚假表单" class="heading-link"><i class="fas fa-link"></i></a>POST和虚假表单</h3>      <p>　经过前面2个惨痛的教训，银行决定把获取请求数据的方法也改了，改用$_POST，只获取POST请求的数据，后台处理页面Transfer.php代码如下：</p><figure class="highlight php"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">　　　　session_start();</span><br><span class="line">　　　　<span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;toBankId&#x27;</span>] &amp;&amp;　<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;money&#x27;</span>]))</span><br><span class="line">　　　　&#123;</span><br><span class="line">　　　　    buy_stocks(<span class="variable">$_POST</span>[<span class="string">&#x27;toBankId&#x27;</span>],　<span class="variable">$_POST</span>[<span class="string">&#x27;money&#x27;</span>]);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　<span class="meta">?&gt;</span></span><br></pre></td></tr></table></div></figure><p>　　然而，危险网站B与时俱进，它改了一下代码：</p><figure class="highlight html"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">　　　　　　<span class="function"><span class="keyword">function</span> <span class="title">steal</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="function"><span class="javascript">　　　　　　</span>&#123;</span></span><br><span class="line"><span class="javascript">          　　　　 iframe = <span class="built_in">document</span>.frames[<span class="string">&quot;steal&quot;</span>];</span></span><br><span class="line"><span class="javascript">　　     　　      iframe.document.Submit(<span class="string">&quot;transfer&quot;</span>);</span></span><br><span class="line"><span class="javascript">　　　　　　&#125;</span></span><br><span class="line"><span class="javascript">　　　　</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">　　<span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;steal()&quot;</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">&quot;steal&quot;</span> <span class="attr">display</span>=<span class="string">&quot;none&quot;</span>&gt;</span></span><br><span class="line">　　　　　　<span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">name</span>=<span class="string">&quot;transfer&quot;</span>　<span class="attr">action</span>=<span class="string">&quot;http://www.myBank.com/Transfer.php&quot;</span>&gt;</span></span><br><span class="line">　　　　　　　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;toBankId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;11&quot;</span>&gt;</span></span><br><span class="line">　　　　　　　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;money&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1000&quot;</span>&gt;</span></span><br><span class="line">　　　　　　<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></div></figure><p>如果用户仍是继续上面的操作，很不幸，结果将会是再次不见1000块……因为这里危险网站B暗地里发送了POST请求到银行!</p><p>　　总结一下上面3个例子，CSRF主要的攻击模式基本上是以上的3种，其中以第1,2种最为严重，因为触发条件很简单，一个\<img\>就可以了，而第3种比较麻烦，需要使用JavaScript，所以使用的机会会比前面的少很多，但无论是哪种情况，只要触发了CSRF攻击，后果都有可能很严重。</p><p>　　理解上面的3种攻击模式，其实可以看出，CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！</p>        <h3 id="防御策略"   >          <a href="#防御策略" class="heading-link"><i class="fas fa-link"></i></a>防御策略</h3>      <p>　　服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。</p><p>　(1).Cookie Hashing(所有表单都包含同一个伪随机值)：</p><p>就是用户访问的时候先给一个hash数字, 让用户每次请求的时候作为一个自定义头带上</p><p>　　这个方法个人觉得已经可以杜绝99%的CSRF攻击了，那还有1%呢….由于用户的Cookie很容易由于网站的XSS漏洞而被盗取，这就另外的1%。一般的攻击者看到有需要算Hash值，基本都会放弃了，某些除外，所以如果需要100%的杜绝，这个不是最好的方法。</p><p>　(2).验证码</p><p>　　这个方案的思路是：每次的用户提交都需要用户在表单中填写一个图片上的随机字符串，厄….这个方案可以完全解决CSRF，但个人觉得在易用性方面似乎不是太好，还有听闻是验证码图片的使用涉及了一个被称为MHTML的Bug，可能在某些版本的微软IE中受影响。</p><p>　　(3).One-Time Tokens(不同的表单包含一个不同的伪随机值)</p><p>　　在实现One-Time Tokens时，需要注意一点：就是“并行会话的兼容”。如果用户在一个站点上同时打开了两个不同的表单，CSRF保护措施不应该影响到他对任何表单的提交。考虑一下如果每次表单被装入时站点生成一个伪随机值来覆盖以前的伪随机值将会发生什么情况：用户只能成功地提交他最后打开的表单，因为所有其他的表单都含有非法的伪随机值。必须小心操作以确保CSRF保护措施不会影响选项卡式的浏览或者利用多个浏览器窗口浏览一个站点。</p>        <h2 id="尝试SQL注入"   >          <a href="#尝试SQL注入" class="heading-link"><i class="fas fa-link"></i></a>尝试SQL注入</h2>              <h1 id="前端安全知识点"   >          <a href="#前端安全知识点" class="heading-link"><i class="fas fa-link"></i></a>前端安全知识点</h1>      <p>这一章我们将来学习安全防范这一块的知识点。总的来说安全是很复杂的一个领域，不可能通过一个章节就能学习到这部分的内容。在这一章节中，我们会学习到常见的一些安全问题及如何防范的内容，在当下其实安全问题越来越重要，已经逐渐成为前端开发必备的技能了。</p>        <h2 id="XSS"   >          <a href="#XSS" class="heading-link"><i class="fas fa-link"></i></a>XSS</h2>      <blockquote><p>涉及面试题：什么是 XSS 攻击？如何防范 XSS 攻击？什么是 CSP？</p></blockquote><p>XSS 简单点来说，就是攻击者想尽一切办法将可以执行的代码注入到网页中。</p><p>XSS 可以分为多种类型，但是总体上我认为分为两类：<strong>持久型和非持久型</strong>。</p><p>持久型也就是攻击的代码被服务端写入进<strong>数据库</strong>中，这种攻击危害性很大，因为如果网站访问量很大的话，就会导致大量正常访问页面的用户都受到攻击。</p><p>举个例子，对于评论功能来说，就得防范持久型 XSS 攻击，因为我可以在评论中输入以下内容</p><p><img   src="https://user-gold-cdn.xitu.io/2018/12/2/1676a843648d488c?w=1348&amp;h=318&amp;f=png&amp;s=41697" style=""  alt=""></p><p>这种情况如果前后端没有做好防御的话，这段评论就会被存储到数据库中，这样每个打开该页面的用户都会被攻击到。</p><p>非持久型相比于前者危害就小的多了，一般通过<strong>修改 URL 参数</strong>的方式加入攻击代码，诱导用户访问链接从而进行攻击。</p><p>举个例子，如果页面需要从 URL 中获取某些参数作为内容的话，不经过过滤就会导致攻击代码被执行</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- http://www.domain.com?name=&lt;script&gt;alert(1)&lt;/script&gt; --&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;                                                  </span><br></pre></td></tr></table></div></figure><p>但是对于这种攻击方式来说，如果用户使用 Chrome 这类浏览器的话，浏览器就能自动帮助用户防御攻击。但是我们不能因此就不防御此类攻击了，因为我不能确保用户都使用了该类浏览器。</p><p><img   src="https://user-gold-cdn.xitu.io/2018/12/2/1676d5e1a09c8367?w=647&amp;h=292&amp;f=png&amp;s=32958" style=""  alt=""></p><p>对于 XSS 攻击来说，通常有两种方式可以用来防御。</p>        <h3 id="转义字符"   >          <a href="#转义字符" class="heading-link"><i class="fas fa-link"></i></a>转义字符</h3>      <p>首先，对于用户的输入应该是永远不信任的。最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义</p><figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  str = str.replace(<span class="regexp">/&amp;/g</span>, <span class="string">&#x27;&amp;amp;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&lt;/g</span>, <span class="string">&#x27;&amp;lt;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&gt;/g</span>, <span class="string">&#x27;&amp;gt;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&quot;/g</span>, <span class="string">&#x27;&amp;quto;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&#x27;/g</span>, <span class="string">&#x27;&amp;#39;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/`/g</span>, <span class="string">&#x27;&amp;#96;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/\//g</span>, <span class="string">&#x27;&amp;#x2F;&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></div></figure><p>通过转义可以将攻击代码 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code> 变成<br><figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; &amp;lt;script&amp;gt;alert(1)&amp;lt;&amp;#x2F;script&amp;gt;</span></span><br><span class="line"><span class="built_in">escape</span>(<span class="string">&#x27;&lt;script&gt;alert(1)&lt;/script&gt;&#x27;</span>)</span><br><span class="line"> </span><br></pre></td></tr></table></div></figure><br>但是对于显示富文本来说，显然不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。对于这种情况，通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。<br><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const xss = require(&#x27;xss&#x27;)</span><br><span class="line">let html = xss(&#x27;&lt;h1 id=&quot;title&quot;&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;&#x27;)</span><br><span class="line">// -&gt; &lt;h1&gt;XSS Demo&lt;/h1&gt;&amp;lt;script&amp;gt;alert(&quot;xss&quot;);&amp;lt;/script&amp;gt;</span><br><span class="line">console.log(html)</span><br><span class="line"> </span><br></pre></td></tr></table></div></figure><br>以上示例使用了 <code>js-xss</code> 来实现，可以看到在输出中保留了 <code>h1</code> 标签且过滤了 <code>script</code> 标签。</p>        <h3 id="CSP"   >          <a href="#CSP" class="heading-link"><i class="fas fa-link"></i></a>CSP</h3>      <p>CSP 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击。<br>通常可以通过两种方式来开启 CSP：</p><ol><li>设置 HTTP Header 中的 <code>Content-Security-Policy</code></li><li>设置 <code>meta</code> 标签的方式 <code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</code><br>这里以设置 HTTP Header 来举例</li></ol><ul><li><p>只允许加载本站资源</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: default-src ‘self’</span><br><span class="line"></span><br></pre></td></tr></table></div></figure></li><li><p>只允许加载 HTTPS 协议图片</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: img-src https://*</span><br><span class="line"></span><br></pre></td></tr></table></div></figure></li><li><p>允许加载任何来源框架</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: child-src &#x27;none&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure></li></ul><p>当然可以设置的属性远不止这些，你可以通过查阅 <span class="exturl"><a class="exturl__link"   href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy" >文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 的方式来学习，这里就不过多赘述其他的属性了。<br>对于这种方式来说，只要开发者配置了正确的规则，那么即使网站存在漏洞，攻击者也不能执行它的攻击代码，并且 CSP 的兼容性也不错。<br><img   src="https://user-gold-cdn.xitu.io/2018/12/2/1676d8215a3d1f5b?w=1266&amp;h=478&amp;f=png&amp;s=85547" style=""  alt=""></p>        <h2 id="CSRF"   >          <a href="#CSRF" class="heading-link"><i class="fas fa-link"></i></a>CSRF</h2>      <blockquote><p>涉及面试题：什么是 CSRF 攻击？如何防范 CSRF 攻击？<br>CSRF 中文名为跨站请求伪造。原理就是攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑。<br>举个例子，假设网站中有一个通过 <code>GET</code> 请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口<br><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;http://www.domain.com/xxx?comment=&#x27;attack&#x27;&quot;/&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></div></figure><br>那么你是否会想到使用 <code>POST</code> 方式提交请求是不是就没有这个问题了呢？其实并不是，使用这种方式也不是百分百安全的，攻击者同样可以诱导用户进入某个页面，在页面中通过表单提交 <code>POST</code> 请求。</p>        <h3 id="如何防御"   >          <a href="#如何防御" class="heading-link"><i class="fas fa-link"></i></a>如何防御</h3>      <p>防范 CSRF 攻击可以遵循以下几种规则：</p><ol><li>Get 请求不对数据进行修改</li><li>不让第三方网站访问到用户 Cookie</li><li>阻止第三方网站请求接口</li><li>请求时附带验证信息，比如验证码或者 Token        <h4 id="SameSite"   >          <a href="#SameSite" class="heading-link"><i class="fas fa-link"></i></a>SameSite</h4>      可以对 Cookie 设置 <code>SameSite</code> 属性。该属性表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。        <h4 id="验证-Referer"   >          <a href="#验证-Referer" class="heading-link"><i class="fas fa-link"></i></a>验证 Referer</h4>      对于需要防范 CSRF 的请求，我们可以通过验证 Referer 来判断该请求是否为第三方网站发起的。        <h4 id="Token"   >          <a href="#Token" class="heading-link"><i class="fas fa-link"></i></a>Token</h4>      服务器下发一个随机 Token，每次发起请求时将 Token 携带上，服务器验证 Token 是否有效。        <h2 id="点击劫持"   >          <a href="#点击劫持" class="heading-link"><i class="fas fa-link"></i></a>点击劫持</h2>      涉及面试题：什么是点击劫持？如何防范点击劫持？<br>点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 <code>iframe</code> 嵌套的方式嵌入自己的网页中，并将 <code>iframe</code> 设置为透明，在页面中透出一个按钮诱导用户点击。<br><img   src="https://user-gold-cdn.xitu.io/2018/12/1/16768734d57c5f47?w=812&amp;h=424&amp;f=png&amp;s=43633" style=""  alt=""><br>对于这种攻击方式，推荐防御的方法有两种。        <h3 id="X-FRAME-OPTIONS"   >          <a href="#X-FRAME-OPTIONS" class="heading-link"><i class="fas fa-link"></i></a>X-FRAME-OPTIONS</h3>      <code>X-FRAME-OPTIONS</code> 是一个 HTTP 响应头，在现代浏览器有一个很好的支持。这个 HTTP 响应头 就是为了防御用 <code>iframe</code> 嵌套的点击劫持攻击。<br>该响应头有三个值可选，分别是</li></ol><ul><li><code>DENY</code>，表示页面不允许通过 <code>iframe</code> 的方式展示</li><li><code>SAMEORIGIN</code>，表示页面可以在相同域名下通过 <code>iframe</code> 的方式展示</li><li><code>ALLOW-FROM</code>，表示页面可以在指定来源的 <code>iframe</code> 中展示        <h3 id="JS-防御"   >          <a href="#JS-防御" class="heading-link"><i class="fas fa-link"></i></a>JS 防御</h3>      对于某些远古浏览器来说，并不能支持上面的这种方式，那我们只有通过 JS 的方式来防御点击劫持了。<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;style id=&quot;click-jack&quot;&gt;</span><br><span class="line">    html &#123;</span><br><span class="line">      display: none !important;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    if (self == top) &#123;</span><br><span class="line">      var style = document.getElementById(&#x27;click-jack&#x27;)</span><br><span class="line">      document.body.removeChild(style)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      top.location = self.location</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></div></figure>以上代码的作用就是当通过 <code>iframe</code> 的方式加载页面时，攻击者的网页直接不显示所有内容了。        <h2 id="中间人攻击"   >          <a href="#中间人攻击" class="heading-link"><i class="fas fa-link"></i></a>中间人攻击</h2>      涉及面试题：什么是中间人攻击？如何防范中间人攻击？<br>中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息。<br>通常来说不建议使用公共的 Wi-Fi，因为很可能就会发生中间人攻击的情况。如果你在通信的过程中涉及到了某些敏感信息，就完全暴露给攻击方了。<br>当然防御中间人攻击其实并不难，只需要增加一个安全通道来传输信息。HTTPS 就可以用来防御中间人攻击，但是并不是说使用了 HTTPS 就可以高枕无忧了，因为如果你没有完全关闭 HTTP 访问的话，攻击方可以通过某些方式将 HTTPS 降级为 HTTP 从而实现中间人攻击。        <h2 id="小结"   >          <a href="#小结" class="heading-link"><i class="fas fa-link"></i></a>小结</h2>      在这一章中，我们学习到了一些常见的前端安全方面的知识及如何防御这些攻击。但是安全的领域相当大，这些内容只是沧海一粟，如果大家对于安全有兴趣的话，可以阅读 <span class="exturl"><a class="exturl__link"   href="https://github.com/trimstray/the-book-of-secret-knowledge" >这个仓库的内容</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 来学习和实践这方面的知识。</li></ul></blockquote>]]></content>
    
    
    <summary type="html">软件安全 - 02 [Web安全策略] 实现WEB攻击</summary>
    
    
    
    <category term="网络安全" scheme="http://zjeff-953.gitee.io/zjeff/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="标签" scheme="http://zjeff-953.gitee.io/zjeff/tags/%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>软件安全 - 03 [前端实践] 位运算和权限设计</title>
    <link href="http://zjeff-953.gitee.io/zjeff/2022/06/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%20-%2001%20[%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1]%20%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%99%BB%E5%BD%95%E7%B3%BB%E7%BB%9F/"/>
    <id>http://zjeff-953.gitee.io/zjeff/2022/06/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%20-%2001%20[%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1]%20%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%99%BB%E5%BD%95%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-06-02T07:24:10.067Z</published>
    <updated>2021-06-08T13:03:20.000Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="软件安全-03-前端实践-位运算和权限设计"   >          <a href="#软件安全-03-前端实践-位运算和权限设计" class="heading-link"><i class="fas fa-link"></i></a>软件安全 - 03 [前端实践] 位运算和权限设计</h1>      <span id="more"></span><p><span class="exturl"><a class="exturl__link"   href="https://www.cnblogs.com/xiekeli/p/5607107.html" >https://www.cnblogs.com/xiekeli/p/5607107.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p><span class="exturl"><a class="exturl__link"   href="https://www.bilibili.com/read/cv5992629" >在前端哈希密码是否是个不错的方案？</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p><span class="exturl"><a class="exturl__link"   href="https://blog.csdn.net/shadow_zed/article/details/82425793" >https://blog.csdn.net/shadow_zed/article/details/82425793</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
    
    
    <summary type="html">软件安全 - 03 [前端实践] 位运算和权限设计</summary>
    
    
    
    <category term="网络安全" scheme="http://zjeff-953.gitee.io/zjeff/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="标签" scheme="http://zjeff-953.gitee.io/zjeff/tags/%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>编码Unicode和UTF-8</title>
    <link href="http://zjeff-953.gitee.io/zjeff/2022/06/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%BC%96%E7%A0%81Unicode%E5%92%8CUTF-8/"/>
    <id>http://zjeff-953.gitee.io/zjeff/2022/06/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%BC%96%E7%A0%81Unicode%E5%92%8CUTF-8/</id>
    <published>2022-06-02T07:24:10.064Z</published>
    <updated>2022-05-27T02:37:26.151Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="编码Unicode和UTF-8"   >          <a href="#编码Unicode和UTF-8" class="heading-link"><i class="fas fa-link"></i></a>编码Unicode和UTF-8</h1>      <span id="more"></span><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210506203219.png" alt="image-20210506203219544"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210506203301.png" alt="image-20210506203300981"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210506203314.png" alt="image-20210506203314098"></p><p>作者：uuspider<br>链接：<span class="exturl"><a class="exturl__link"   href="https://www.zhihu.com/question/23374078/answer/65352538" >https://www.zhihu.com/question/23374078/answer/65352538</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>举一个例子：It’s 知乎日报</p><p>你看到的unicode字符集是这样的编码表：</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">I 0049</span><br><span class="line">t 0074</span><br><span class="line">&#x27; 0027</span><br><span class="line">s 0073</span><br><span class="line">  0020</span><br><span class="line">知 77e5</span><br><span class="line">乎 4e4e</span><br><span class="line">日 65e5</span><br><span class="line">报 62a5</span><br></pre></td></tr></table></div></figure><p>每一个字符对应一个十六进制数字。</p><p>计算机只懂二进制，因此，严格按照unicode的方式(UCS-2)，应该这样存储：</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">I 00000000 01001001</span><br><span class="line">t 00000000 01110100</span><br><span class="line">&#x27; 00000000 00100111</span><br><span class="line">s 00000000 01110011</span><br><span class="line">  00000000 00100000</span><br><span class="line">知 01110111 11100101</span><br><span class="line">乎 01001110 01001110</span><br><span class="line">日 01100101 11100101</span><br><span class="line">报 01100010 10100101</span><br></pre></td></tr></table></div></figure><p>这个字符串总共占用了18个字节，但是对比中英文的二进制码，可以发现，英文前9位都是0！浪费啊，浪费硬盘，浪费流量。</p><p>怎么办？</p><p>UTF。</p><p>UTF-8是这样做的：</p><p>\1. 单字节的字符，字节的第一位设为0，对于英语文本，UTF-8码只占用一个字节，和ASCII码完全相同；</p><p>\2. n个字节的字符(n&gt;1)，第一个字节的前n位设为1，第n+1位设为0，后面字节的前两位都设为10，这n个字节的其余空位填充该字符unicode码，高位用0补足。</p><p>这样就形成了如下的UTF-8标记位：</p><p>0xxxxxxx<br>110xxxxx 10xxxxxx<br>1110xxxx 10xxxxxx 10xxxxxx<br>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx<br>111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx<br>1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx<br>… …</p><p>于是，”It’s 知乎日报“就变成了：</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">I 01001001</span><br><span class="line">t 01110100</span><br><span class="line">&#x27; 00100111</span><br><span class="line">s 01110011</span><br><span class="line">  00100000</span><br><span class="line">知 11100111 10011111 10100101</span><br><span class="line">乎 11100100 10111001 10001110</span><br><span class="line">日 11100110 10010111 10100101</span><br><span class="line">报 11100110 10001010 10100101</span><br></pre></td></tr></table></div></figure><p>和上边的方案对比一下，英文短了，每个中文字符却多用了一个字节。但是整个字符串只用了17个字节，比上边的18个短了一点点。</p><p>下边是课后作业：</p><p>请将”It’s 知乎日报“的GB2312和GBK码(自行google)转成二进制。不考虑历史因素，从技术角度解释为什么在unicode和UTF-8大行其道的同时，GB2312和GBK仍在广泛使用。</p><p>剧透：一切都是为了节省你的硬盘和流量</p><p><span class="exturl"><a class="exturl__link"   href="https://blog.csdn.net/hongsong673150343/article/details/88584753" >https://blog.csdn.net/hongsong673150343/article/details/88584753</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
    
    
    <summary type="html">描述</summary>
    
    
    
    <category term="分类" scheme="http://zjeff-953.gitee.io/zjeff/categories/%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="标签" scheme="http://zjeff-953.gitee.io/zjeff/tags/%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>系统分析与设计 - 03 应用题</title>
    <link href="http://zjeff-953.gitee.io/zjeff/2022/06/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%20-%2003%20%E5%BA%94%E7%94%A8%E9%A2%98/"/>
    <id>http://zjeff-953.gitee.io/zjeff/2022/06/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%20-%2003%20%E5%BA%94%E7%94%A8%E9%A2%98/</id>
    <published>2022-06-02T07:24:10.062Z</published>
    <updated>2022-05-27T02:37:26.150Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="系统分析与设计-03-应用题"   >          <a href="#系统分析与设计-03-应用题" class="heading-link"><i class="fas fa-link"></i></a>系统分析与设计 - 03 应用题</h1>      <span id="more"></span>        <h2 id="第1章-系统分析与设计概述"   >          <a href="#第1章-系统分析与设计概述" class="heading-link"><i class="fas fa-link"></i></a>第1章 系统分析与设计概述</h2>              <h2 id="第2章-面向对象建模基础"   >          <a href="#第2章-面向对象建模基础" class="heading-link"><i class="fas fa-link"></i></a>第2章 面向对象建模基础</h2>              <h2 id="第3章-系统规划"   >          <a href="#第3章-系统规划" class="heading-link"><i class="fas fa-link"></i></a>第3章 系统规划</h2>              <h2 id="第4章-系统需求分析"   >          <a href="#第4章-系统需求分析" class="heading-link"><i class="fas fa-link"></i></a>第4章 系统需求分析</h2>              <h3 id="BPMN-需求建模方法"   >          <a href="#BPMN-需求建模方法" class="heading-link"><i class="fas fa-link"></i></a>BPMN 需求建模方法</h3>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112310943594.png" alt="image-20211231094335449"></p>        <h3 id="UML-系统功能需求建模方法"   >          <a href="#UML-系统功能需求建模方法" class="heading-link"><i class="fas fa-link"></i></a>UML 系统功能需求建模方法</h3>              <h4 id="用例图"   >          <a href="#用例图" class="heading-link"><i class="fas fa-link"></i></a>用例图</h4>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112310943239.png" alt="image-20211231094353132"></p>        <h4 id="活动图"   >          <a href="#活动图" class="heading-link"><i class="fas fa-link"></i></a>活动图</h4>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112310944544.png" alt="image-20211231094411425"></p>        <h4 id="泳道图"   >          <a href="#泳道图" class="heading-link"><i class="fas fa-link"></i></a>泳道图</h4>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112310944118.png" alt="image-20211231094454016"></p>        <h4 id="分析类图"   >          <a href="#分析类图" class="heading-link"><i class="fas fa-link"></i></a>分析类图</h4>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112310945970.png" alt="image-20211231094527855"></p>        <h2 id="第5章-系统架构设计"   >          <a href="#第5章-系统架构设计" class="heading-link"><i class="fas fa-link"></i></a>第5章 系统架构设计</h2>              <h3 id="系统总体架构"   >          <a href="#系统总体架构" class="heading-link"><i class="fas fa-link"></i></a>系统总体架构</h3>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112310936402.png" alt="image-20211231093644285"></p>        <h3 id="系统拓扑架构"   >          <a href="#系统拓扑架构" class="heading-link"><i class="fas fa-link"></i></a>系统拓扑架构</h3>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112310937860.png" alt="image-20211231093707699"></p>        <h3 id="系统数据架构"   >          <a href="#系统数据架构" class="heading-link"><i class="fas fa-link"></i></a>系统数据架构</h3>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112310938735.png" alt="image-20211231093807493"></p>        <h4 id="系统数据分层架构"   >          <a href="#系统数据分层架构" class="heading-link"><i class="fas fa-link"></i></a>系统数据分层架构</h4>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112310938133.png" alt="image-20211231093840030"></p>        <h4 id="系统数据治理架构"   >          <a href="#系统数据治理架构" class="heading-link"><i class="fas fa-link"></i></a>系统数据治理架构</h4>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112310938833.png" alt="image-20211231093847622"></p>        <h4 id="系统数据存储架构"   >          <a href="#系统数据存储架构" class="heading-link"><i class="fas fa-link"></i></a>系统数据存储架构</h4>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112310939210.png" alt="image-20211231093915054"></p>        <h3 id="系统应用架构"   >          <a href="#系统应用架构" class="heading-link"><i class="fas fa-link"></i></a>系统应用架构</h3>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112310939781.png" alt="image-20211231093942590"></p>        <h3 id="软件体系架构（软件架构）"   >          <a href="#软件体系架构（软件架构）" class="heading-link"><i class="fas fa-link"></i></a>软件体系架构（软件架构）</h3>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112310940658.png" alt="image-20211231094025467"></p>        <h4 id="软件技术架构"   >          <a href="#软件技术架构" class="heading-link"><i class="fas fa-link"></i></a>软件技术架构</h4>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112310940953.png" alt="image-20211231094047852"></p>        <h2 id="第6章-软件建模设计"   >          <a href="#第6章-软件建模设计" class="heading-link"><i class="fas fa-link"></i></a>第6章 软件建模设计</h2>              <h3 id="软件建模设计"   >          <a href="#软件建模设计" class="heading-link"><i class="fas fa-link"></i></a>软件建模设计</h3>              <h4 id="静态结构建模"   >          <a href="#静态结构建模" class="heading-link"><i class="fas fa-link"></i></a>静态结构建模</h4>              <h5 id="类图"   >          <a href="#类图" class="heading-link"><i class="fas fa-link"></i></a>类图</h5>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112311049314.png" alt="image-20211231104901229"></p>        <h4 id="动态交互视图建模"   >          <a href="#动态交互视图建模" class="heading-link"><i class="fas fa-link"></i></a>动态交互视图建模</h4>              <h5 id="顺序图"   >          <a href="#顺序图" class="heading-link"><i class="fas fa-link"></i></a>顺序图</h5>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112311048688.png" alt="image-20211231104811571"></p>        <h5 id="通信图"   >          <a href="#通信图" class="heading-link"><i class="fas fa-link"></i></a>通信图</h5>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112311043982.png" alt="image-20211231104323849"></p>        <h4 id="状态机视图建模"   >          <a href="#状态机视图建模" class="heading-link"><i class="fas fa-link"></i></a>状态机视图建模</h4>              <h5 id="状态机图"   >          <a href="#状态机图" class="heading-link"><i class="fas fa-link"></i></a>状态机图</h5>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112311047866.png" alt="image-20211231104752744"></p>        <h4 id="实现视图建模"   >          <a href="#实现视图建模" class="heading-link"><i class="fas fa-link"></i></a>实现视图建模</h4>              <h5 id="构件图"   >          <a href="#构件图" class="heading-link"><i class="fas fa-link"></i></a>构件图</h5>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112311046851.png" alt="image-20211231104657722"></p>        <h5 id="部署图"   >          <a href="#部署图" class="heading-link"><i class="fas fa-link"></i></a>部署图</h5>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112311047368.png" alt="image-20211231104710260"></p>        <h5 id="子系统与包图"   >          <a href="#子系统与包图" class="heading-link"><i class="fas fa-link"></i></a>子系统与包图</h5>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112311047593.png" alt="image-20211231104726482"></p>        <h3 id="设计模式"   >          <a href="#设计模式" class="heading-link"><i class="fas fa-link"></i></a>设计模式</h3>              <h4 id="创建型模式"   >          <a href="#创建型模式" class="heading-link"><i class="fas fa-link"></i></a>创建型模式</h4>              <h5 id="单例模式"   >          <a href="#单例模式" class="heading-link"><i class="fas fa-link"></i></a>单例模式</h5>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance = <span class="keyword">null</span>;    <span class="comment">//保证 instance 在所有线程中同步</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;    <span class="comment">//private 避免类在外部被实例化</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//getInstance 方法前加同步</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h5 id="工厂模式"   >          <a href="#工厂模式" class="heading-link"><i class="fas fa-link"></i></a>工厂模式</h5>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抽象产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//具体产品：ProductA</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体产品1显示...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//具体产品：ProductB</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体产品2显示...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRODUCT_A = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRODUCT_B = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRODUCT_C = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">makeProduct</span><span class="params">(<span class="keyword">int</span> kind)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (kind) &#123;</span><br><span class="line">                <span class="keyword">case</span> Const.PRODUCT_A:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">                <span class="keyword">case</span> Const.PRODUCT_B:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="结构型模式"   >          <a href="#结构型模式" class="heading-link"><i class="fas fa-link"></i></a>结构型模式</h4>              <h5 id="适配器模式"   >          <a href="#适配器模式" class="heading-link"><i class="fas fa-link"></i></a>适配器模式</h5>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter;</span><br><span class="line"><span class="comment">//目标接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配者接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span></span>&#123;       </span><br><span class="line">        System.out.println(<span class="string">&quot;适配者中的业务代码被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类适配器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassAdapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassAdapterTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类适配器模式测试：&quot;</span>);</span><br><span class="line">        Target target = <span class="keyword">new</span> ClassAdapter();</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h5 id="桥接模式"   >          <a href="#桥接模式" class="heading-link"><i class="fas fa-link"></i></a>桥接模式</h5>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bridge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Implementor imple = <span class="keyword">new</span> ConcreteImplementorA();</span><br><span class="line">        Abstraction abs = <span class="keyword">new</span> RefinedAbstraction(imple);</span><br><span class="line">        abs.Operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现化角色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OperationImpl</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体实现化角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementorA</span> <span class="keyword">implements</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OperationImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体实现化(Concrete Implementor)角色被访问&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象化角色</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Implementor imple;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Abstraction</span><span class="params">(Implementor imple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.imple = imple;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展抽象化角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">RefinedAbstraction</span><span class="params">(Implementor imple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(imple);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;扩展抽象化(Refined Abstraction)角色被访问&quot;</span>);</span><br><span class="line">        imple.OperationImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="行为型模式"   >          <a href="#行为型模式" class="heading-link"><i class="fas fa-link"></i></a>行为型模式</h4>              <h5 id="责任链模式"   >          <a href="#责任链模式" class="heading-link"><i class="fas fa-link"></i></a>责任链模式</h5>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chainOfResponsibility;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainOfResponsibilityPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 组装责任链</span></span><br><span class="line">        Handler handler1 = <span class="keyword">new</span> ConcreteHandler1();</span><br><span class="line">        Handler handler2 = <span class="keyword">new</span> ConcreteHandler2();</span><br><span class="line">        handler1.setNext(handler2);</span><br><span class="line">        <span class="comment">// 提交请求</span></span><br><span class="line">        handler1.handleRequest(<span class="string">&quot;two&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象处理者角色</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Handler next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Handler next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Handler <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理请求的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(String request)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理者角色1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler1</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(String request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.equals(<span class="string">&quot;one&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体处理者1负责处理该请求！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (getNext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                getNext().handleRequest(request);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;没有人处理该请求！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理者角色2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler2</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(String request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.equals(<span class="string">&quot;two&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体处理者2负责处理该请求！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (getNext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                getNext().handleRequest(request);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;没有人处理该请求！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h5 id="中介者模式"   >          <a href="#中介者模式" class="heading-link"><i class="fas fa-link"></i></a>中介者模式</h5>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.c.mediator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediatorPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mediator md = <span class="keyword">new</span> ConcreteMediator();</span><br><span class="line">        Colleague c1, c2;</span><br><span class="line">        c1 = <span class="keyword">new</span> ConcreteColleague1();</span><br><span class="line">        c2 = <span class="keyword">new</span> ConcreteColleague2();</span><br><span class="line">        md.register(c1);</span><br><span class="line">        md.register(c2);</span><br><span class="line">        c1.send();</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">        c2.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象中介者</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Colleague colleague)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">relay</span><span class="params">(Colleague cl)</span></span>; <span class="comment">//转发</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体中介者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Colleague&gt; colleagues = <span class="keyword">new</span> ArrayList&lt;Colleague&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Colleague colleague)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!colleagues.contains(colleague)) &#123;</span><br><span class="line">            colleagues.add(colleague);</span><br><span class="line">            colleague.setMedium(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">relay</span><span class="params">(Colleague cl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Colleague ob : colleagues) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ob.equals(cl)) &#123;</span><br><span class="line">                ((Colleague) ob).receive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象同事类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMedium</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体同事类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleague1</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体同事类1收到请求。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体同事类1发出请求。&quot;</span>);</span><br><span class="line">        mediator.relay(<span class="keyword">this</span>); <span class="comment">//请中介者转发</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体同事类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleague2</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体同事类2收到请求。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体同事类2发出请求。&quot;</span>);</span><br><span class="line">        mediator.relay(<span class="keyword">this</span>); <span class="comment">//请中介者转发</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h2 id="第7章-用户界面设计"   >          <a href="#第7章-用户界面设计" class="heading-link"><i class="fas fa-link"></i></a>第7章 用户界面设计</h2>              <h2 id="UML-分类"   >          <a href="#UML-分类" class="heading-link"><i class="fas fa-link"></i></a>UML 分类</h2>      <ul><li>用例图</li><li>静态图(Static diagram)<ul><li>类图</li><li>对象图</li><li>包图</li></ul></li><li>行为图(Behavior diagram)<ul><li>状态图</li></ul></li><li>交互图(Interactive diagram)<ul><li>顺序图</li><li>协作图</li><li>通信图</li></ul></li><li>实现图( Implementation diagram )<ul><li>活动图</li><li>构件图</li><li>部署图</li></ul></li></ul><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    
    <summary type="html">系统分析与设计</summary>
    
    
    
    <category term="系统分析与设计" scheme="http://zjeff-953.gitee.io/zjeff/categories/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="系统分析与设计" scheme="http://zjeff-953.gitee.io/zjeff/tags/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>系统分析与设计 - 02 知识总结</title>
    <link href="http://zjeff-953.gitee.io/zjeff/2022/06/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%20-%2002%20%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://zjeff-953.gitee.io/zjeff/2022/06/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%20-%2002%20%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</id>
    <published>2022-06-02T07:24:10.059Z</published>
    <updated>2022-05-27T02:37:26.151Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="系统分析与设计-02-知识总结"   >          <a href="#系统分析与设计-02-知识总结" class="heading-link"><i class="fas fa-link"></i></a>系统分析与设计 - 02 知识总结</h1>      <span id="more"></span>        <h2 id="第一章-系统分析与设计概述"   >          <a href="#第一章-系统分析与设计概述" class="heading-link"><i class="fas fa-link"></i></a>第一章 系统分析与设计概述</h2>              <h3 id="大纲"   >          <a href="#大纲" class="heading-link"><i class="fas fa-link"></i></a>大纲</h3>      <p>了解信息系统组成、类型、利益相关者、系统开发人员</p><p>理解信息系统类型、软件特性、软件质量属性<br>理解信息系统生命周期、系统开发活动<br>理解信息系统开发过程模型、技术特点、适用场景<br>了解系统开发策略、开发方法、开发工具等</p>        <h3 id="概述"   >          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a>概述</h3>      <p>了解信息系统</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112290820698.png" alt="image-20211229082049565"></p><p>了解信息系统组成</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112290821778.png" alt="image-20211229082103686"></p><p>了解信息系统类型</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112290821949.png" alt="image-20211229082113822"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112290916923.png" alt="image-20211229091643780"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112290917624.png" alt="image-20211229091708498"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112290917712.png" alt="image-20211229091730576"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112290917053.png" alt="image-20211229091746901"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112290917413.png" alt="image-20211229091753282"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112290918989.png" alt="image-20211229091803903"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112290919679.png" alt="image-20211229091923605"></p><ol><li>业务处理系统</li><li>管理信息系统</li><li>决策支持系统</li><li>OA系统</li></ol><p>了解信息系统利益相关者</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112290934621.png" alt="image-20211229093444566" style="zoom:50%;" /></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112290935740.png" alt="image-20211229093509674" style="zoom: 50%;" /></p><p>了解信息系统开发人员</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112290935847.png" alt="image-20211229093523731" style="zoom: 50%;" /></p><p>理解信息系统类型</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112290942948.png" alt="image-20211229094206831"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112290945354.png" alt="image-20211229094522258"></p><p>理解信息系统软件特性</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112290947030.png" alt="image-20211229094705931"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112290947225.png" alt="image-20211229094719108"></p><p>理解信息系统软件质量属性</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112290947773.png" alt="image-20211229094729607"></p><p>理解信息系统生命周期</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112290948072.png" alt="image-20211229094847970"></p><p>理解信息系统开发活动</p><p><img src="C:\Users\15727\AppData\Roaming\Typora\typora-user-images\image-20211229094900836.png" alt="image-20211229094900836"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112290949750.png" alt="image-20211229094911636"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112290949138.png" alt="image-20211229094917063"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112290949983.png" alt="image-20211229094923835"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112290949101.png" alt="image-20211229094932022"></p><p>理解信息系统开发过程模型、技术特点、适用场景</p><ol><li>瀑布开发过程模型</li><li>选型开发过程模型</li><li>螺旋式开发过程模型</li><li>统一软件开发过程</li><li>敏捷软件开发过程模型</li></ol><p>了解系统开发策略</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112290952195.png" alt="image-20211229095257060"></p><p><img src="C:\Users\15727\AppData\Roaming\Typora\typora-user-images\image-20211229095303007.png" alt="image-20211229095303007"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112290953735.png" alt="image-20211229095315557"></p><p>了解系统开发方法</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112290953816.png" alt="image-20211229095332672"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112290953857.png" alt="image-20211229095337703"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112290953032.png" alt="image-20211229095342862"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112290953382.png" alt="image-20211229095349243"></p><p><img src="C:\Users\15727\AppData\Roaming\Typora\typora-user-images\image-20211229095358624.png" alt="image-20211229095358624"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112290954097.png" alt="image-20211229095404917"></p><p>了解系统开发工具</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112290954450.png" alt="image-20211229095417379" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112290954198.png" alt="image-20211229095433075"></p>        <h2 id="第二章-面向对象建模基础"   >          <a href="#第二章-面向对象建模基础" class="heading-link"><i class="fas fa-link"></i></a>第二章 面向对象建模基础</h2>              <h3 id="大纲-1"   >          <a href="#大纲-1" class="heading-link"><i class="fas fa-link"></i></a>大纲</h3>      <p>理解面向对象分析与设计的基本思想<br>理解UML建模语言基本要素及用途<br>理解业务流程建模与BPMN建模语言</p>        <h3 id="概述-1"   >          <a href="#概述-1" class="heading-link"><i class="fas fa-link"></i></a>概述</h3>      <p>理解面向对象分析的基本思想</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291017963.png" alt="image-20211229101705801"></p><p>理解面向对象设计的基本思想</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291023992.png" alt="image-20211229102306840"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291023365.png" alt="image-20211229102318255"></p><p>理解UML建模语言基本要素及用途</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291023774.png" alt="image-20211229102345592"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291024555.png" alt="image-20211229102408373"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291024029.png" alt="image-20211229102417927"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291034176.png" alt="image-20211229103437013"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291034283.png" alt="image-20211229103457136"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291035229.png" alt="image-20211229103513144"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291035339.png" alt="image-20211229103524204"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291035494.png" alt="image-20211229103531407"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291035977.png" alt="image-20211229103537837"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291035534.png" alt="image-20211229103544463"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291035417.png" alt="image-20211229103554240"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291036752.png" alt="image-20211229103600687"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291036977.png" alt="image-20211229103615829"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291036671.png" alt="image-20211229103627584"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291036269.png" alt="image-20211229103636103"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291036436.png" alt="image-20211229103642354"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291036390.png" alt="image-20211229103648229"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291036766.png" alt="image-20211229103653696"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291037715.png" alt="image-20211229103702561"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291037288.png" alt="image-20211229103710232"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291037610.png" alt="image-20211229103717434"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291037228.png" alt="image-20211229103728077"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291037759.png" alt="image-20211229103736623"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291037331.png" alt="image-20211229103742227"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291037290.png" alt="image-20211229103751173"></p><p>理解业务流程建模与BPMN建模语言</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291038136.png" alt="image-20211229103812007"></p>        <h2 id="第三章-系统规划"   >          <a href="#第三章-系统规划" class="heading-link"><i class="fas fa-link"></i></a>第三章 系统规划</h2>              <h3 id="大纲-2"   >          <a href="#大纲-2" class="heading-link"><i class="fas fa-link"></i></a>大纲</h3>      <p>理解系统规划的典型方法<br>掌握系统规划方案设计<br>掌握项目计划方法<br>掌握项目可行性分析方法</p>        <h3 id="概述-2"   >          <a href="#概述-2" class="heading-link"><i class="fas fa-link"></i></a>概述</h3>      <p>理解系统规划的典型方法</p><p>掌握系统规划方案设计</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291513886.png" alt="image-20211229151335775" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291514213.png" alt="image-20211229151408131" style="zoom: 67%;" /></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291514993.png" alt="image-20211229151417934" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291514549.png" alt="image-20211229151425456" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291514871.png" alt="image-20211229151431769" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291514759.png" alt="image-20211229151438674" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291514091.png" alt="image-20211229151446033" style="zoom:67%;" /></p><p><img src="C:\Users\15727\AppData\Roaming\Typora\typora-user-images\image-20211229151456672.png" alt="image-20211229151456672" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291515092.png" alt="image-20211229151502951" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291515155.png" alt="image-20211229151517059" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291515435.png" alt="image-20211229151527343" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291515174.png" alt="image-20211229151534069" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291515715.png" alt="image-20211229151541609" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291515581.png" alt="image-20211229151546521" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291515294.png" alt="image-20211229151555230" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291516024.png" alt="image-20211229151601967" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291516094.png" alt="image-20211229151608000" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291516314.png" alt="image-20211229151623208" style="zoom:67%;" /></p><p>掌握项目计划方法</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291644831.png" alt="image-20211229164431623" style="zoom: 50%;" /></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291644169.png" alt="image-20211229164442043" style="zoom: 50%;" /></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291644720.png" alt="image-20211229164451562" style="zoom: 50%;" /></p><p><img src="C:\Users\15727\AppData\Roaming\Typora\typora-user-images\image-20211229211707985.png" alt="image-20211229211707985" style="zoom:50%;" /></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112292117991.png" alt="image-20211229211735856" style="zoom:50%;" /></p><p>掌握项目可行性分析方法</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291852702.png" alt="image-20211229185229540" style="zoom:50%;" /></p>        <h2 id="第四章-系统需求分析"   >          <a href="#第四章-系统需求分析" class="heading-link"><i class="fas fa-link"></i></a>第四章 系统需求分析</h2>              <h3 id="大纲-3"   >          <a href="#大纲-3" class="heading-link"><i class="fas fa-link"></i></a>大纲</h3>      <p>掌握需求采集方法与需求确定方法<br>掌握BPMN业务需求建模方法<br>掌握UML系统功能需求建模方法<br>掌握需求规格说明、需求管理方法</p>        <h3 id="概述-3"   >          <a href="#概述-3" class="heading-link"><i class="fas fa-link"></i></a>概述</h3>      <p>掌握需求采集方法与需求确定方法</p><p>掌握BPMN业务需求建模方法</p><p>掌握UML系统功能需求建模方法</p><p>掌握需求规格说明、需求管理方法</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112301314280.png" alt="image-20211230131406164"></p>        <h2 id="第五章-系统架构设计"   >          <a href="#第五章-系统架构设计" class="heading-link"><i class="fas fa-link"></i></a>第五章 系统架构设计</h2>              <h3 id="大纲-4"   >          <a href="#大纲-4" class="heading-link"><i class="fas fa-link"></i></a>大纲</h3>      <p>了解系统设计过程、设计活动、设计方法;</p><p>理解系统的架构组成、架构方法、架构设计;<br>理解基于客户机/服务器的、基于构件的、面向服务的架构技术;<br>理解非功能需求如何影响架构设计;</p><p>掌握软件架构的UML建模设计方法。</p>        <h3 id="概述-4"   >          <a href="#概述-4" class="heading-link"><i class="fas fa-link"></i></a>概述</h3>      <p>了解系统设计过程、设计活动、设计方法;</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112301339036.png" alt="image-20211230133949909"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112301340327.png" alt="image-20211230134001236"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112301340053.png" alt="image-20211230134010865"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112301340715.png" alt="image-20211230134019538"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112301404713.png" alt="image-20211230140439631"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112301404529.png" alt="image-20211230140450428"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112301404483.png" alt="image-20211230140459395"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112301340803.png" alt="image-20211230134036662"></p><p>理解系统的架构组成、架构方法、架构设计;</p><p>理解基于客户机/服务器的、基于构件的、面向服务的架构技术;</p><p>理解非功能需求如何影响架构设计;</p><p>掌握软件架构的UML建模设计方法。</p>        <h2 id="第六章-软件建模设计与设计模式"   >          <a href="#第六章-软件建模设计与设计模式" class="heading-link"><i class="fas fa-link"></i></a>第六章 软件建模设计与设计模式</h2>              <h3 id="大纲-5"   >          <a href="#大纲-5" class="heading-link"><i class="fas fa-link"></i></a>大纲</h3>      <p>了解软件建模详细设计的目标、原则、内容;</p><p>掌握类图的高级建模设计方法;<br>掌握顺序图和通信图的高级建模设计方法;</p><p>掌握状态机图的高级建模设计方法;<br>掌握构件图、部署图、包图的高级建模设计方法;</p><p>掌握典型设计模式的设计与编程方法。</p><ul><li>设计模式概述</li><li>创建型模式</li><li>结构型模式</li><li>行为型模式</li></ul>        <h3 id="概述-5"   >          <a href="#概述-5" class="heading-link"><i class="fas fa-link"></i></a>概述</h3>      <p>了解软件建模详细设计的目标、原则、内容;</p><p>掌握类图的高级建模设计方法;<br>掌握顺序图和通信图的高级建模设计方法;</p><p>掌握状态机图的高级建模设计方法;<br>掌握构件图、部署图、包图的高级建模设计方法;</p><p>掌握典型设计模式的设计与编程方法。</p><ul><li>设计模式概述</li><li>创建型模式</li><li>结构型模式</li><li>行为型模式</li></ul>        <h2 id="第七章-用户界面设计"   >          <a href="#第七章-用户界面设计" class="heading-link"><i class="fas fa-link"></i></a>第七章 用户界面设计</h2>              <h3 id="大纲-6"   >          <a href="#大纲-6" class="heading-link"><i class="fas fa-link"></i></a>大纲</h3>      <p>了解信息系统用户界面的组成、设计原则、设计内容、设计过程<br>掌握Web系统用户界面的设计要素、建模设计方法、界面逻辑表达<br>掌握移动App用户界面的设计要素、建模设计方法、界面逻辑表达</p>        <h3 id="概述-6"   >          <a href="#概述-6" class="heading-link"><i class="fas fa-link"></i></a>概述</h3>      ]]></content>
    
    
    <summary type="html">系统分析与设计</summary>
    
    
    
    <category term="系统分析与设计" scheme="http://zjeff-953.gitee.io/zjeff/categories/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="系统分析与设计" scheme="http://zjeff-953.gitee.io/zjeff/tags/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>系统分析与设计 - 01 期末试题</title>
    <link href="http://zjeff-953.gitee.io/zjeff/2022/06/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%20-%2001%20%E6%9C%9F%E6%9C%AB%E8%AF%95%E9%A2%98/"/>
    <id>http://zjeff-953.gitee.io/zjeff/2022/06/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%20-%2001%20%E6%9C%9F%E6%9C%AB%E8%AF%95%E9%A2%98/</id>
    <published>2022-06-02T07:24:10.056Z</published>
    <updated>2022-05-27T02:37:26.151Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="系统分析与设计-01-期末试题"   >          <a href="#系统分析与设计-01-期末试题" class="heading-link"><i class="fas fa-link"></i></a>系统分析与设计 - 01 期末试题</h1>      <span id="more"></span><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112252125386.png" alt="image-20211225212544303"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112252126650.png" alt="image-20211225212601588"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112252126172.png" alt="image-20211225212614095"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112252127825.png" alt="image-20211225212738740"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112252127353.png" alt="image-20211225212746273"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112252127836.png" alt="image-20211225212755769"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112252128602.png" alt="image-20211225212805528"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112252128179.png" alt="image-20211225212816114"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112252128387.png" alt="image-20211225212827305"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112252128687.png" alt="image-20211225212838624"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112252128979.png" alt="image-20211225212848901"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112252128355.png" alt="image-20211225212859285"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112252129386.png" alt="image-20211225212910310"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112252129880.png" alt="image-20211225212919823"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112252129557.png" alt="image-20211225212928474"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112252129937.png" alt="image-20211225212938863"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112252129032.png" alt="image-20211225212945952"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112252129291.png" alt="image-20211225212953212"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112252130144.png" alt="image-20211225213000075"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112311149229.png" alt="image-20211231114920901"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112311149357.png" alt="image-20211231114933245"></p>]]></content>
    
    
    <summary type="html">系统分析与设计</summary>
    
    
    
    <category term="系统分析与设计" scheme="http://zjeff-953.gitee.io/zjeff/categories/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="系统分析与设计" scheme="http://zjeff-953.gitee.io/zjeff/tags/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>系统分析与设计 - 00 学堂在线题目</title>
    <link href="http://zjeff-953.gitee.io/zjeff/2022/06/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%20-%2000%20%E5%AD%A6%E5%A0%82%E5%9C%A8%E7%BA%BF%E9%A2%98%E7%9B%AE/"/>
    <id>http://zjeff-953.gitee.io/zjeff/2022/06/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%20-%2000%20%E5%AD%A6%E5%A0%82%E5%9C%A8%E7%BA%BF%E9%A2%98%E7%9B%AE/</id>
    <published>2022-06-02T07:24:10.053Z</published>
    <updated>2022-05-27T02:37:26.151Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="系统分析与设计-00-学堂在线题目"   >          <a href="#系统分析与设计-00-学堂在线题目" class="heading-link"><i class="fas fa-link"></i></a>系统分析与设计 - 00 学堂在线题目</h1>      <span id="more"></span>        <h2 id="第1章-系统分析与设计概述"   >          <a href="#第1章-系统分析与设计概述" class="heading-link"><i class="fas fa-link"></i></a>第1章 系统分析与设计概述</h2>      <div class="table-container"><div class="table-container"><table><thead><tr><th>题目</th><th>答案</th></tr></thead><tbody><tr><td>项目经理是系统构造人员之一。</td><td>X</td></tr><tr><td>信息系统是一类处理信息的系统软件。</td><td>X</td></tr><tr><td>系统规划是在项目立项之后进行。</td><td>X</td></tr><tr><td>敏捷软件开发过程模型是一种轻量级的过程模型<strong>。</strong></td><td>V</td></tr><tr><td>应用软件依赖于系统运行环境。</td><td>V</td></tr><tr><td>信息系统通常由信息化基础设施、应用软件、数据库管理系统、数据库、业务数据、_<em>_</em>等要素组成。</td><td>[ “用户” ]</td></tr><tr><td>软件被划分为系统软件、应用软件和_<em>_</em>。</td><td>[ “中间件”, “中间件软件” ]</td></tr><tr><td>在信息系统生命周期中的_<em>_</em>、系统需求分析、系统设计阶段进行系统分析与设计活动。</td><td>[ “系统规划” ]</td></tr><tr><td>在螺旋式开发过程模型中，系统软件编码是在_<em>_</em>阶段的开发活动</td><td>[ “实施工程” ]</td></tr><tr><td>复用粒度最大的系统开发方法是_<em>_</em>。</td><td>[ “面向服务的系统开发方法” ]</td></tr></tbody></table></div></div><p>1．比较系统分析员与系统架构设计师的角色职责有何异同？</p><p>2．软件本质特性有哪些？</p><p>3．哪些开发活动是跨信息系统生命周期？</p><p>4．敏捷软件开发过程模型如何实施？</p><p>5．现代软件系统开发有哪些主流技术方法？</p><p>1.系统分析师（systemanalyst）是在系统开发中进行业务需求分析、系统需求分析、可行性分析、业务建模和指导项目开发的人。系统架构师协同系统分析师的工作，建议系统分析师按什么标准，什么工具，什么模式，什么技术去思考系统。同时，系统架构师应该对系统分析师所提出的问题，碰到的难题及时地提出解决的方法。 2.软件是复杂的，软件是人类思维和智能的一种延伸和在异体上的再现，远比任何以往人类的创造物都要复杂的多，软件的复杂性是软件的固有属性、本质特性。软件是不可见的，软件是客观世界空间和计算机空间之间的一种逻辑实体，不具有物理的形体特征。软件是不断变化的，它需要随着应用、硬件、用户和社会等各种因素的变化而不断的被修改和扩展。软件必须遵从人为的惯例并适应已有的技术和系统，软件需要随接口的不同而改变，随时间的推移而变化，而这些变化是不同的人设计的结果，许多复杂性来自保持与其他接口的一致，对软件的任何再设计，都无法简化这些复杂特性。 3.软件测试、软件维护、软件配置、软件质量保证、软件审核等等。 4.敏捷开发迭代流程一般遵循以下五个步骤：需求分析（requirements analysis）产品设计（design）功能编码（coding）功能测试（testing）部署评估（deployment / evaluation）。 </p><p>5.软件开发的8大主流方法：结构化方法、Jackson方法、原型方法、面向对象方法、敏捷方法、并列争求法、水晶法、自适应软件开发（ASD)。</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112281541769.png" style="zoom:80%;" /></p>        <h2 id="第2章-面向对象建模基础"   >          <a href="#第2章-面向对象建模基础" class="heading-link"><i class="fas fa-link"></i></a>第2章 面向对象建模基础</h2>      <div class="table-container"><div class="table-container"><table><thead><tr><th>问题</th><th>答案</th></tr></thead><tbody><tr><td>面向对象的需求分析与编程语言无关。</td><td>V</td></tr><tr><td>活动图可以表示并发活动。</td><td>V</td></tr><tr><td>状态机图有自转换状态。</td><td>V</td></tr><tr><td>部署图的节点中可以嵌入构件。</td><td>V</td></tr><tr><td>BPMN可以基于WS-BPEL转换为软件流程组件。</td><td>V</td></tr><tr><td>面向对象思想应用在面向对象分析、_<em>_</em>、面向对象编程过程中。</td><td>[ “面向对象设计” ]</td></tr><tr><td>类图中类之间的关系有关联关系、依赖关系、聚合关系、_<em>_</em>。</td><td>[ “泛化关系” ]</td></tr><tr><td>通信图中的元素包括对象、_<em>_</em> 、链和自反链。</td><td>[ “消息” ]</td></tr><tr><td>BPMN流对象分为三类：活动、_<em>_</em>、网关。</td><td>[ “事件” ]</td></tr><tr><td>BPMN中数据分为数据对象、_<em>_</em>、数据输入和数据输出等。</td><td>[ “数据对象集” ]</td></tr></tbody></table></div></div><p>1．面向对象分析与面向对象设计如何建立联系？</p><p>2．BPMN和UML的应用场景有什么区别？</p><p>3．UML的面向对象思想体现在哪些方面？</p><p>4．包图与类图是否可以放在一起？</p><p>1.面向对象分析的输入是用户的功能需求，输出是简单的、理性化的分析模型，此阶段的工作更多侧重于如何理解软件的功能需求；面向对象设计的输入是面向对象分析的结果，是最终的、细化后的设计模型，此阶段的工作更多侧重于如何得到一个合适的、完整的解决方案。 2.UML应用于对软件系统进行规范化，可视化，模型化，文档化。BPMN应用于业务流程建模，方便人理解和有助于协同组织之间的业务。 3.UML提供了四种通用机制，它们被一直地应用到模型中，描述了达到面向对象建模目的的4种策略，并在UML的不同语境下被反复运用，是的UML更简单并易于使用。这四种机制分别是：规格说明（specifications）、修饰（adornments）、通用划分（common divisions）和扩展机制（extensibility mechanisms）。 4.可以。</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112291007067.png" alt="image-20211229100752017"></p>        <h2 id="第3章-系统规划"   >          <a href="#第3章-系统规划" class="heading-link"><i class="fas fa-link"></i></a>第3章 系统规划</h2>      <div class="table-container"><div class="table-container"><table><thead><tr><th>题目</th><th>答案</th></tr></thead><tbody><tr><td>系统规划需要在项目立项后进行。</td><td>X</td></tr><tr><td>信息系统建设目标必须支持组织机构目标达成。</td><td>V</td></tr><tr><td>系统规划内容包括功能需求分析。</td><td>X</td></tr><tr><td>BSP方法可以直接将组织机构目标转换为信息系统目标。</td><td>X</td></tr><tr><td>在完成项目成本预算后就可以进行任务分工。</td><td>X</td></tr><tr><td>系统规划涉及组织机构的信息系统目标、信息化现状分析、系统建设方案、_<em>_</em>等内容。</td><td>[ “信息系统建设计划” ]</td></tr><tr><td>系统规划步骤包括规划准备、初步调查、战略与现状分析、_<em>_</em>和确定总体架构等。</td><td>[ “确定信息系统建设目标和战略” ]</td></tr><tr><td>业务流程重组强调以_<em>_</em>、以关心客户的需求和满意度为目标，对现有业务流程进行不断地优化或重新设计。</td><td>[ “业务流程为改造对象中心” ]</td></tr><tr><td>企业价值链分析可以从内部价值链、纵向价值链和_<em>_</em>价值链角度进行分析。</td><td>[ “横向价值链” ]</td></tr><tr><td>在项目成本估算中，既可以用货币单位表示，也可以采用工时、人月、_<em>_</em>等单位表示费用估计值。</td><td>[ “人天” ]</td></tr></tbody></table></div></div><p>\1. 为什么需要在系统规划阶段进行可行性分析？</p><p>2．哪种方法适合于协作型企业的信息系统规划？</p><p>3．如何分析组织机构的价值链？</p><p>4．如何进行项目的WBS工作任务分解？</p><p>5．在项目计划中，如何实现任务进度安排？</p><p>6．在信息系统项目开发中，需要遵从工程伦理道德规范？</p><p>1.可行性研究的意义在于，虽然可行性研究不能指出项目最终的详细计划和方向，但可行性研究可以在项目定义阶段用较小的代价识别出错误构思的系统，从而规避未来更多的资源投入的损失（时间、资金、人力、机会），或者因遭遇到无法逾越的技术障碍或环境障碍导致的不可避免的失败。 2.企业系统规划法（BPS）是从企业目标入手，逐步将企业目标转化为管理信息系统的目标和结构，从而更好地支持企业目标的实现。 3.运用价值链分析法确定与成本管理有关的价值活动企业的价值活动可以分为五种主要活动和四种辅助活动。五种主要活动包括（1）投入性活动，如收货、储存和配置等相关活动；（2）生产作业，即将投入转化为最终产品的相关活动；（3）产出性活动，如产成品的运输、储存、客户联系、定单处理等；（4）销售活动，旨在让顾客了解和购买商品，如广告、促销、销售机构的费用等；（5）服务活动，包括培训、修理、维护保养、部件更新等，旨在提高产品的附加值。 4.工作分解结构（简称WBS）跟因数分解是一个原理，就是把一个项目，按一定的原则分解，项目分解成任务，任务再分解成一项项工作，再把一项项工作分配到每个人的日常活动中，直到分解不下去为止。即：项目→任务→工作→日常活动。工作分解结构以可交付成果为导向，对项目要素进行的分组，它归纳和定义了项目的整个工作范围，每下降一层代表对项目工作的更详细定义。WBS总是处于计划过程的中心，也是制定进度计划、资源需求、成本预算、风险管理计划和采购计划等的重要基础。 5.通过里程碑式管理是控制项目进度。可以利用里程碑来管理项目，让包括自己、客户、组员和领导都了解项目的整个进度，完成了多少，该以哪种节奏工作。里程碑一般是完成阶段的工作标志，标志着上一个阶段的结束和下一个阶段的开始。通过里程碑项目经理可以为下一步工作作出决策，准确评估。 6.需要。工程伦理是调整工程与技术、工程与社会之间关系的道德规范,对工程师的伦理行为和工程建设起着引导、规范、开拓等重要作用。 工程伦理准则包括五个方面:以人为本、关爱生命、安全可靠、关爱自然、公平正义。 工程师的社会职责事关人类的前途和命运,工程师要对工程活动的全面社会意义和长远社会影响建立自觉的认识,承担起全部的社会责任。</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112300010982.png" alt="image-20211230001040860"></p>        <h2 id="第4章-系统需求分析"   >          <a href="#第4章-系统需求分析" class="heading-link"><i class="fas fa-link"></i></a>第4章 系统需求分析</h2>      <div class="table-container"><div class="table-container"><table><thead><tr><th>题目</th><th>答案</th></tr></thead><tbody><tr><td>BPMN的编排流程中没有泳池。</td><td>V</td></tr><tr><td>UML用例之间的扩展关系箭头是从扩展用例指向被扩展用例。</td><td>V</td></tr><tr><td>活动图无法表达并发执行的活动。</td><td>X</td></tr><tr><td>类图中两个类之间的泛化关系是指两个类之间的一般与特殊关系。</td><td>V</td></tr><tr><td>需求变更管理需要有专门的变更过程控制。</td><td>V</td></tr><tr><td>观察法分为旁观式观察、解释式观察、_<em>_</em>。</td><td>[ “参与式观察” ]</td></tr><tr><td>调查表中的封闭式问题有3种形式：单选/多选问题、评价问题、_<em>_</em>。</td><td>[ “排序问题” ]</td></tr><tr><td>用例图包含的元素有用例、关系、_<em>_</em>。</td><td>[ “参与者”, “角色” ]</td></tr><tr><td>需求规格说明书中非常重要的三部分内容分别是功能性需求、_<em>_</em>、接口需求。</td><td>[ “非功能性需求” ]</td></tr><tr><td>一个类包含三方面要素：类名、属性、_<em>_</em>。</td><td>[ “操作”, “方法” ]</td></tr></tbody></table></div></div><p>1．哪些需求采集方法适用于初期需求不明确的场景？</p><p>2．调查表法在什么场景中比较有效？</p><p>3．快速应用开发与原型法有什么区别？</p><p>\4. BPMN与UML中活动图在表现业务流程方面有什么区别？</p><p>\5. 功能性需求与非功能性需求对项目难易程度的影响分别有多大？</p><p>备注：每个学生除参与讨论以上问题外，还需自拟本章讨论问题或参与他人问题讨论。</p><p>\1. 原型法、头脑风暴法 2. 相对来说比较清晰简单的时候 3. 快速应用程序开发(RAD)不仅仅是一个流程或平台(稍后我们将讨论RAD与敏捷)，它代表了软件设计、构建和交付方式的根本转变。除了加快产品上市、降低成本和提高质量之外，RAD在概念上还与其他IT趋势保持一致，这些趋势有利于敏捷性、迭代和重用。 4. BPMN可以很详细地描述组织机构的业务流程过程，UML中活动图适合简略描述业务流程。 5. 功能性需求，一般是我们显性易见的，就是一般实现了什么功能，提供了什么服务，非功能性需求，以下应用维基百科的定义（虽然有些晦涩和绕口，但是我认为是比较精到和准确的） 在系统工程及需求工程中，非功能性需求（Non-functional requirement）是指依一些条件判断系统运作情形或其特性，而不是针对系统特定行为的需求。和非功能性需求相对的是功能需求，后者会定义系统特定的行为或功能。非功能性需求也可以视为为了满足客户业务需求而需要符合，但又不在功能需求以外的特性。</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/202112301313065.png" alt="image-20211230131319917"></p>        <h2 id="第5章-系统架构设计"   >          <a href="#第5章-系统架构设计" class="heading-link"><i class="fas fa-link"></i></a>第5章 系统架构设计</h2>      <div class="table-container"><div class="table-container"><table><thead><tr><th>题目</th><th>答案</th></tr></thead><tbody><tr><td>类图模型在系统设计各阶段都需要涉及。</td><td>V</td></tr><tr><td>系统数据架构是一类数据库模型。</td><td>X</td></tr><tr><td>系统架构的本质就是软件架构。</td><td>X</td></tr><tr><td>客户机/服务器体系架构适合Web应用。</td><td>V</td></tr><tr><td>异步消息通信模式适合银行转账业务。</td><td>X</td></tr><tr><td>系统架构通常包括系统拓扑架构、系统数据架构、系统软件架构和_<em>_</em>等。</td><td>[ “系统应用架构”, “应用架构” ]</td></tr><tr><td>典型软件系统一般被划分为表示层、业务逻辑层、<em>__</em>和数据存储层。</td><td>[ “数据存取访问层” ]</td></tr><tr><td>客户/服务模式可以细分为<em>__</em>、多客户/多服务模式、多层客户/服务模式。</td><td>[ “多客户/单服务模式” ]</td></tr><tr><td>在面向服务的软件架构中，其通信模式主要有服务注册通信模式、<em>__</em>、服务句柄代理转发通信模式、服务发现通信模式。</td><td>[ “服务代理转发通信模式” ]</td></tr><tr><td>软件对象之间的消息通信模式主要有同步消息通信模式和<em>__</em>。</td><td>[ “异步消息通信模式” ]</td></tr></tbody></table></div></div><p>1．系统设计过程涉及哪些主要开发活动？</p><p>2．系统架构设计如何满足系统非功能需求？</p><p>3．系统数据架构设计一般给出哪些内容？</p><p>4．微服务与微服务体系架构有何异同？</p><p>5．软件架构模式在系统开发中应如何选择？</p><p>1.系统设计是根据系统分析的结果，运用系统科学的思想和方法，设计出能最大限度满足所要求的目标 (或目的) 的新系统的过程。 系统设计内容，包括确定系统功能、设计方针和方法，产生理想系统并作出草案，通过收集信息对草案作出修正产生可选设计方案，将系统分解为若干子系统，进行子系统和总系统的详细设计并进行评价，对系统方案进行论证并作出性能效果预测。 2.考虑安全性、可靠性、互操作性、健壮性等非功能需求，然后依据相应的系统开放方法进行具体的详细设计。 3.数据架构是一套规范和文档的集合，包括：企业数据模型；信息的价值链分析：使数据与业务流程及其他企业架构的组件相一致；相关数据交付架构：包括数据库架构、数据整合架构、数据仓库/商务智能架构、文档和内容架构，以及元数据架构。 4.微服务是SOA的一种，是一种设计方法，其中包含多个服务，服务之间通过相互依赖最终提供一系列的功能。一个服务通常以独立的形式存在与操作系统进程中。各个服务之间通过网络调用。而微服务架构:其实和SOA架构类似,微服务是在SOA上做的升华，微服务架构强调的一个重点是“业务需要彻底的组件化和服务化”，原有的单个业务系统会拆分为多个可以独立开发、设计、运行的小应用。这些小应用之间通过服务完成交互和集成。 5.系统设计师应当明确分离关注点。每层负责一个明确的任务，由于关注点的分离，易于测试：每个层都是可测试的，可维护的并且易于更新。在这样明确之后，再选择合适的软件架构模式。</p>        <h2 id="第6章-软件建模设计"   >          <a href="#第6章-软件建模设计" class="heading-link"><i class="fas fa-link"></i></a>第6章 软件建模设计</h2>      <div class="table-container"><div class="table-container"><table><thead><tr><th>题目</th><th>答案</th></tr></thead><tbody><tr><td>处于相同状态的同类的不同对象对同一事件的反应往往是一样的，而处于不同状态的同一对象则对同一事件会做出不同反应。</td><td>V</td></tr><tr><td>只要将包中元素的可见性设为公共的，则其他包就可以访问它。</td><td>X</td></tr><tr><td>聚合与泛化都是面向对象系统支持功能复用的强大技术。</td><td>V</td></tr><tr><td>在UML构件图中，需要定义消息来描述构件之间的联系。</td><td>X</td></tr><tr><td>所有对象都通过类来描述，所有类都具有对象。</td><td>X</td></tr><tr><td><em>状态机图__</em>通过对对象的各种状态建立模型来描述对象随时间变化的动态行为，并且它是以独立的对象为中心进行描述的。</td><td>[ “状态机图” ]</td></tr><tr><td>在UML类图中，类用矩形图符来表示，这个矩形由3个部分组成，分别是类型名、<em>属性__</em>和操作。</td><td>[ “属性” ]</td></tr><tr><td>UML中的交互图包括顺序图和<em>通信图, 协作图__</em>。</td><td>[ “通信图”, “协作图” ]</td></tr><tr><td>UML中顺序图表示为二维图，纵向是对象，横向代表参与交互对象之间的<em>消息__</em>。</td><td>[ “消息” ]</td></tr><tr><td>状态机图由对象的状态和连接这些状态的<em>转换__</em>组成。</td><td>[ “转换” ]</td></tr></tbody></table></div></div><p>1．系统的静态模型、交互模型和状态机模型各有哪些特点？</p><p>2．类之间的关系有哪些？举例描述这些关系。</p><p>3．顺序图和通信图有哪些区别和联系？</p><p>\4. 泛化有什么作用？如何实现类继承？</p><p>\5. 接口和抽象类有什么区别和联系？</p><p>\1. 静态结构视图用来表示软件系统的类程序组成结构，同时也反映各个类中封装的数据与操作方法。静态结构视图支撑面向对象程序编程。2. 聚合关系，包括专属聚合，从属聚合，拥有聚合，成员聚合；泛化与继承关系；关联关系。3. 二者均属于动态交互模型图，顺序图强调时间先后关系，对象间消息的传递以时间顺序可视化表示，通信图消息则按空间布局。4. 泛化是指多个类的公共特征抽象到一个更一般化的类中。5. 抽象类：在Java中被abstract关键字修饰的类称为抽象类，被abstract关键字修饰的方法称为抽象方法，抽象方法只有方法的声明，没有方法体。抽象类的特点：抽象类不能被实例化只能被继承；包含抽象方法的一定是抽象类，但是抽象类不一定含有抽象方法；抽象类中的抽象方法的修饰符只能为public或者protected，默认为public；一个子类继承一个抽象类，则子类必须实现父类抽象方法，否则子类也必须定义为抽象类；抽象类可以包含属性、方法、构造方法，但是构造方法不能用于实例化，主要用途是被子类调用。接口：Java中接口使用interface关键字修饰，特点为:接口可以包含变量、方法；变量被隐士指定为public static final，方法被隐士指定为public abstract（JDK1.8之前）；接口支持多继承，即一个接口可以extends多个接口，间接的解决了Java中类的单继承问题；一个类可以实现多个接口。</p>        <h2 id="第7章-用户界面设计"   >          <a href="#第7章-用户界面设计" class="heading-link"><i class="fas fa-link"></i></a>第7章 用户界面设计</h2>      <div class="table-container"><div class="table-container"><table><thead><tr><th>题目</th><th>答案</th></tr></thead><tbody><tr><td>信息系统的功能是通过用户与系统界面交互来完成。</td><td>V</td></tr><tr><td>人的视觉规律是以中心为重点向四周发散。</td><td>X</td></tr><tr><td>在详细界面设计前需要进行系统原型设计。</td><td>V</td></tr><tr><td>输入数据格式校验是通过执行检查程序来实现的。</td><td>V</td></tr><tr><td>页面的数据列表可以打印输出。</td><td>X</td></tr><tr><td>为减少用户记忆负担，在界面上可以给出场景导引、默认值、<em>下拉列表值, 快捷方式, 逐次推进的提示方式__</em>等提示。</td><td>[ “下拉列表值”, “快捷方式”, “逐次推进的提示方式” ]</td></tr><tr><td>用户界面设计一般包括界面结构设计、界面交互设计、界面导航设计、界面视觉设计和<em>界面布局设计, 界面输入/输出设计__</em>。</td><td>[ “界面布局设计”, “界面输入/输出设计” ]</td></tr><tr><td>Web页面导航主要有水平栏目导航、垂直栏目导航、混合栏目导航和<em>页面内容导航__</em>。</td><td>[ “页面内容导航” ]</td></tr><tr><td>在移动App页面布局设计中，需要对页面信息内容、页面主题内容、用户行为心理和<em>用户功能操作__</em>进行整体考虑。</td><td>[ “用户功能操作” ]</td></tr><tr><td>在手机App页面布局设计中，页面可以分为背景层、内容层、悬浮层和<em>弹出层__</em>。</td><td>[ “弹出层” ]</td></tr></tbody></table></div></div><p>1．用户界面设计需要遵循哪些基本原则？</p><p>2．用户界面输入需要考虑解决哪些问题？</p><p>3．Web页面结构设计与移动App界面结构设计有哪些异同？</p><p>4．Web页面输出有哪些形式？</p><p>5．用户界面交互设计主要包括哪些方面的内容？</p><p>1.用户原则。人机界面设计首先要确立用户类型。划分类型可以从不同的角度，视实际情况而定。确定类型后要针对其特点预测他们对不同界面的反应。这就要从多方面设计分析。信息最小量原则。人机界面设计要尽量减少用户记忆负担，采用有助于记忆的设计方案。帮助和提示原则。要对用户的操作命令作出反应，帮助用户处理问题。系统要设计有恢复出错现场的能力，在系统内部处理工作要有提示，尽量把主动权让给用户。媒体最佳组合原则。多媒体界面的成功并不在于仅向用户提供丰富的媒体，而应在相关理论指导下，注意处理好各种媒体间的关系,恰当选用。 2.制定输入规则，防止无效输入；一切的输入都是威胁，需要制定相应的安全规则。 3.web系统基于B/S架构实现信息系统,通常包含大量功能页面,移动App开发基于有限软硬件资源,需要面对多终端多使用场景的问题。 4.数据报表，数据图。 5.交互设计，它主要指的是两个或多个个体之间交流和互动方式的设计，以达成某种设计产品的目的。交互设计的目标一般从“可用性”和”用户体验“两个层面出发，以帮助解决用户需求。首先是明确商业目标和用户目标。商业目标是很多初级的设计师容易忽略甚至抗拒的，在设计中，不仅仅要考虑用户体验和用户目标，还要考虑业务和商业目标。然后是在不同层次上思考和规划。产品的功能层、信息层、行为层等。</p>]]></content>
    
    
    <summary type="html">系统分析与设计</summary>
    
    
    
    <category term="系统分析与设计" scheme="http://zjeff-953.gitee.io/zjeff/categories/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="系统分析与设计" scheme="http://zjeff-953.gitee.io/zjeff/tags/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>程序员的进阶之路</title>
    <link href="http://zjeff-953.gitee.io/zjeff/2022/06/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"/>
    <id>http://zjeff-953.gitee.io/zjeff/2022/06/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/</id>
    <published>2022-06-02T07:24:10.049Z</published>
    <updated>2021-04-30T00:53:32.000Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="程序员的进阶之路"   >          <a href="#程序员的进阶之路" class="heading-link"><i class="fas fa-link"></i></a>程序员的进阶之路</h1>              <h2 id="Function-功能"   >          <a href="#Function-功能" class="heading-link"><i class="fas fa-link"></i></a>Function 功能</h2>              <h2 id="Design-patten-设计模式和编程思想"   >          <a href="#Design-patten-设计模式和编程思想" class="heading-link"><i class="fas fa-link"></i></a>Design patten 设计模式和编程思想</h2>              <h2 id="Performance-性能指标"   >          <a href="#Performance-性能指标" class="heading-link"><i class="fas fa-link"></i></a>Performance 性能指标</h2>              <h2 id="Architecture-系统架构"   >          <a href="#Architecture-系统架构" class="heading-link"><i class="fas fa-link"></i></a>Architecture 系统架构</h2>              <h2 id="Software-enginering-and-market-软件工程和核心业务"   >          <a href="#Software-enginering-and-market-软件工程和核心业务" class="heading-link"><i class="fas fa-link"></i></a>Software enginering and market 软件工程和核心业务</h2>      ]]></content>
    
    
    <summary type="html">描述</summary>
    
    
    
    <category term="程序员的进阶之路" scheme="http://zjeff-953.gitee.io/zjeff/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="程序员的进阶之路" scheme="http://zjeff-953.gitee.io/zjeff/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 - 14 计网习题</title>
    <link href="http://zjeff-953.gitee.io/zjeff/2022/06/02/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%2014%20%E8%AE%A1%E7%BD%91%E4%B9%A0%E9%A2%98/"/>
    <id>http://zjeff-953.gitee.io/zjeff/2022/06/02/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%2014%20%E8%AE%A1%E7%BD%91%E4%B9%A0%E9%A2%98/</id>
    <published>2022-06-02T07:24:10.037Z</published>
    <updated>2022-05-27T02:37:26.151Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="计算机网络-14-计网习题"   >          <a href="#计算机网络-14-计网习题" class="heading-link"><i class="fas fa-link"></i></a>计算机网络 - 14 计网习题</h1>      <span id="more"></span>        <h2 id="题1"   >          <a href="#题1" class="heading-link"><i class="fas fa-link"></i></a>题1</h2>      <p>一、单选题 (每小题2分，共30分)</p><p>下列不是Cerf and Kahn的开发网络体系结构系统设计原则的是:</p><p>A、自治原则</p><p>B、尽力服务</p><p>C、无状态路由 </p><p><strong>D、集中式控制</strong></p><p>协议中规定报文交互事件顺序的要素是: ( )</p><p>A、语法</p><p>B、语义</p><p><strong>C、同步</strong></p><p>D、以上都不是</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210629224831.png" alt="image-20210629224830744" style="zoom:50%;" /></p><p>具有相同上行和下行速率的网络接入技术是: ( )</p><p>A、ADSL</p><p><strong>B、WiFi</strong> </p><p>C、CDMA </p><p>D、4G</p><blockquote><p>我们使用的ADSL是非对称的传输方式，即上行速率不等于下行速率；ADSL上行速率640Kbps到1Mbps，下行速率10Mbps到100Mbps。</p><p><img src="C:\Users\15727\AppData\Roaming\Typora\typora-user-images\image-20210629082042336.png" alt="image-20210629082042336"></p><p><span class="exturl"><a class="exturl__link"   href="https://www.zhihu.com/question/53150127/answer/135456359" >原理上wifi的mac层是对等的</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>这个题可以用排除法啊，ADSL是非对称的，C，D本质上都是同一类型的调制方式，CDMA有3G、4G，只有B是一种局域网络接入方式，理论上两个方向肯定是一样的，就像接收端发送端都是对等的</p></blockquote><p>使用UDP协议的应用层协议是: ( )</p><p>A、HTTP </p><p>B、 SMTP </p><p><strong>C、 DHCP</strong> </p><p>D、 FTP</p><p>不属于路由器设备产生的分组时延是: ( )</p><p><strong>A、传播时延</strong></p><p>B、 传输时延</p><p>C、 排队时延</p><p>D、 节点处理时延</p><p>下列不属于植入恶意软件的攻击方式是: ( )</p><p>A、病毒 </p><p>B、 蠕虫 </p><p>C、木马 </p><p><strong>D、DDoS攻击</strong></p><blockquote><ul><li>病毒<ul><li>基本上是破坏或修改文件</li><li>递归自我复制</li></ul></li><li>木马<ul><li>通过伪装为远程攻击做准备</li></ul></li><li>蠕虫<ul><li>利用网络复制</li><li>可以带有载荷，携带其他恶意行为</li></ul></li><li>rootkit<ul><li>提升到特权权限，控制计算机。</li></ul></li><li>后门<ul><li>绕过安全防护的机制</li><li>可以是软件也可以是算法，甚至是硬件</li></ul></li></ul></blockquote><p>下面不属于P2P网络应用的是: </p><p>A、迅雷下载</p><p>B、 BitTorrent 下载</p><p><strong>C、 电子邮件</strong></p><p>D、 Napster 集中式目录应用</p><p>一个网页文件由1个基本HTML文件和3个引用对象文件组成，所有文件都在同一个Web服务器上，则使用带流水线的持久HTTP连接的方式，显示该网页需要的时间延迟是:( )</p><p>A、2个RTT </p><p>B、3个RTT</p><p><strong>C、 4个RTT</strong></p><p>D、5个RTT</p><p>HTTP服务器使用的默认监听端口号是: ( )</p><p><strong>A、80</strong></p><p>B、8080</p><p>C、20</p><p>D、110</p><p>TCP没有提供的服务是: ( )</p><p>A、连接管理</p><p>B、 可靠传输</p><p>C、 拥塞控制</p><p><strong>D、带宽保证</strong></p><p>如果校验和是8位二进制序列，则数据0x8789的校验和是: ( )</p><p>A、0x10 </p><p><strong>B、 0x11</strong></p><p>C、 0xEF</p><p>D、OxEE</p><p>下列不是网络层功能的是: ( )</p><p>A、选路</p><p>B、转发</p><p><strong>C、进程通信</strong></p><p>D、虚电路连接</p><p>下列不属于192.168.10.0/22子网的IP是: ( )</p><p>A、192.168.101.1</p><p>B、192.168.102.1 </p><p>C、192.168.103.1</p><p><strong>D.  192.168.104.1</strong></p><p>实现给定IP地址解析对应的MAC地址的协议是: </p><p><strong>A、ARP</strong></p><p>B、DNS </p><p>C、 DHCP </p><p>D. HTTP</p><p>15、下列对于二层交换机描述错误的是: ( )</p><p>A、交换机通过MAC帧中的源MAC地址进行自学习更新交换表</p><p>B、交换机通过MAC帧中的目的MAC地址查询交换表确定输出接口</p><p>C、交换机端口连接共享网段使用CSMA/CD进行介质访问</p><p><strong>D、交换机对于冲突的报文进行广播转发</strong></p><blockquote><p>路由器能阻止广播，二层交换机不划分VLAN情况下不能阻止广播，三层交换机三层借口能阻止广播，三层交换机二层接口不能阻止广播。划分VLAN能阻止广播。原因：广播的原理是在同一网段内每个端口都发送一份同样的数据。二层交换机因为没有IP地址识。</p></blockquote><p>二、判断题(每小题2分，共20分)</p><p>1、家庭中电脑连接WiFi的速率和运营商提供的接入带宽是相同的 X</p><p>2、电路交换是面向连接的 V</p><blockquote><p>(单选题) 关于电路交换和分组交换,下列说法不正确的是 ( )</p><p> A. 电路交换是面向连接的 </p><p>B. 分组交换是面向无连接的 </p><p>C. 分组交换使用的是存储转发技术 </p><p>D. 电路交换的传输效率往往很高</p><p>答案 D</p></blockquote><p>3、SSL提供加密的TCP连接 V</p><p>4、两个邮件服务器之间使用POP3或IMAP实现邮件传输 X </p><p>5、TCP流量控制是指发送方的发送窗口小于等于接收方的接收窗口 V</p><p>6、TCP首部字段的序号是当前发送数据段第一个字节在发送缓冲区中的位置编号 V</p><p>7、VPN可以实现在公网上进行加密数据传输 V</p><blockquote><p><strong>vpn</strong>:通过对网络数据的封包和加密传输，<strong>在公网上</strong>传输私有数据，达到私有网络的安全级别。采用<strong>vpn</strong>技术的目的是为了在不安全的信道上<strong>实现</strong>安全信息传输，保证企业内部信息在internet上传输时的机密性和完整性，同时使用鉴别对通过ineternet进行的<strong>数据传输</strong>进行确认。</p><p> ssl:是一种协议； ssh:通过使用ssh，把所有传输的数据<strong>进行加密</strong>。“中间人”在传输中进行攻击就不可能<strong>实现</strong>了。能够防止dns和ip欺骗。并且传输的数据经过压缩，<strong>可以</strong>加快传输的速度。还<strong>可以</strong>代替telnet，<strong>可以</strong>为ftp、pop、甚至ppp提供一个安全的“通道”</p><p>SSH(Secure shell):通过SSH，把所有传输的数据<strong>进行加密</strong>。 Secure Socket Layer，为Netscape所研发，用以保障在Internet上<strong>数据传输</strong>之安全，利用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取及窃听。 二者的联系与区别：在OSI七层模型中,这两个安全传输协议其实都是建立在应用层上的: 在最初的设计意图中,SSL(Secure Sockets Layer (SSL) and Transport Layer Security (TLS))被设计为加强Web安全传输(HTTP/HTTPS/)的协议(事实上还有SMTP/NNTP等),SSH(Secure Shell)更多的则被设计为加强Telnet/FTP安全的传输协议,默认地,它使用22端口.SSL层: 借助下层协议的的信道安全的协商出一份加密密钥，并用此密钥来加密HTTP请求。</p></blockquote><p>8、DHCP协议使用Discover报文发现DHCP服务器(V )</p><p>9、二层交换机具有路由选择的功能( X )</p><p>10、PPP协议与以太网具有相同的帧格式(X )</p><p>三、简答和计算题(共50分)</p><p>1、简述TCP协议实现的功能? (6分)</p><blockquote><p>传输层用来提供端到端的服务，意思就是在这个层次，不需要关心报文的中间的转发，看上去就像两端直接在通信。<br>网络层则提供点到点的通信，用来处理网络中的报文路由转发。</p><p>TCP提供的高质量服务：可靠传输、流量控制、拥塞避免。</p><p>一、TCP可靠传输<br>可靠传输的话题，在数据链路层就已经得到思考与设计，TCP采用的策略与其十分类似:</p><p> 1）TCP是面向字节流的传输方式，TCP将需要发送的报文以字节流的方式放进TCP缓存中，并每次向IP中传递不定大小的字节流，称为报文段或段</p><p> 2）TCP发出一个报文段后，启动一个定时器，若在定时器到时前，没有收到确认，则重发该报文段。</p><p> 3）TCP通过校验和来检验首部与数据是否发生错误。若是，则丢弃该报文，并不向源套接字发送确认，等待其重传。</p><p> 4）通过IP协议传递过来的数据报很可能会时序到达。TCP协议根据序号可以将这些数据重新排序，最终以正确的顺序交给应用层。</p><p> 5）TCP协议还会丢弃IP数据报传过来的重复数据。</p><p>二、TCP流量控制<br>流量控制是指，当服务器端数据发送速率过快时，存在数据淹没的风险，客户端需要做出调整，降低服务器端的数据发送速率。</p><p>TCP的流量控制依靠设置TCP报文首部中的窗口字段来完成。</p><p>TCP报文窗口字段，决定了客户端接收缓存的大小，通过调整窗口字段，服务器将得知客户端预期接收的字节流大小，并随之调整发送速率。</p><p>三、TCP拥塞避免<br>拥塞避免常易与流量控制混淆，但两者并不相同。</p><p>流量控制是解决由发送方数据发送过快而接收方接收不过来问题的方法，作用于两台主机之间的数据传输，是局部性的。</p><p>拥塞避免是解决全局网络下，由于传输数据报过多，导致带宽不够、资源不足的问题，用于调控全局网络，是宏观性的。</p><p>原文链接：<span class="exturl"><a class="exturl__link"   href="https://blog.csdn.net/weixin_44580146/article/details/106969663" >https://blog.csdn.net/weixin_44580146/article/details/106969663</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p></blockquote><p>2、简述使用web缓存后网页请求响应的过程? (6分)</p><p>3、简述DNS服务器类型及DNS查询方法? (6分)</p><p>4、假设客户端建立连接时分配的初始序号是1234,服务器分配的初始序号是2478，填充下列TCP建立连接时的首部标识、序号和确认号的值? (6 分)<br><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210629100259.png" alt="image-20210629100259050"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210629100317.png" alt="image-20210629100317080"></p><p>6、简述路由由器存储转发分组的处理过程? (6 分)</p><p>7、简述Dijsktra算法? (6分)</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210629100350.png" alt="image-20210629100350736"></p>        <h2 id="题2"   >          <a href="#题2" class="heading-link"><i class="fas fa-link"></i></a>题2</h2>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210629202542.png" alt="image-20210629202542369"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210629202724.png" alt="image-20210629202717269"></p>        <h2 id="题3"   >          <a href="#题3" class="heading-link"><i class="fas fa-link"></i></a>题3</h2>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210630001953.png" alt="image-20210630001953121"></p><p><strong>Keep Curious , Keep Learning !</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;计算机网络-14-计网习题&quot;   &gt;
          &lt;a href=&quot;#计算机网络-14-计网习题&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;计算机网络 - 14 计网习题&lt;/h1&gt;</summary>
    
    
    
    <category term="基础知识" scheme="http://zjeff-953.gitee.io/zjeff/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="前端" scheme="http://zjeff-953.gitee.io/zjeff/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="后端" scheme="http://zjeff-953.gitee.io/zjeff/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="计算机网络" scheme="http://zjeff-953.gitee.io/zjeff/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 - 13 计网总结</title>
    <link href="http://zjeff-953.gitee.io/zjeff/2022/06/02/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%2013%20%E8%AE%A1%E7%BD%91%E6%80%BB%E7%BB%93/"/>
    <id>http://zjeff-953.gitee.io/zjeff/2022/06/02/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%2013%20%E8%AE%A1%E7%BD%91%E6%80%BB%E7%BB%93/</id>
    <published>2022-06-02T07:24:10.034Z</published>
    <updated>2022-05-27T02:37:26.151Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="计算机网络-13-计网总结"   >          <a href="#计算机网络-13-计网总结" class="heading-link"><i class="fas fa-link"></i></a>计算机网络 - 13 计网总结</h1>      <span id="more"></span>        <h2 id="数据传输过程"   >          <a href="#数据传输过程" class="heading-link"><i class="fas fa-link"></i></a>数据传输过程</h2>              <h2 id="分层总结"   >          <a href="#分层总结" class="heading-link"><i class="fas fa-link"></i></a>分层总结</h2>      <p>每个层需要了解如下几点</p><ol><li>PDU最小传输单位：</li><li>主要设备</li><li>该层传输范围</li><li>该层主要作用</li><li>编址名称和编址方案</li><li>主要协议（协议名称，协议作用，报文格式，交互过程）</li></ol><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210627133353.png" alt="image-20210627133353646"></p>        <h3 id="应用层"   >          <a href="#应用层" class="heading-link"><i class="fas fa-link"></i></a>应用层</h3>              <h4 id="PDU最小传输单位（消息message）"   >          <a href="#PDU最小传输单位（消息message）" class="heading-link"><i class="fas fa-link"></i></a>PDU最小传输单位（消息message）</h4>              <h4 id="主要设备："   >          <a href="#主要设备：" class="heading-link"><i class="fas fa-link"></i></a>主要设备：</h4>      <p>端系统</p>        <h4 id="该层传输范围"   >          <a href="#该层传输范围" class="heading-link"><i class="fas fa-link"></i></a>该层传输范围</h4>              <h4 id="该层主要作用"   >          <a href="#该层主要作用" class="heading-link"><i class="fas fa-link"></i></a>该层主要作用</h4>              <h4 id="编址名称和编址方案"   >          <a href="#编址名称和编址方案" class="heading-link"><i class="fas fa-link"></i></a>编址名称和编址方案</h4>              <h4 id="主要协议（协议名称，协议作用，报文格式，交互过程）"   >          <a href="#主要协议（协议名称，协议作用，报文格式，交互过程）" class="heading-link"><i class="fas fa-link"></i></a>主要协议（协议名称，协议作用，报文格式，交互过程）</h4>              <h3 id="传输层"   >          <a href="#传输层" class="heading-link"><i class="fas fa-link"></i></a>传输层</h3>              <h4 id="PDU最小传输单位（段Segment）"   >          <a href="#PDU最小传输单位（段Segment）" class="heading-link"><i class="fas fa-link"></i></a>PDU最小传输单位（段Segment）</h4>      <p>提供端到端的可靠报文传递和错误恢复（段Segment）</p>        <h4 id="主要设备"   >          <a href="#主要设备" class="heading-link"><i class="fas fa-link"></i></a>主要设备</h4>      <p>端系统</p>        <h4 id="该层传输范围-1"   >          <a href="#该层传输范围-1" class="heading-link"><i class="fas fa-link"></i></a>该层传输范围</h4>              <h4 id="该层主要作用-1"   >          <a href="#该层主要作用-1" class="heading-link"><i class="fas fa-link"></i></a>该层主要作用</h4>              <h4 id="编址名称和编址方案-1"   >          <a href="#编址名称和编址方案-1" class="heading-link"><i class="fas fa-link"></i></a>编址名称和编址方案</h4>              <h4 id="主要协议（协议名称，协议作用，报文格式，交互过程）-1"   >          <a href="#主要协议（协议名称，协议作用，报文格式，交互过程）-1" class="heading-link"><i class="fas fa-link"></i></a>主要协议（协议名称，协议作用，报文格式，交互过程）</h4>              <h5 id="TCP"   >          <a href="#TCP" class="heading-link"><i class="fas fa-link"></i></a>TCP</h5>      <p>为了满足TCP协议不丢包。TCP协议有如下规定</p><p>1、数据分片：发送端对数据进行分片，接受端要对数据进行重组，由TCP确定分片的大小并控制分片和重组</p><p>2、到达确认：接收端接收到分片数据时，根据分片数据序号向发送端发送一个确认</p><p>3、超时重发：发送方在发送分片时设置超时定时器，如果在定时器超时之后没有收到相应的确认，重发分片数据</p><p>4、滑动窗口：TCP连接的每一方的接受缓冲空间大小固定，接收端只允许另一端发送接收端缓冲区所能接纳的数据，TCP在滑动窗口的基础上提供流量控制，防止较快主机致使较慢主机的缓冲区溢出</p><p>5、失序处理：作为IP数据报来传输的TCP分片到达时可能会失序，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层；</p><p>6、重复处理：作为IP数据报来传输的TCP分片会发生重复，TCP的接收端必须丢弃重复的数据；</p><p>7、数据校验：TCP将保持它首部和数据的检验和，这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到分片的检验和有差错，TCP将丢弃这个分片，并不确认收到此报文段导致对端超时并重发</p>        <h5 id="UDP"   >          <a href="#UDP" class="heading-link"><i class="fas fa-link"></i></a>UDP</h5>              <h3 id="网络层"   >          <a href="#网络层" class="heading-link"><i class="fas fa-link"></i></a>网络层</h3>              <h4 id="PDU最小传输单位（包PackeT）"   >          <a href="#PDU最小传输单位（包PackeT）" class="heading-link"><i class="fas fa-link"></i></a>PDU最小传输单位（包PackeT）</h4>      <p>负责数据包从源到宿的传递和网际互连（包PackeT）</p>        <h4 id="主要设备-1"   >          <a href="#主要设备-1" class="heading-link"><i class="fas fa-link"></i></a>主要设备</h4>              <h5 id="路由器（Router）"   >          <a href="#路由器（Router）" class="heading-link"><i class="fas fa-link"></i></a>路由器（Router）</h5>      <p>负责网络层的数据中继。它能理解数据中的IP地址，如果它接收到一个数据包，就检查其中的IP地址：如果目标地址是本地网络的就不理会；如果是其他网络的，就将数据包转发出本地网络。它的作用在于连接相同或不同类型网络，并且能找到网络中数据传输最合适的路径即路由选择。</p><p> 因为路由器仅仅转发特定地址的数据包，不传送不支持路由协议的数据包传送和未知目标网络数据包的传送，所以可以防止广播风暴。</p>        <h5 id="网关（Gateway）"   >          <a href="#网关（Gateway）" class="heading-link"><i class="fas fa-link"></i></a>网关（Gateway）</h5>      <p> 网关（Gateway）负责网络层以上的数据中继，实现不同体系结构的 网络协议转换，它通常采用软件的方法实现，并且与特定的应用服务一一对应。</p><p> 网关是一种复杂的网络连接设备，可以支持不同协议之间的转换，实现不同协议网络之间的互连。网关具有对不兼容的高层协议进行转换的能力，为了实现异构设备之间的通信，网关需要对不同的链路层、专用会话层、表示层和应用层协议进行翻译和转换，所以网关兼有路由器、网桥、中继器的特性。</p><p> 若要使两个完全不同的网络（异构网）连接在一起，一般使用网关，在Internet中两个网络也要通过一台称为网关的计算机实现互联。这台计算机能根据用户通信目标计算机的IP地址，决定是否将用户发出的信息送出本地网络。同时，它还将外界发送给属于本地网络计算机的信息接收过来，它是一个网络与另一个网络相联的通道。为了使TCP/IP协议能够寻址，该通道被赋予一个IP地址，这个IP地址称为网关地址。</p><p> 所以，网关的作用就是将两个使用不同协议的网络段连接在一起的设备，对两个网络段中的使用不同传输协议的数据进行互相的翻译转换。在互连设备中，由于协议转换的复杂性，一般只能进行一对一的转换，或是少数几种特定应用协议的转换。</p>        <h4 id="该层传输范围-2"   >          <a href="#该层传输范围-2" class="heading-link"><i class="fas fa-link"></i></a>该层传输范围</h4>              <h4 id="该层主要作用-2"   >          <a href="#该层主要作用-2" class="heading-link"><i class="fas fa-link"></i></a>该层主要作用</h4>              <h4 id="编址名称和编址方案-2"   >          <a href="#编址名称和编址方案-2" class="heading-link"><i class="fas fa-link"></i></a>编址名称和编址方案</h4>              <h4 id="主要协议（协议名称，协议作用，报文格式，交互过程）-2"   >          <a href="#主要协议（协议名称，协议作用，报文格式，交互过程）-2" class="heading-link"><i class="fas fa-link"></i></a>主要协议（协议名称，协议作用，报文格式，交互过程）</h4>              <h3 id="数据链路层"   >          <a href="#数据链路层" class="heading-link"><i class="fas fa-link"></i></a>数据链路层</h3>              <h4 id="PDU最小传输单位（帧Frame）"   >          <a href="#PDU最小传输单位（帧Frame）" class="heading-link"><i class="fas fa-link"></i></a>PDU最小传输单位（帧Frame）</h4>      <p>将比特组装成帧和点到点的传递（帧Frame）</p>        <h4 id="主要设备-2"   >          <a href="#主要设备-2" class="heading-link"><i class="fas fa-link"></i></a>主要设备</h4>              <h5 id="集线器（HUB）"   >          <a href="#集线器（HUB）" class="heading-link"><i class="fas fa-link"></i></a>集线器（HUB）</h5>      <p> 集线器属于数据链路层，用于连接星型网。</p><p> 集线器（HUB）是一种典型或称为特殊的转发器，其的作用可以简单的理解为将一些机器连接起来组成一个局域网。它不具有智能处理能力，处理的数据只是电流而已，它采用共享带宽的工作方式，附接端口的所有计算机根据 CSMA/CD 协议竞争带宽的使用权，任一时刻只能由两台计算机之间进行通信。</p><p> 集线器属于纯硬件网络底层设备，基本上不具有类似于交换机的”智能记忆”能力和”学习”能力。它也不具备交换机所具有的MAC地址表，所以它发送数据时都是没有针对性的，而是采用 广播方式 发送。也就是说当它要向某节点发送数据时，不是直接把数据发送到目的节点，而是把数据包发送到与集线器相连的所有节点。</p><p>这种广播发送数据方式有两方面不足：</p><p>用户数据包向所有节点发送，很可能带来数据通信的不安全因素，一些别有用心的人很容易就能非法截获他人的数据包<br>CSMA/CD 协议只能采用半双工信道传输，网络通信效率低。再加上所有数据包都是向所有节点同时发送，就更可能造成网络塞车现象，更加降低了网络执行效率</p>        <h5 id="网桥（Gate-Bridge）"   >          <a href="#网桥（Gate-Bridge）" class="heading-link"><i class="fas fa-link"></i></a>网桥（Gate Bridge）</h5>      <p> 网桥（Gate Bridge）负责数据链路层的数据中继。互连两个独立的、仅在低两层实现上有差异的子网。</p><p> 数据链路层的作用包括数据链路的 建立、维护和拆除、帧包装、帧传输、帧同步、帧差错控制以及流量控制等。网桥工作在数据链路层，将两个局域网 LAN 连起来，根据MAC地址来转发帧。它可以有效地联接两个LAN，使本地通信限制在本网段内，并转发相应的信号至另一网段，因此网桥通常用于联接数量不多的、同一类型的网段。</p><p> 网桥的存储和转发功能与中继器相比有优点也有缺点，其优点是：</p><p>使用网桥进行互连克服了物理限制，这意味着构成lan的数据站总数和网段数很容易扩充。<br>网桥纳入存储和转发功能可使其适应于连接使用不同mac协议的两个lan，因而能构成一个不同lan混连在一起的混合网络环境。<br>网桥的中继功能仅仅依赖于mac帧的地址，因而对高层协议完全透明。网桥将一个较大的lan分成段，有利于改善可靠性、可用性和安全性。<br>网桥的主要缺点是：</p><p>由于网桥在执行转发前先接收帧并进行缓冲，与中继器相比会引入更多时延。<br>由于网桥不提供流控功能，因此在流量较大时有可能使其过载，从而造成帧的丢失。<br>其优点多于缺点，所以网桥能得到广泛使用。</p><p> 与转发器一样，网桥只是实现了网络的扩大，从网络层的角度来看，使用转发器连接的两个网络，仍然属于同一个网络。</p>        <h5 id="交换机（Switch）"   >          <a href="#交换机（Switch）" class="heading-link"><i class="fas fa-link"></i></a>交换机（Switch）</h5>      <p> 交换机（Switch）是一种简化的网桥，用于互连相同类型的网络，工作在数据链路层。它采用独享带宽的工作方式，交换机比集线器智能，网络上的数据是MAC地址的集合，它能分辨出帧中的源MAC地址和目的MAC地址，因此可以在任意两个端口之间建立联系，但交换机并不懂得IP地址。</p>        <h4 id="该层传输范围-3"   >          <a href="#该层传输范围-3" class="heading-link"><i class="fas fa-link"></i></a>该层传输范围</h4>              <h4 id="该层主要作用-3"   >          <a href="#该层主要作用-3" class="heading-link"><i class="fas fa-link"></i></a>该层主要作用</h4>              <h4 id="编址名称和编址方案-3"   >          <a href="#编址名称和编址方案-3" class="heading-link"><i class="fas fa-link"></i></a>编址名称和编址方案</h4>              <h4 id="主要协议（协议名称，协议作用，报文格式，交互过程）-3"   >          <a href="#主要协议（协议名称，协议作用，报文格式，交互过程）-3" class="heading-link"><i class="fas fa-link"></i></a>主要协议（协议名称，协议作用，报文格式，交互过程）</h4>              <h3 id="物理层"   >          <a href="#物理层" class="heading-link"><i class="fas fa-link"></i></a>物理层</h3>              <h4 id="PDU最小传输单位（比特Bit）"   >          <a href="#PDU最小传输单位（比特Bit）" class="heading-link"><i class="fas fa-link"></i></a>PDU最小传输单位（比特Bit）</h4>      <p>通过媒介传输比特,确定机械及电气规范（比特Bit）</p>        <h4 id="主要设备-3"   >          <a href="#主要设备-3" class="heading-link"><i class="fas fa-link"></i></a>主要设备</h4>              <h5 id="转发器（Repeater）"   >          <a href="#转发器（Repeater）" class="heading-link"><i class="fas fa-link"></i></a>转发器（Repeater）</h5>      <p>又被称为中继器或放大器，执行物理层协议，负责物理层的数据中继和电气信号的“再生”。用于互连两个相同类型的网段，主要功能是延伸网段和改变传输媒体，从而实现信息位的转发，转发器本身不执行信号的过滤功能。</p><p>转发器只是实现了网络的扩大，从网络层的角度来看，使用转发器连接的两个网络，仍然属于同一个网络。</p>        <h4 id="该层传输范围-4"   >          <a href="#该层传输范围-4" class="heading-link"><i class="fas fa-link"></i></a>该层传输范围</h4>              <h4 id="该层主要作用-4"   >          <a href="#该层主要作用-4" class="heading-link"><i class="fas fa-link"></i></a>该层主要作用</h4>              <h4 id="编址名称和编址方案-4"   >          <a href="#编址名称和编址方案-4" class="heading-link"><i class="fas fa-link"></i></a>编址名称和编址方案</h4>              <h4 id="主要协议（协议名称，协议作用，报文格式，交互过程）-4"   >          <a href="#主要协议（协议名称，协议作用，报文格式，交互过程）-4" class="heading-link"><i class="fas fa-link"></i></a>主要协议（协议名称，协议作用，报文格式，交互过程）</h4>              <h2 id="PDU总结"   >          <a href="#PDU总结" class="heading-link"><i class="fas fa-link"></i></a>PDU总结</h2>      <p>数据帧（Frame）：是一种信息单位，它的起始点和目的点都是数据链路层。</p><p>数据包（Packet）：也是一种信息单位，它的起始和目的地是网络层。</p><p>数据报（Datagram）：通常是指起始点和目的地都使用无连接网络服务的的网络层的信息单元。</p><p>段（Segment）：通常是指起始点和目的地都是传输层的信息单元。</p><p>消息（message）：是指起始点和目的地都在网络层以上（经常在应用层）的信息单元。</p><p><strong>结论: 应用层的http/ftp这些基于TCP的协议较大时可以被TCP拆分成一个个数据段，因为IP不可靠，所以TCP自己会分段，分段的大小保证每个数据段都能被一个IP数据包传输，这样IP发生丢包的时候就可以知道丢了那个，也不用重传整个TCP数据段。当使用基于UDP的应用层协议的时候，数据报会直接交付给IP进行分包，所以不可靠，如果要提高可靠性，需要在应用层进行封装。</strong></p><p><strong>总之：上层的可能被下层的拆分，但是不会被下层的合并</strong></p><p><strong>也就是说，一个数据帧不能有多个数据包，一个数据包不能有多个段，但是反之可以成立</strong></p><p>UDP:直接附上ip头，但在网络层会根据数据帧所能走大小执行分片。</p><p>TCP:双方会互相通报最大报文长度，从而在传输层分片</p><p><strong>首先需要理解的是数据报是不能比数据帧大的，数据帧根据不同网络（无线有线）长度会有所区别，数据包（一块数据）进行为网络层传输时会进行判别，如果长过是网络层要进行分片，成为数据报。</strong></p><p>原因：</p><p>以太网的MTU是1500，你可以用 netstat -i 命令查看这个值。如果IP层有数据包要传，而且数据包的长度超过了MTU，那么IP层就要对数据包进行分片（fragmentation）操作，使每一片的长度都小于或等于MTU。我们假设要传输一个UDP数据包，以太网的MTU为1500字节，一般IP首部为20字节，UDP首部为8字节，数据的净荷（payload）部分预留是1500-20-8=1472字节。如果数据部分大于1472字节，就会出现分片现象。</p><p>IP分片发生在IP层，不仅源端主机会进行分片，中间的路由器也有可能分片，因为不同的网络的MTU是不一样的，如果传输路径上的某个网络的MTU比源端网络的MTU要小，路由器就可能对IP数据报再次进行分片。而分片数据的重组只会发生在目的端的IP层。</p><p>但是正常情况下要避免在网络层分片：</p><p>原因是IP层是没有超时重传机制的，如果IP层对一个数据包进行了分片，只要有一个分片丢失了，只能依赖于传输层进行重传，结果是所有的分片都要重传一遍，这个代价有点大。由此可见，IP分片会大大降低传输层传送数据的成功率，所以我们要避免IP分片。</p><p>所以UDP:对于UDP包，我们需要在应用层去限制每个包的大小，一般不要超过1472字节，即以太网MTU（1500）—UDP首部（8）—IP首部（20）。</p><p>TCP：对于TCP数据，应用层就不需要考虑这个问题了，因为传输层已经帮我们做了。在建立连接的三次握手的过程中，连接双方会相互通告MSS（Maximum Segment Size，最大报文段长度），<strong>MSS一般是MTU—IP首部（20）—TCP首部（20）</strong>，每次发送的TCP数据都不会超过双方MSS的最小值，所以就保证了IP数据报不会超过MTU，避免了IP分片。</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210627132222.png" alt="image-20210627132222209"></p>        <h2 id="物理设备总结"   >          <a href="#物理设备总结" class="heading-link"><i class="fas fa-link"></i></a>物理设备总结</h2>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210629092959.png" alt="image-20210629092959265"></p>        <h2 id="协议总结"   >          <a href="#协议总结" class="heading-link"><i class="fas fa-link"></i></a>协议总结</h2>              <h1 id="参考资料"   >          <a href="#参考资料" class="heading-link"><i class="fas fa-link"></i></a>参考资料</h1>      <p><span class="exturl"><a class="exturl__link"   href="https://blog.csdn.net/Wwinky/article/details/118075564" >各层设备</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p><strong>Keep Curious , Keep Learning !</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;计算机网络-13-计网总结&quot;   &gt;
          &lt;a href=&quot;#计算机网络-13-计网总结&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;计算机网络 - 13 计网总结&lt;/h1&gt;</summary>
    
    
    
    <category term="基础知识" scheme="http://zjeff-953.gitee.io/zjeff/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="前端" scheme="http://zjeff-953.gitee.io/zjeff/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="后端" scheme="http://zjeff-953.gitee.io/zjeff/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="计算机网络" scheme="http://zjeff-953.gitee.io/zjeff/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 - 11 计网面试题</title>
    <link href="http://zjeff-953.gitee.io/zjeff/2022/06/02/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%2012%20%E8%AE%A1%E7%BD%91%E9%9D%A2%E8%AF%95-%E7%BC%93%E5%AD%98/"/>
    <id>http://zjeff-953.gitee.io/zjeff/2022/06/02/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%2012%20%E8%AE%A1%E7%BD%91%E9%9D%A2%E8%AF%95-%E7%BC%93%E5%AD%98/</id>
    <published>2022-06-02T07:24:10.031Z</published>
    <updated>2021-06-27T00:34:46.000Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="计算机网络-11-计网面试题"   >          <a href="#计算机网络-11-计网面试题" class="heading-link"><i class="fas fa-link"></i></a>计算机网络 - 11 计网面试题</h1>      <span id="more"></span><p><span class="exturl"><a class="exturl__link"   href="https://zhuanlan.zhihu.com/p/90507417" >https://zhuanlan.zhihu.com/p/90507417</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p><strong>Keep Curious , Keep Learning !</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;计算机网络-11-计网面试题&quot;   &gt;
          &lt;a href=&quot;#计算机网络-11-计网面试题&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;计算机网络 - 11 计网面试题&lt;/h1&gt;</summary>
    
    
    
    <category term="基础知识" scheme="http://zjeff-953.gitee.io/zjeff/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="前端" scheme="http://zjeff-953.gitee.io/zjeff/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="后端" scheme="http://zjeff-953.gitee.io/zjeff/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="计算机网络" scheme="http://zjeff-953.gitee.io/zjeff/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 - 11 计网面试题</title>
    <link href="http://zjeff-953.gitee.io/zjeff/2022/06/02/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%2011%20%E8%AE%A1%E7%BD%91%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://zjeff-953.gitee.io/zjeff/2022/06/02/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%2011%20%E8%AE%A1%E7%BD%91%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-06-02T07:24:10.028Z</published>
    <updated>2022-05-27T02:37:26.151Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="计算机网络-11-计网面试题"   >          <a href="#计算机网络-11-计网面试题" class="heading-link"><i class="fas fa-link"></i></a>计算机网络 - 11 计网面试题</h1>      <p>XS，上课一套， 实验一套，考试一套，面试一套。</p><p>不过没有本质区别，知识侧重点不同</p><span id="more"></span>        <h2 id="100个概念小题"   >          <a href="#100个概念小题" class="heading-link"><i class="fas fa-link"></i></a>100个概念小题</h2>              <h3 id="1）什么是链接？"   >          <a href="#1）什么是链接？" class="heading-link"><i class="fas fa-link"></i></a>1）什么是链接？</h3>      <p>链接是指两个设备之间的连接。它包括用于一个设备能够与另一个设备通信的电缆类型和协议。</p>        <h3 id="2）OSI-参考模型的层次是什么？"   >          <a href="#2）OSI-参考模型的层次是什么？" class="heading-link"><i class="fas fa-link"></i></a>2）OSI 参考模型的层次是什么？</h3>      <p>有 7 个 OSI 层：物理层，数据链路层，网络层，传输层，会话层，表示层和应用层。</p>        <h3 id="3）什么是骨干网-网络核心？"   >          <a href="#3）什么是骨干网-网络核心？" class="heading-link"><i class="fas fa-link"></i></a>3）什么是骨干网/网络核心？</h3>      <p>骨干网络是集中的基础设施，旨在将不同的路由和数据分发到各种网络。它还处理带宽管理和各种通道。</p>        <h3 id="4）什么是-LAN？"   >          <a href="#4）什么是-LAN？" class="heading-link"><i class="fas fa-link"></i></a>4）什么是 LAN？</h3>      <p>LAN 是局域网的缩写。它是指计算机与位于小物理位置的其他网络设备之间的连接。</p>        <h3 id="5）什么是节点？"   >          <a href="#5）什么是节点？" class="heading-link"><i class="fas fa-link"></i></a>5）什么是节点？</h3>      <p>节点是指连接发生的点。它可以是作为网络一部分的计算机或设备。为了形成网络连接，需要两个或更多个节点。</p>        <h3 id="6）什么是路由器？"   >          <a href="#6）什么是路由器？" class="heading-link"><i class="fas fa-link"></i></a>6）什么是路由器？</h3>      <p>路由器可以连接两个或更多网段。这些是在其路由表中存储信息的智能网络设备，例如路径，跳数等。有了这个信息，他们就可以确定数据传输的最佳路径。路由器在 OSI 网络层运行。</p>        <h3 id="7）什么是点对点链接？"   >          <a href="#7）什么是点对点链接？" class="heading-link"><i class="fas fa-link"></i></a>7）什么是点对点链接？</h3>      <p>它是指网络上两台计算机之间的直接连接。除了将电缆连接到两台计算机的 NIC卡之外，点对点连接不需要任何其他网络设备。</p>        <h3 id="8）什么是匿名-FTP？"   >          <a href="#8）什么是匿名-FTP？" class="heading-link"><i class="fas fa-link"></i></a>8）什么是匿名 FTP？</h3>      <p>匿名 FTP 是授予用户访问公共服务器中的文件的一种方式。允许访问这些服务器中的数据的用户不需要识别自己，而是以匿名访客身份登录。</p>        <h3 id="9）什么是子网掩码？"   >          <a href="#9）什么是子网掩码？" class="heading-link"><i class="fas fa-link"></i></a>9）什么是子网掩码？</h3>      <p>子网掩码与 IP 地址组合，以识别两个部分：扩展网络地址和主机地址。像 IP 地址一样，子网掩码由 32 位组成。</p>        <h3 id="10）UTP-电缆允许的最大长度是多少？"   >          <a href="#10）UTP-电缆允许的最大长度是多少？" class="heading-link"><i class="fas fa-link"></i></a>10）UTP 电缆允许的最大长度是多少？</h3>      <p>UTP 电缆的单段具有 90 到 100 米的允许长度。这种限制可以通过使用中继器和开关来克服</p>        <h3 id="11）什么是数据封装？"   >          <a href="#11）什么是数据封装？" class="heading-link"><i class="fas fa-link"></i></a>11）什么是数据封装？</h3>      <p>数据封装是在通过网络传输信息之前将信息分解成更小的可管理块的过程。在这个过程中，源和目标地址与奇偶校验一起附加到标题中。</p>        <h3 id="12）描述网络拓扑"   >          <a href="#12）描述网络拓扑" class="heading-link"><i class="fas fa-link"></i></a>12）描述网络拓扑</h3>      <p>网络拓扑是指计算机网络的布局。它显示了设备和电缆的物理布局，以及它们如何连接到彼此。</p>        <h3 id="13）什么是-VPN？"   >          <a href="#13）什么是-VPN？" class="heading-link"><i class="fas fa-link"></i></a>13）什么是 VPN？</h3>      <p>VPN 意味着虚拟专用网络，这种技术允许通过网络（如 Internet）创建安全通道。</p><p>例如，VPN 允许您建立到远程服务器的安全拨号连接。</p>        <h3 id="14）简要描述-NAT。"   >          <a href="#14）简要描述-NAT。" class="heading-link"><i class="fas fa-link"></i></a>14）简要描述 NAT。</h3>      <p>NAT 是网络地址转换。这是一种协议，为公共网络上的多台计算机提供一种方式来共享到 Internet 的单一连接。</p>        <h3 id="15）OSI-参考模型下网络层的工作是什么？"   >          <a href="#15）OSI-参考模型下网络层的工作是什么？" class="heading-link"><i class="fas fa-link"></i></a>15）OSI 参考模型下网络层的工作是什么？</h3>      <p>网络层负责数据路由，分组交换和网络拥塞控制。路由器在此层下运行。</p>        <h3 id="16）网络拓扑如何影响您在建立网络时的决策？"   >          <a href="#16）网络拓扑如何影响您在建立网络时的决策？" class="heading-link"><i class="fas fa-link"></i></a>16）网络拓扑如何影响您在建立网络时的决策？</h3>      <p>网络拓扑决定了互连设备必须使用什么媒介。它还作为适用于设置的材料，连接器和终端的基础。</p>        <h3 id="17）什么是-RIP？"   >          <a href="#17）什么是-RIP？" class="heading-link"><i class="fas fa-link"></i></a>17）什么是 RIP？</h3>      <p>RIP，路由信息协议的简称由路由器用于将数据从一个网络发送到另一个网络。</p><p>它通过将其路由表广播到网络中的所有其他路由器来有效地管理路由数据。它以跳数为单位确定网络距离。</p>        <h3 id="18）什么是不同的方式来保护计算机网络？"   >          <a href="#18）什么是不同的方式来保护计算机网络？" class="heading-link"><i class="fas fa-link"></i></a>18）什么是不同的方式来保护计算机网络？</h3>      <p>有几种方法可以做到这一点。在所有计算机上安装可靠和更新的防病毒程序。确保防火墙的设置和配置正确。用户认证也将有很大的帮助。所有这些组合将构成一个高度安全的网络。</p>        <h3 id="19）什么是-NIC？"   >          <a href="#19）什么是-NIC？" class="heading-link"><i class="fas fa-link"></i></a>19）什么是 NIC？</h3>      <p>NIC 是网络接口卡（网卡）的缩写。这是连接到 PC 以连接到网络设备。每个 NIC都有自己的 MAC 地址，用于标识网络上的 PC。</p>        <h3 id="20）什么是-WAN？"   >          <a href="#20）什么是-WAN？" class="heading-link"><i class="fas fa-link"></i></a>20）什么是 WAN？</h3>      <p>WAN 代表广域网。它是地理上分散的计算机和设备的互连。它连接位于不同地区和国家/地区的网络。</p>        <h3 id="21）OSI-物理层的重要性是什么？"   >          <a href="#21）OSI-物理层的重要性是什么？" class="heading-link"><i class="fas fa-link"></i></a>21）OSI 物理层的重要性是什么？</h3>      <p>物理层进行从数据位到电信号的转换，反之亦然。这是网络设备和电缆类型的考虑和设置。</p>        <h3 id="22）TCP-IP-下有多少层？"   >          <a href="#22）TCP-IP-下有多少层？" class="heading-link"><i class="fas fa-link"></i></a>22）TCP/IP 下有多少层？</h3>      <p>有四层：网络层，互联网层，传输层和应用层。</p>        <h3 id="23）什么是代理服务器，它们如何保护计算机网络？"   >          <a href="#23）什么是代理服务器，它们如何保护计算机网络？" class="heading-link"><i class="fas fa-link"></i></a>23）什么是代理服务器，它们如何保护计算机网络？</h3>      <p>代理服务器主要防止外部用户识别内部网络的 IP 地址。不知道正确的 IP 地址，甚至无法识别网络的物理位置。代理服务器可以使外部用户几乎看不到网络。</p>        <h3 id="24）OSI-会话层的功能是什么？"   >          <a href="#24）OSI-会话层的功能是什么？" class="heading-link"><i class="fas fa-link"></i></a>24）OSI 会话层的功能是什么？</h3>      <p>该层为网络上的两个设备提供协议和方法，通过举行会话来相互通信。这包括设置会话，管理会话期间的信息交换以及终止会话时的解除过程。</p>        <h3 id="25）实施容错系统的重要性是什么？有限吗？"   >          <a href="#25）实施容错系统的重要性是什么？有限吗？" class="heading-link"><i class="fas fa-link"></i></a>25）实施容错系统的重要性是什么？有限吗？</h3>      <p>容错系统确保持续的数据可用性。这是通过消除单点故障来实现的。但是，在某些情况下，这种类型的系统将无法保护数据，例如意外删除。</p>        <h3 id="26）10Base-T-是什么意思？"   >          <a href="#26）10Base-T-是什么意思？" class="heading-link"><i class="fas fa-link"></i></a>26）10Base-T 是什么意思？</h3>      <p>10 是指数据传输速率，在这种情况下是 10Mbps。“Base”是指基带。T 表示双绞线，这是用于该网络的电缆。</p>        <h3 id="27）什么是私有-IP-地址？"   >          <a href="#27）什么是私有-IP-地址？" class="heading-link"><i class="fas fa-link"></i></a>27）什么是私有 IP 地址？</h3>      <p>专用 IP 地址被分配用于内部网。这些地址用于内部网络，不能在外部公共网络上路由。这些确保内部网络之间不存在任何冲突，同时私有 IP 地址的范围同样可重复使用于多个内部网络，因为它们不会“看到”彼此。</p>        <h3 id="28）什么是-NOS？"   >          <a href="#28）什么是-NOS？" class="heading-link"><i class="fas fa-link"></i></a>28）什么是 NOS？</h3>      <p>NOS 或网络操作系统是专门的软件，其主要任务是向计算机提供网络连接，以便能够与其他计算机和连接的设备进行通信。</p>        <h3 id="29）什么是-DoS？"   >          <a href="#29）什么是-DoS？" class="heading-link"><i class="fas fa-link"></i></a>29）什么是 DoS？</h3>      <p>DoS 或拒绝服务攻击是试图阻止用户访问互联网或任何其他网络服务。这种攻击可能有不同的形式，由一群永久者组成。这样做的一个常见方法是使系统服务器过载，使其无法再处理合法流量，并将被强制重置。</p>        <h3 id="30）什么是-OSI，它在电脑网络中扮演什么角色？"   >          <a href="#30）什么是-OSI，它在电脑网络中扮演什么角色？" class="heading-link"><i class="fas fa-link"></i></a>30）什么是 OSI，它在电脑网络中扮演什么角色？</h3>      <p>OSI（开放系统互连）作为数据通信的参考模型。它由 7 层组成，每层定义了网络设备如何相互连接和通信的特定方面。一层可以处理所使用的物理介质，而另一层则指示如何通过网络实际传输数据。</p>        <h3 id="31）电缆被屏蔽并具有双绞线的目的是什么？"   >          <a href="#31）电缆被屏蔽并具有双绞线的目的是什么？" class="heading-link"><i class="fas fa-link"></i></a>31）电缆被屏蔽并具有双绞线的目的是什么？</h3>      <p>其主要目的是防止串扰。串扰是电磁干扰或噪声，可能影响通过电缆传输的数据。</p>        <h3 id="32）地址共享的优点是什么？"   >          <a href="#32）地址共享的优点是什么？" class="heading-link"><i class="fas fa-link"></i></a>32）地址共享的优点是什么？</h3>      <p>通过使用地址转换而不是路由，地址共享提供了固有的安全性优势。这是因为互联网上的主机只能看到提供地址转换的计算机上的外部接口的公共 IP 地址，而不是内部网络上的私有 IP 地址。</p>        <h3 id="33）什么是-MAC-地址？"   >          <a href="#33）什么是-MAC-地址？" class="heading-link"><i class="fas fa-link"></i></a>33）什么是 MAC 地址？</h3>      <p>MAC 或媒介访问控制，可以唯一地标识网络上的设备。它也被称为物理地址或以太网地址。MAC 地址由 6 个字节组成。</p>        <h3 id="34）在-OSI-参考模型方面，TCP-IP-应用层的等同层或多层是什么？"   >          <a href="#34）在-OSI-参考模型方面，TCP-IP-应用层的等同层或多层是什么？" class="heading-link"><i class="fas fa-link"></i></a>34）在 OSI 参考模型方面，TCP/IP 应用层的等同层或多层是什么？</h3>      <p>TCP/IP 应用层实际上在 OSI 模型上具有三个对等体：会话层，表示层和应用层。</p>        <h3 id="35）如何识别给定-IP-地址的-IP-类？"   >          <a href="#35）如何识别给定-IP-地址的-IP-类？" class="heading-link"><i class="fas fa-link"></i></a>35）如何识别给定 IP 地址的 IP 类？</h3>      <p>通过查看任何给定 IP 地址的第一个八位字节，您可以识别它是 A 类，B 类还是 C类。如果第一个八位字节以 0 位开头，则该地址为 Class A.如果以位 10 开头，则该地址为 B 类地址。如果从 110 开始，那么它是 C 类网络。</p>        <h3 id="36）OSPF-的主要目的是什么？"   >          <a href="#36）OSPF-的主要目的是什么？" class="heading-link"><i class="fas fa-link"></i></a>36）OSPF 的主要目的是什么？</h3>      <p>OSPF 或开放最短路径优先，是使用路由表确定数据交换的最佳路径的链路状态路由协议。</p>        <h3 id="37）什么是防火墙？"   >          <a href="#37）什么是防火墙？" class="heading-link"><i class="fas fa-link"></i></a>37）什么是防火墙？</h3>      <p>防火墙用于保护内部网络免受外部攻击。这些外部威胁可能是黑客谁想要窃取数据或计算机病毒，可以立即消除数据。它还可以防止来自外部网络的其他用户访问专用网络。</p>        <h3 id="38）什么是星形拓扑？"   >          <a href="#38）什么是星形拓扑？" class="heading-link"><i class="fas fa-link"></i></a>38）什么是星形拓扑？</h3>      <p>星形拓扑由连接到节点的中央集线器组成。这是最简单的设置和维护之一。</p>        <h3 id="39）什么是网关？"   >          <a href="#39）什么是网关？" class="heading-link"><i class="fas fa-link"></i></a>39）什么是网关？</h3>      <p>网关提供两个或多个网段之间的连接。它通常是运行网关软件并提供翻译服务的计算机。它是允许不同系统在网络上通信的关键。</p>        <h3 id="40）星型拓扑的缺点是什么？"   >          <a href="#40）星型拓扑的缺点是什么？" class="heading-link"><i class="fas fa-link"></i></a>40）星型拓扑的缺点是什么？</h3>      <p>星形拓扑的一个主要缺点是，一旦中央集线器或交换机被损坏，整个网络就变得不可用了。</p>        <h3 id="41）什么是-SLIP？"   >          <a href="#41）什么是-SLIP？" class="heading-link"><i class="fas fa-link"></i></a>41）什么是 SLIP？</h3>      <p>SLIP 或串行线路接口协议实际上是在 UNIX 早期开发的旧协议。这是用于远程访问的协议之一。</p>        <h3 id="42）给出一些私有网络地址的例子。"   >          <a href="#42）给出一些私有网络地址的例子。" class="heading-link"><i class="fas fa-link"></i></a>42）给出一些私有网络地址的例子。</h3>      <p>10.0.0.0，子网掩码为 255.0.0.0</p><p>172.16.0.0，子网掩码为 255.240.0.0</p><p>192.168.0.0，子网掩码为 255.255.0.0</p><p>个人网站：<span class="exturl"><a class="exturl__link"   href="https://www.cxyxiaowu.com" >https://www.cxyxiaowu.com</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h3 id="43）什么是-Tracert？"   >          <a href="#43）什么是-Tracert？" class="heading-link"><i class="fas fa-link"></i></a>43）什么是 Tracert？</h3>      <p>Tracert 是一个 Windows 实用程序，可用于跟踪从路由器到目标网络的数据采集的路由。它还显示了在整个传输路由期间采用的跳数。</p>        <h3 id="44）网络管理员的功能是什么？"   >          <a href="#44）网络管理员的功能是什么？" class="heading-link"><i class="fas fa-link"></i></a>44）网络管理员的功能是什么？</h3>      <p>网络管理员有许多责任，可以总结为 3 个关键功能：安装网络，配置网络设置以及网络的维护/故障排除。</p>        <h3 id="45）描述对等网络的一个缺点。"   >          <a href="#45）描述对等网络的一个缺点。" class="heading-link"><i class="fas fa-link"></i></a>45）描述对等网络的一个缺点。</h3>      <p>当您正在访问由网络上的某个工作站共享的资源时，该工作站的性能会降低。</p>        <h3 id="46）什么是混合网络？"   >          <a href="#46）什么是混合网络？" class="heading-link"><i class="fas fa-link"></i></a>46）什么是混合网络？</h3>      <p>混合网络是利用客户端 – 服务器和对等体系结构的网络设置。</p>        <h3 id="47）什么是-DHCP？"   >          <a href="#47）什么是-DHCP？" class="heading-link"><i class="fas fa-link"></i></a>47）什么是 DHCP？</h3>      <p>DHCP 是动态主机配置协议的缩写。其主要任务是自动为网络上的设备分配 IP 地址。它首先检查任何设备尚未占用的下一个可用地址，然后将其分配给网络设备。</p>        <h3 id="48）ARP-的主要工作是什么？"   >          <a href="#48）ARP-的主要工作是什么？" class="heading-link"><i class="fas fa-link"></i></a>48）ARP 的主要工作是什么？</h3>      <p>ARP 或地址解析协议的主要任务是将已知的 IP 地址映射到 MAC 层地址。</p>        <h3 id="49）什么是-TCP-IP？"   >          <a href="#49）什么是-TCP-IP？" class="heading-link"><i class="fas fa-link"></i></a>49）什么是 TCP/IP？</h3>      <p>TCP/IP 是传输控制协议/互联网协议的缩写。这是一组协议层，旨在在不同类型的计算机网络（也称为异构网络）上进行数据交换。</p>        <h3 id="50）如何使用路由器管理网络？"   >          <a href="#50）如何使用路由器管理网络？" class="heading-link"><i class="fas fa-link"></i></a>50）如何使用路由器管理网络？</h3>      <p>路由器内置了控制台，可让您配置不同的设置，如安全和数据记录。您可以为计算机分配限制，例如允许访问的资源，或者可以浏览互联网的某一天的特定时间。</p><p>您甚至可以对整个网络中看不到的网站施加限制。</p>        <h3 id="51）当您希望在不同平台（如-UNIX-系统和-Windows-服务器之间）传输文件时，可以应用什么协议？"   >          <a href="#51）当您希望在不同平台（如-UNIX-系统和-Windows-服务器之间）传输文件时，可以应用什么协议？" class="heading-link"><i class="fas fa-link"></i></a>51）当您希望在不同平台（如 UNIX 系统和 Windows 服务器之间）传输文件时，可以应用什么协议？</h3>      <p>使用 FTP（文件传输协议）在这些不同的服务器之间进行文件传输。这是可能的，因为 FTP 是平台无关的。</p>        <h3 id="52）默认网关的使用是什么？"   >          <a href="#52）默认网关的使用是什么？" class="heading-link"><i class="fas fa-link"></i></a>52）默认网关的使用是什么？</h3>      <p>默认网关提供了本地网络连接到外部网络的方法。用于连接外部网络的默认网关通常是外部路由器端口的地址。</p>        <h3 id="53）保护网络的一种方法是使用密码。什么可以被认为是好的密码？"   >          <a href="#53）保护网络的一种方法是使用密码。什么可以被认为是好的密码？" class="heading-link"><i class="fas fa-link"></i></a>53）保护网络的一种方法是使用密码。什么可以被认为是好的密码？</h3>      <p>良好的密码不仅由字母组成，还包括字母和数字的组合。结合大小写字母的密码比使用所有大写字母或全部小写字母的密码有利。密码必须不能被黑客很容易猜到，比如日期，姓名，收藏夹等等。</p>        <h3 id="54）UTP-电缆的正确终止率是多少？"   >          <a href="#54）UTP-电缆的正确终止率是多少？" class="heading-link"><i class="fas fa-link"></i></a>54）UTP 电缆的正确终止率是多少？</h3>      <p>非屏蔽双绞线网线的正常终止是 100 欧姆。</p>        <h3 id="55）什么是-Netstat？"   >          <a href="#55）什么是-Netstat？" class="heading-link"><i class="fas fa-link"></i></a>55）什么是 Netstat？</h3>      <p>Netstat 是一个命令行实用程序。它提供有关连接当前 TCP/IP 设置的有用信息。</p>        <h3 id="56）C-类网络中的网络-ID-数量是多少？"   >          <a href="#56）C-类网络中的网络-ID-数量是多少？" class="heading-link"><i class="fas fa-link"></i></a>56）C 类网络中的网络 ID 数量是多少？</h3>      <p>对于 C 类网络，可用的网络 ID 位数为 21。可能的网络 ID 数目为 2，提高到 21或 2,097,152。每个网络 ID 的主机 ID 数量为 2，增加到 8 减去 2，或 254。</p>        <h3 id="57）使用长于规定长度的电缆时会发生什么？"   >          <a href="#57）使用长于规定长度的电缆时会发生什么？" class="heading-link"><i class="fas fa-link"></i></a>57）使用长于规定长度的电缆时会发生什么？</h3>      <p>电缆太长会导致信号丢失。这意味着数据传输和接收将受到影响，因为信号长度下降。</p>        <h3 id="58）什么常见的软件问题可能导致网络缺陷？"   >          <a href="#58）什么常见的软件问题可能导致网络缺陷？" class="heading-link"><i class="fas fa-link"></i></a>58）什么常见的软件问题可能导致网络缺陷？</h3>      <p>软件相关问题可以是以下任何一种或其组合：</p><p>– 客户端服务器问题</p><p>– 应用程序冲突</p><p>– 配置错误</p><p>– 协议不匹配</p><p>– 安全问题</p><p>– 用户政策和权利问题</p>        <h3 id="59）什么是-ICMP？"   >          <a href="#59）什么是-ICMP？" class="heading-link"><i class="fas fa-link"></i></a>59）什么是 ICMP？</h3>      <p>ICMP 是 Internet 控制消息协议。它为 TCP/IP 协议栈内的协议提供消息传递和通信。这也是管理由 PING 等网络工具使用的错误信息的协议。</p>        <h3 id="60）什么是-Ping？"   >          <a href="#60）什么是-Ping？" class="heading-link"><i class="fas fa-link"></i></a>60）什么是 Ping？</h3>      <p>Ping 是一个实用程序，允许您检查网络上的网络设备之间的连接。您可以使用其IP 地址或设备名称（如计算机名称）ping 设备。</p>        <h3 id="61）什么是点对点（P2P）？"   >          <a href="#61）什么是点对点（P2P）？" class="heading-link"><i class="fas fa-link"></i></a>61）什么是点对点（P2P）？</h3>      <p>对等是不在服务器上回复的网络。该网络上的所有 PC 都是单独的工作站。</p>        <h3 id="62）什么是-DNS？"   >          <a href="#62）什么是-DNS？" class="heading-link"><i class="fas fa-link"></i></a>62）什么是 DNS？</h3>      <p>DNS 是域名系统。该网络服务的主要功能是为 TCP/IP 地址解析提供主机名。</p>        <h3 id="63）光纤与其他介质有什么优势？"   >          <a href="#63）光纤与其他介质有什么优势？" class="heading-link"><i class="fas fa-link"></i></a>63）光纤与其他介质有什么优势？</h3>      <p>光纤的一个主要优点是不太容易受到电气干扰。它还支持更高的带宽，意味着可以发送和接收更多的数据。长距离信号降级也非常小。</p>        <h3 id="64）集线器和交换机有什么区别？"   >          <a href="#64）集线器和交换机有什么区别？" class="heading-link"><i class="fas fa-link"></i></a>64）集线器和交换机有什么区别？</h3>      <p>集线器充当多端口中继器。然而，随着越来越多的设备连接到它，它将无法有效地管理通过它的流量。交换机提供了一个更好的替代方案，可以提高性能，特别是在所有端口上预期有高流量时。</p>        <h3 id="65）Windows-RRAS-服务支持的不同网络协议是什么？"   >          <a href="#65）Windows-RRAS-服务支持的不同网络协议是什么？" class="heading-link"><i class="fas fa-link"></i></a>65）Windows RRAS 服务支持的不同网络协议是什么？</h3>      <p>支持三种主要的网络协议：NetBEUI，TCP/IP 和 IPX。</p>        <h3 id="66）A，B-和-C-类网络中的最大网络和主机是什么？"   >          <a href="#66）A，B-和-C-类网络中的最大网络和主机是什么？" class="heading-link"><i class="fas fa-link"></i></a>66）A，B 和 C 类网络中的最大网络和主机是什么？</h3>      <p>对于 A 类，有 126 个可能的网络和 16,777,214 个主机</p><p>对于 B 类，有 16,384 个可能的网络和 65,534 个主机</p><p>对于 C 类，有 2,097,152 个可能的网络和 254 个主机</p>        <h3 id="67）直通电缆的标准颜色顺序是什么？"   >          <a href="#67）直通电缆的标准颜色顺序是什么？" class="heading-link"><i class="fas fa-link"></i></a>67）直通电缆的标准颜色顺序是什么？</h3>      <p>橙色/白色，橙色，绿色/白色，蓝色，蓝色/白色，绿色，棕色/白色，棕色。</p>        <h3 id="68）什么协议落在-TCP-IP-协议栈的应用层之下？"   >          <a href="#68）什么协议落在-TCP-IP-协议栈的应用层之下？" class="heading-link"><i class="fas fa-link"></i></a>68）什么协议落在 TCP/IP 协议栈的应用层之下？</h3>      <p>以下是 TCP/IP 应用层协议：FTP，TFTP，Telnet 和 SMTP。</p>        <h3 id="69）您需要连接两台电脑进行文件共享。是否可以这样做，而不使用集线器或路由器？"   >          <a href="#69）您需要连接两台电脑进行文件共享。是否可以这样做，而不使用集线器或路由器？" class="heading-link"><i class="fas fa-link"></i></a>69）您需要连接两台电脑进行文件共享。是否可以这样做，而不使用集线器或路由器？</h3>      <p>是的，您可以使用一根电缆将两台计算机连接在一起。在这种情况下可以使用交叉型电缆。在这种设置中，一条电缆的数据传输引脚连接到另一条电缆的数据接收引脚，反之亦然。</p>        <h3 id="70）什么是-ipconfig？"   >          <a href="#70）什么是-ipconfig？" class="heading-link"><i class="fas fa-link"></i></a>70）什么是 ipconfig？</h3>      <p>Ipconfig 是一个常用于识别网络上计算机的地址信息的实用程序。它可以显示物理地址以及 IP 地址。</p>        <h3 id="71）直通和交叉电缆有什么区别？"   >          <a href="#71）直通和交叉电缆有什么区别？" class="heading-link"><i class="fas fa-link"></i></a>71）直通和交叉电缆有什么区别？</h3>      <p>直通电缆用于将计算机连接到交换机，集线器或路由器。交叉电缆用于将两个类似设备连接在一起，如 PC 到 PC 或集线器到集线器。</p>        <h3 id="72）什么是客户端-服务器？"   >          <a href="#72）什么是客户端-服务器？" class="heading-link"><i class="fas fa-link"></i></a>72）什么是客户端/服务器？</h3>      <p>客户端/服务器是一种类型的网络，其中一个或多个计算机充当服务器。服务器提供集中的资源库，如打印机和文件。客户端是指访问服务器的工作站。</p>        <h3 id="73）描述网络。"   >          <a href="#73）描述网络。" class="heading-link"><i class="fas fa-link"></i></a>73）描述网络。</h3>      <p>网络是指用于数据通信的计算机和外围设备之间的互连。可以使用有线电缆或通过无线链路进行网络连接。</p>        <h3 id="74）将-NIC-卡从一台-PC-移动到另一台-PC-时，MAC-地址是否也被转移？"   >          <a href="#74）将-NIC-卡从一台-PC-移动到另一台-PC-时，MAC-地址是否也被转移？" class="heading-link"><i class="fas fa-link"></i></a>74）将 NIC 卡从一台 PC 移动到另一台 PC 时，MAC 地址是否也被转移？</h3>      <p>是的，那是因为 MAC 地址是硬连线到 NIC 电路，而不是 PC。这也意味着当 NIC卡被另一个替换时，PC 可以具有不同的 MAC 地址。</p>        <h3 id="75）解释聚类支持"   >          <a href="#75）解释聚类支持" class="heading-link"><i class="fas fa-link"></i></a>75）解释聚类支持</h3>      <p>群集支持是指网络操作系统在容错组中连接多台服务器的能力。这样做的主要目的是在一台服务器发生故障的情况下，集群中的下一个服务器将继续进行所有处理。</p>        <h3 id="76）在包含两个服务器和二十个工作站的网络中，安装防病毒程序的最佳位置是哪里？"   >          <a href="#76）在包含两个服务器和二十个工作站的网络中，安装防病毒程序的最佳位置是哪里？" class="heading-link"><i class="fas fa-link"></i></a>76）在包含两个服务器和二十个工作站的网络中，安装防病毒程序的最佳位置是哪里？</h3>      <p>必须在所有服务器和工作站上安装防病毒程序，以确保保护。这是因为个人用户可以访问任何工作站，并在插入可移动硬盘驱动器或闪存驱动器时引入计算机病毒。</p>        <h3 id="77）描述以太网。"   >          <a href="#77）描述以太网。" class="heading-link"><i class="fas fa-link"></i></a>77）描述以太网。</h3>      <p>以太网是当今使用的流行网络技术之一。它是在 20 世纪 70 年代初开发的，并且基于 IEEE 中规定的规范。以太网在局域网中使用。</p>        <h3 id="78）实现环形拓扑有什么缺点？"   >          <a href="#78）实现环形拓扑有什么缺点？" class="heading-link"><i class="fas fa-link"></i></a>78）实现环形拓扑有什么缺点？</h3>      <p>如果网络上的一个工作站发生故障，可能会导致整个网络丢失。另一个缺点是，当需要在网络的特定部分进行调整和重新配置时，整个网络也必须被暂时关闭。</p>        <h3 id="79）CSMA-CD-和-CSMA-CA-有什么区别？"   >          <a href="#79）CSMA-CD-和-CSMA-CA-有什么区别？" class="heading-link"><i class="fas fa-link"></i></a>79）CSMA/CD 和 CSMA/CA 有什么区别？</h3>      <p>CSMA/CD 或碰撞检测，每当碰撞发生时重新发送数据帧。CSMA/CA 或碰撞避免，将首先在数据传输之前广播意图发送。</p>        <h3 id="80）什么是-SMTP？"   >          <a href="#80）什么是-SMTP？" class="heading-link"><i class="fas fa-link"></i></a>80）什么是 SMTP？</h3>      <p>SMTP 是简单邮件传输协议的缩写。该协议处理所有内部邮件，并在 TCP/IP 协议栈上提供必要的邮件传递服务。</p>        <h3 id="81）什么是组播路由？"   >          <a href="#81）什么是组播路由？" class="heading-link"><i class="fas fa-link"></i></a>81）什么是组播路由？</h3>      <p>组播路由是一种有针对性的广播形式，将消息发送到所选择的用户组，而不是将其发送到子网上的所有用户。</p>        <h3 id="82）加密在网络上的重要性是什么？"   >          <a href="#82）加密在网络上的重要性是什么？" class="heading-link"><i class="fas fa-link"></i></a>82）加密在网络上的重要性是什么？</h3>      <p>加密是将信息转换成用户不可读的代码的过程。然后使用秘密密钥或密码将其翻译或解密回其正常可读格式。加密有助于确保中途截获的信息仍然不可读，因为用户必须具有正确的密码或密钥。</p>        <h3 id="83）如何安排和显示-IP-地址？"   >          <a href="#83）如何安排和显示-IP-地址？" class="heading-link"><i class="fas fa-link"></i></a>83）如何安排和显示 IP 地址？</h3>      <p>IP 地址显示为一系列由周期或点分隔的四位十进制数字。这种安排的另一个术语是点分十进制格式。一个例子是 192.168.101.2</p>        <h3 id="84）解释认证的重要性。"   >          <a href="#84）解释认证的重要性。" class="heading-link"><i class="fas fa-link"></i></a>84）解释认证的重要性。</h3>      <p>认证是在用户登录网络之前验证用户凭据的过程。它通常使用用户名和密码进行。这提供了限制来自网络上的有害入侵者的访问的安全手段。</p>        <h3 id="85）隧道模式是什么意思？"   >          <a href="#85）隧道模式是什么意思？" class="heading-link"><i class="fas fa-link"></i></a>85）隧道模式是什么意思？</h3>      <p>这是一种数据交换模式，其中两个通信计算机本身不使用 IPSec。相反，将 LAN连接到中转网络的网关创建了一个使用 IPSec 协议来保护通过它的所有通信的虚拟隧道。</p>        <h3 id="86）建立-WAN-链路涉及的不同技术有哪些？"   >          <a href="#86）建立-WAN-链路涉及的不同技术有哪些？" class="heading-link"><i class="fas fa-link"></i></a>86）建立 WAN 链路涉及的不同技术有哪些？</h3>      <p>模拟连接 – 使用常规电话线；数字连接 – 使用数字电话线；交换连接 – 使用发送方和接收方之间的多组链接来移动数据。</p>        <h3 id="87）网格拓扑的一个优点是什么？"   >          <a href="#87）网格拓扑的一个优点是什么？" class="heading-link"><i class="fas fa-link"></i></a>87）网格拓扑的一个优点是什么？</h3>      <p>在一个链接失败的情况下，总会有另一个链接可用。网状拓扑实际上是最容错的网络拓扑之一。</p>        <h3 id="88）在排除计算机网络问题时，可能会发生什么常见的硬件相关问题？"   >          <a href="#88）在排除计算机网络问题时，可能会发生什么常见的硬件相关问题？" class="heading-link"><i class="fas fa-link"></i></a>88）在排除计算机网络问题时，可能会发生什么常见的硬件相关问题？</h3>      <p>大部分网络由硬件组成。这些领域的问题可能包括硬盘故障，NIC 损坏甚至硬件启动。不正确的硬件配置也是其中一个疑难问题。</p>        <h3 id="89）可以做什么来修复信号衰减问题？"   >          <a href="#89）可以做什么来修复信号衰减问题？" class="heading-link"><i class="fas fa-link"></i></a>89）可以做什么来修复信号衰减问题？</h3>      <p>处理这种问题的常见方法是使用中继器和集线器，因为它将有助于重新生成信号，从而防止信号丢失。检查电缆是否正确终止也是必须的。</p>        <h3 id="90）动态主机配置协议如何协助网络管理？"   >          <a href="#90）动态主机配置协议如何协助网络管理？" class="heading-link"><i class="fas fa-link"></i></a>90）动态主机配置协议如何协助网络管理？</h3>      <p>网络管理员不必访问每台客户端计算机来配置静态 IP 地址，而是可以应用动态主机配置协议来创建称为可以动态分配给客户端的范围的 IP 地址池。</p>        <h3 id="91）解释网络概念的概况？"   >          <a href="#91）解释网络概念的概况？" class="heading-link"><i class="fas fa-link"></i></a>91）解释网络概念的概况？</h3>      <p>配置文件是为每个用户设置的配置设置。例如，可以创建将用户置于组中的配置文件。</p>        <h3 id="92）什么是-Sneakernet？"   >          <a href="#92）什么是-Sneakernet？" class="heading-link"><i class="fas fa-link"></i></a>92）什么是 Sneakernet？</h3>      <p>Sneakernet 被认为是最早的联网形式，其中使用可移动介质（如磁盘，磁带）物理传输数据。</p>        <h3 id="93）IEEE-在计算机网络中的作用是什么？"   >          <a href="#93）IEEE-在计算机网络中的作用是什么？" class="heading-link"><i class="fas fa-link"></i></a>93）IEEE 在计算机网络中的作用是什么？</h3>      <p>IEEE 或电气和电子工程师学会是由电气和电子设备标准发布和管理的工程师组成的组织。这包括网络设备，网络接口，cablings 和连接器。</p>        <h3 id="94）TCP-IP-Internet-层下有哪些协议？"   >          <a href="#94）TCP-IP-Internet-层下有哪些协议？" class="heading-link"><i class="fas fa-link"></i></a>94）TCP/IP Internet 层下有哪些协议？</h3>      <p>该层管理的协议有 4 种。这些是 ICMP，IGMP，IP 和 ARP。</p>        <h3 id="95）谈到网络，什么是权限？"   >          <a href="#95）谈到网络，什么是权限？" class="heading-link"><i class="fas fa-link"></i></a>95）谈到网络，什么是权限？</h3>      <p>权限是指在网络上执行特定操作的授权许可。网络上的每个用户可以分配个人权限，具体取决于该用户必须允许的内容。</p>        <h3 id="96）建立-VLAN-的一个基本要求是什么？"   >          <a href="#96）建立-VLAN-的一个基本要求是什么？" class="heading-link"><i class="fas fa-link"></i></a>96）建立 VLAN 的一个基本要求是什么？</h3>      <p>需要一个 VLAN，因为在交换机级别只有一个广播域，这意味着每当新用户连接时，该信息都会传播到整个网络。交换机上的 VLAN 有助于在交换机级别创建单独的广播域。它用于安全目的。</p>        <h3 id="97）什么是-IPv6？"   >          <a href="#97）什么是-IPv6？" class="heading-link"><i class="fas fa-link"></i></a>97）什么是 IPv6？</h3>      <p>IPv6 或 Internet 协议版本 6 被开发以替代 IPv4。目前，IPv4 正在用于控制互联网流量，但 IPv4 已经饱和。IPv6 能够克服这个限制。</p>        <h3 id="98）什么是-RSA-算法？"   >          <a href="#98）什么是-RSA-算法？" class="heading-link"><i class="fas fa-link"></i></a>98）什么是 RSA 算法？</h3>      <p>RSA 是 Rivest-Shamir-Adleman 算法的缩写。它是目前最常用的公钥加密算法。</p><p>详细介绍：<span class="exturl"><a class="exturl__link"   href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&amp;mid=2247485579&amp;idx=2&amp;sn=e4a9085fc53a9138d16be34994b9e269&amp;chksm=fa0e670acd79ee1c9c37632cb1ec2de0a5de2e210381bd1a867304bea22a78f6153294661e74&amp;scene=21#wechat_redirect" >https://www.cxyxiaowu.com/718.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h3 id="99）什么是网格拓扑？"   >          <a href="#99）什么是网格拓扑？" class="heading-link"><i class="fas fa-link"></i></a>99）什么是网格拓扑？</h3>      <p>网格拓扑是一种设置，其中每个设备都直接连接到网络上的每个其他设备。因此，它要求每个设备具有至少两个网络连接。</p>        <h3 id="100）100Base-FX-网络的最大段长度是多少？"   >          <a href="#100）100Base-FX-网络的最大段长度是多少？" class="heading-link"><i class="fas fa-link"></i></a>100）100Base-FX 网络的最大段长度是多少？</h3>      <p>使用 100Base-FX 的网段的最大允许长度为 412 米。整个网络的最大长度为 5 公里。</p>        <h2 id="谈下你对五层网络协议体系结构的理解？"   >          <a href="#谈下你对五层网络协议体系结构的理解？" class="heading-link"><i class="fas fa-link"></i></a>谈下你对五层网络协议体系结构的理解？</h2>      <p>学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。</p>        <h3 id="1-应用层"   >          <a href="#1-应用层" class="heading-link"><i class="fas fa-link"></i></a>1. 应用层</h3>      <p>应用层（application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。我们把应用层交互的数据单元称为报文。</p>        <h3 id="2-运输层"   >          <a href="#2-运输层" class="heading-link"><i class="fas fa-link"></i></a>2. 运输层</h3>      <p>运输层（transport layer）的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。</p><p>由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p>        <h3 id="3-网络层"   >          <a href="#3-网络层" class="heading-link"><i class="fas fa-link"></i></a>3. 网络层</h3>      <p>在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP / IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。</p>        <h3 id="4-数据链路层"   >          <a href="#4-数据链路层" class="heading-link"><i class="fas fa-link"></i></a>4. 数据链路层</h3>      <p>数据链路层（data link layer）通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如：同步信息，地址信息，差错控制等）。</p><p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。控制信息还使接收端能够检测到所收到的帧中有无差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</p>        <h3 id="5-物理层"   >          <a href="#5-物理层" class="heading-link"><i class="fas fa-link"></i></a>5. 物理层</h3>      <p>在物理层上所传送的数据单位是比特。物理层（physical layer）的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>        <h2 id="常用协议"   >          <a href="#常用协议" class="heading-link"><i class="fas fa-link"></i></a>常用协议</h2>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210620082340.jpg" alt="5-1604667697" style="zoom: 80%;" /></p><p><strong>Keep Curious , Keep Learning !</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;计算机网络-11-计网面试题&quot;   &gt;
          &lt;a href=&quot;#计算机网络-11-计网面试题&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;计算机网络 - 11 计网面试题&lt;/h1&gt;
      &lt;p&gt;XS，上课一套， 实验一套，考试一套，面试一套。&lt;/p&gt;
&lt;p&gt;不过没有本质区别，知识侧重点不同&lt;/p&gt;</summary>
    
    
    
    <category term="基础知识" scheme="http://zjeff-953.gitee.io/zjeff/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="前端" scheme="http://zjeff-953.gitee.io/zjeff/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="后端" scheme="http://zjeff-953.gitee.io/zjeff/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="计算机网络" scheme="http://zjeff-953.gitee.io/zjeff/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 - 08 计网大纲</title>
    <link href="http://zjeff-953.gitee.io/zjeff/2022/06/02/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%2010%20%E8%AE%A1%E7%BD%91%E5%A4%A7%E7%BA%B2/"/>
    <id>http://zjeff-953.gitee.io/zjeff/2022/06/02/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%2010%20%E8%AE%A1%E7%BD%91%E5%A4%A7%E7%BA%B2/</id>
    <published>2022-06-02T07:24:10.025Z</published>
    <updated>2022-05-27T02:37:26.151Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="计算机网络-08-计网大纲"   >          <a href="#计算机网络-08-计网大纲" class="heading-link"><i class="fas fa-link"></i></a>计算机网络 - 08 计网大纲</h1>      <span id="more"></span>        <h1 id="课本重点"   >          <a href="#课本重点" class="heading-link"><i class="fas fa-link"></i></a>课本重点</h1>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210626201136.png" alt="d82a9a09ff6548230c4c8a555fa20eb"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210626201128.png" alt="bc9b3043e26b0bac19d244af315cf35"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210626201125.png" alt="9119e10f30188d42adad99326fad52a"></p>        <h1 id="重点内容"   >          <a href="#重点内容" class="heading-link"><i class="fas fa-link"></i></a>重点内容</h1>              <h1 id="TCP-IP协议体系"   >          <a href="#TCP-IP协议体系" class="heading-link"><i class="fas fa-link"></i></a>TCP/IP协议体系</h1>              <h2 id="TCP-IP协议体系的认知"   >          <a href="#TCP-IP协议体系的认知" class="heading-link"><i class="fas fa-link"></i></a>TCP/IP协议体系的认知</h2>      <ul><li>一些概念<ul><li>内核态</li><li>用户态</li><li>应用层（接触较多）</li><li>数据链路层</li><li>数据传输对等</li></ul></li></ul>        <h2 id="数据链路层"   >          <a href="#数据链路层" class="heading-link"><i class="fas fa-link"></i></a>数据链路层</h2>      <ul><li>以太网帧的格式</li><li>MTU（最大传输单元）概念</li><li>ARP协议、RARP协议（即地址解析和逆地址解析）<ul><li>一般归入链路层，网络层和链路层的中间协议</li><li>报文格式</li><li>IP和MAC地址互查</li><li>ARP缓存</li></ul></li></ul>        <h2 id="网络层"   >          <a href="#网络层" class="heading-link"><i class="fas fa-link"></i></a>网络层</h2>      <ul><li>掌握IP首部格式：如16位分片标识、DF不分片标志、MF更多分片标志、13位片偏移，8位生存时间TTL，16位的首部检验和等等</li><li>掌握IP分片</li><li>掌握IP选路（路由表）</li><li>掌握ICMP协议<ul><li>报文格式</li><li>报文的两大分类：查询+交错<ul><li>2种查询报文+5种差错报文</li></ul></li></ul></li></ul>        <h2 id="传输层"   >          <a href="#传输层" class="heading-link"><i class="fas fa-link"></i></a>传输层</h2>      <ul><li>掌握UDP协议：包括特点+首部各个字段</li><li>掌握TCP协议：特点+首部字段+可靠机制</li><li>TCP连接控制机制：三次握手、四次挥手、同时打开、同时关闭、半关闭</li><li>TCP流量控制机制：滑动窗口、慢启动、拥塞避免、快速重传、快速恢复</li><li>TCP超时重传机制：各种定时器（4个）</li></ul>        <h2 id="应用层"   >          <a href="#应用层" class="heading-link"><i class="fas fa-link"></i></a>应用层</h2>      <ul><li>掌握DNS协议</li><li>掌握DNS协议的名字空间</li><li>DNS指针查询（反向查找或逆向解析）基本原理</li><li>DNS缓存</li><li>掌握FTP协议（网络界的活化石）<ul><li>两条链接：控制连接+数据连接</li><li>两种工作模式：PASV+PORT</li><li>各种指令和响应码</li><li>FTP断点续传、匿名FTP</li></ul></li><li>HTTP协议<ul><li>报文格式：请求报文+响应报文+各种请求字段+响应头各种字段</li><li>http状态码</li></ul></li><li>HTTPS协议<ul><li>https详细握手过程</li><li>摘要算法、数字签名、数字证书的原理和过程</li></ul></li></ul>        <h1 id="知识体系"   >          <a href="#知识体系" class="heading-link"><i class="fas fa-link"></i></a>知识体系</h1>      <p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210626213559.jpg" alt="img"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210626213603.jpg" alt="img"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210626213608.jpg" alt="img"></p>        <h1 id="做题家"   >          <a href="#做题家" class="heading-link"><i class="fas fa-link"></i></a>做题家</h1>      <p>【匿名】汪星人 2021/6/17 17:28:59<br>请问老师，PPT中标注为*的内容，考试是不会涉及的吗？</p><p>王老师(20233643) 2021/6/17 17:29:19<br>是的，不会涉及</p><p>FTP不要求</p><p>【匿名】中箭虎 2021/6/22 16:18:18<br>请问老师，虚电路和数据报网络是不是只需要了解就好了</p><p>王老师(20233643) 2021/6/22 16:19:18<br>是的，了解一下对应的概念特点</p><p>郑博文-2019091608006(1061829415) 2021/6/23 16:59:41<br>老师，rdt的那个FSM图要求会画吗？</p><p>王老师(20233643) 2021/6/23 17:07:41<br>rdt那些不需要FSM，只需要了解对应的特点；对于TCP拥塞控制，由于比较复杂，建议理解体会FSM图，这样能更清晰地理解拥塞控制过程原理，如果不借助 FSM 图也能够清晰阐述其过程原理，也可以。</p><p>【匿名】小魔王 2021/6/23 19:55:57<br>IP广播地址255.255.255.255。当一台主机发出一个目的地址为255.255.255.255的数据报时，该报文会交付给同一个网络中的所有主机。路由器耶会有选择地向邻近地子网转发该报文。（虽然它们通常不这样做）</p><p>【匿名】小魔王 2021/6/23 19:56:14<br>老师，书上原文这样描述，做题的话，就认为有可能是吗</p><p>王老师(20233643) 2021/6/23 19:57:43<br>是的</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210629150602.png" alt="image-20210629150602356"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210629150628.png" alt="image-20210629150628501"></p><p>2019091608030 刘雨璐(1097202005) 2021/6/24 21:34:05<br>老师，ICMP需要掌握吗</p><p>王老师(20233643) 2021/6/24 22:17:04<br>需要掌握</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210629150650.png" alt="image-20210629150650042"></p><p>郑博文-2019091608006(1061829415) 2021/6/25 12:40:40<br>老师，套接字编程那些具体的函数和参数要完全记住吗？有点多<img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210629150656.gif" alt="img">。</p><p>王老师(20233643) 2021/6/25 13:21:17<br>套接字编程流程中的主要函数及参数需要掌握，比如listen, accept, bind等</p><p>王老师(20233643) 2021/6/27 18:34:46<br>毒性逆转不做考查要求</p><p>2019091604027-甘云荟(1529486412) 2021/6/28 23:34:43<br>老师，请问UDP的专有函数，recvfrom()和sento()需要掌握吗？@王老师 </p><p>王老师(20233643) 2021/6/28 23:36:00<br>TCP，UDP的函数都需要的</p><p>2019091604027-甘云荟(1529486412) 2021/6/29 13:42:33<br>老师，请问估计RTT和重传超时间隔和具体公式需要掌握吗？@王老师 </p><p>王老师(20233643) 2021/6/29 13:42:56<br>需要的</p><p>2019091604027-甘云荟(1529486412) 2021/6/29 13:44:04<br>那a和b的值是按课本推荐值来取0.125和0.25吗？</p><p>王老师(20233643) 2021/6/29 13:45:23<br>是的，如果出现类似考题，题中没有给出参数取值，就按照这两个默认值</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210629151057.png" alt="image-20210629151056832"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210629151158.png" alt="image-20210629151158549"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210629151541.png" alt="image-2021062 9151540691"></p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210629155720.png" alt="image-20210629155720471"></p><p><strong>Keep Curious , Keep Learning !</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;计算机网络-08-计网大纲&quot;   &gt;
          &lt;a href=&quot;#计算机网络-08-计网大纲&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;计算机网络 - 08 计网大纲&lt;/h1&gt;</summary>
    
    
    
    <category term="基础知识" scheme="http://zjeff-953.gitee.io/zjeff/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="前端" scheme="http://zjeff-953.gitee.io/zjeff/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="后端" scheme="http://zjeff-953.gitee.io/zjeff/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="计算机网络" scheme="http://zjeff-953.gitee.io/zjeff/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 - 09 计网大题</title>
    <link href="http://zjeff-953.gitee.io/zjeff/2022/06/02/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%2009%20%E8%AE%A1%E7%BD%91%E5%A4%A7%E9%A2%98/"/>
    <id>http://zjeff-953.gitee.io/zjeff/2022/06/02/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%2009%20%E8%AE%A1%E7%BD%91%E5%A4%A7%E9%A2%98/</id>
    <published>2022-06-02T07:24:10.023Z</published>
    <updated>2022-05-27T02:37:26.151Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="计算机网络-09-计网大题"   >          <a href="#计算机网络-09-计网大题" class="heading-link"><i class="fas fa-link"></i></a>计算机网络 - 09 计网大题</h1>      <p>编程题看06 , 简答题和综合体可能考点进行梳理, 自底向下梳理</p><span id="more"></span>        <h2 id="简答题"   >          <a href="#简答题" class="heading-link"><i class="fas fa-link"></i></a>简答题</h2>              <h3 id="TCP-IP-四层协议"   >          <a href="#TCP-IP-四层协议" class="heading-link"><i class="fas fa-link"></i></a>TCP/IP 四层协议</h3>              <h3 id="TCP-UDP的特点和区别"   >          <a href="#TCP-UDP的特点和区别" class="heading-link"><i class="fas fa-link"></i></a>TCP UDP的特点和区别</h3>              <h3 id="TCP-三握四挥"   >          <a href="#TCP-三握四挥" class="heading-link"><i class="fas fa-link"></i></a>TCP 三握四挥</h3>              <h3 id="交换机和路由器区别"   >          <a href="#交换机和路由器区别" class="heading-link"><i class="fas fa-link"></i></a>交换机和路由器区别</h3>      <p>两者的主要区别在于：</p><ol><li>工作层次不同：最初的的交换机是工作在OSI／RM开放体系结构的数据链路层，也就是第二层，而路由器一开始就设计工作在OSI模型的网络层。由于交换机工作在OSI的第二层（数据链路层），所以它的工作原理比较简单，而路由器工作在OSI的第三层（网络层），可以得到更多的协议信息，路由器可以做出更加智能的转发决策。</li><li>回路：根据交换机地址学习和站表建立算法，交换机之间不允许存在回路。一旦存在回路，必须启动生成树算法，阻塞掉产生回路的端口。而路由器的路由协议没有这个问题，路由器之间可以有多条通路来平衡负载，提高可靠性。</li><li>子网划分：交换机只能识别ＭＡＣ地址。ＭＡＣ地址是物理地址，而且采用平坦的地址结构，因此不能根据ＭＡＣ地址来划分子网。而路由器识别ＩＰ地址，ＩＰ地址由网络管理员分配，是逻辑地址且ＩＰ地址具有层次结构，被划分成网络号和主机号，可以非常方便地用于划分子网，路由器的主要功能就是用于连接不同的网络。</li><li>负载集中：交换机之间只能有一条通路，使得信息集中在一条通信链路上，不能进行动态分配，以平衡负载。而路由器的路由协议算法可以避免这一点，ＯＳＰＦ路由协议算法不但能产生多条路由，而且能为不同的网络应用选择各自不同的最佳路由。</li><li>广播控制：交换机只能缩小冲突域，而不能缩小广播域。整个交换式网络就是一个大的广播域，广播报文散到整个交换式网络。而路由器可以隔离广播域，广播报文不能通过路由器继续进行广播。</li><li>介质相关：交换机作为桥接设备也能完成不同链路层和物理层之间的转换，但这种转换过程比较复杂，不适合ＡＳＩＣ实现，势必降低交换机的转发速度。因此目前交换机主要完成相同或相似物理介质和链路协议的网络互连，而不会用来在物理介质和链路层协议相差甚元的网络之间进行互连。而路由器则不同，它主要用于不同网络之间互连，因此能连接不同物理介质、链路层协议和网络层协议的网络。路由器在功能上虽然占据了优势，但价格昂贵，报文转发速度低。</li><li>保密问题：虽说交换机也可以根据帧的源ＭＡＣ地址、目的ＭＡＣ地址和其他帧中内容对帧实施过滤，但路由器根据报文的源ＩＰ地址、目的ＩＰ地址、ＴＣＰ端口地址等内容对报文实施过滤，更加直观方便。</li></ol>        <h2 id="综合题"   >          <a href="#综合题" class="heading-link"><i class="fas fa-link"></i></a>综合题</h2>              <h3 id="TCP滑动窗口"   >          <a href="#TCP滑动窗口" class="heading-link"><i class="fas fa-link"></i></a>TCP滑动窗口</h3>              <h3 id="拥塞控制和快速重传"   >          <a href="#拥塞控制和快速重传" class="heading-link"><i class="fas fa-link"></i></a>拥塞控制和快速重传</h3>              <h3 id="IP数据包分片"   >          <a href="#IP数据包分片" class="heading-link"><i class="fas fa-link"></i></a>IP数据包分片</h3>              <h3 id="路由选择"   >          <a href="#路由选择" class="heading-link"><i class="fas fa-link"></i></a>路由选择</h3>              <h3 id="子网划分"   >          <a href="#子网划分" class="heading-link"><i class="fas fa-link"></i></a>子网划分</h3>      <p><img src="C:\Users\15727\AppData\Roaming\Typora\typora-user-images\image-20210620133441784.png" alt="image-20210620133441784"></p>        <h2 id="CDMA计算"   >          <a href="#CDMA计算" class="heading-link"><i class="fas fa-link"></i></a>CDMA计算</h2>      <p>CDMA是一种共享信道的方法，每一个用户可以在<strong>同样的时间</strong>使用<strong>同样的频带</strong>进行通信。<br>简单地说，就是当多个用户用同一个信道进行通信时，如果不采用CDMA的方法，就只能一个一个用户进行通信，效率相对较低。而采用CDMA的方法，则可以让不同的用户在同一个信道同时通信，且互不干扰。</p><p>用发送端每个站的码片序列依次对混合信号进行规格化内积：<br>•结果为+1，说明这个站发送比特1<br>•结果为-1，说明这个站发送比特0<br>•结果为0，说明这个站没有发送信息</p><p>例题：<br>共有4个站进行码分多址CDMA通信，4个站的码片序列为：<br>A:(-1 -1 -1 +1 +1 -1 +1 +1) B:(-1 -1 +1 -1 +1 +1 +1 -1)<br>C:(-1 +1 -1 +1 +1 +1 -1 -1) D:(-1 +1 -1 -1 -1 -1 +1 -1)<br>现收到这样的码片序列:( +1 -3 +3 -1 +1 +1 +1 +1)<br>则站点（ ）发送数据0<br>A. A<br>B. B<br>C. C<br>D. D</p><p>解答：</p><p><strong>真实信息=（站点码片和收到码片）各项积的和</strong></p><p>A：-1+3-3-1+1-1+1+1=0 表示收到的码片序列与A全部正交，那么A站点没有发送数据。<br>B：1/8(-1+3+3+1+1+1+1-1)=1，表示B站发送的信息是+1。<br>C：1/8(-1-3-3-1+1+1-1-1)= -1，表示C站发送的信息为0。<br>D：1/8(-1-3-3+1-1-1+1-1)=-1，表示D站发送的信息为0。<br>因此，多选题应该选择CD.</p>        <h2 id="MOOC题"   >          <a href="#MOOC题" class="heading-link"><i class="fas fa-link"></i></a>MOOC题</h2>              <h3 id="第一章"   >          <a href="#第一章" class="heading-link"><i class="fas fa-link"></i></a>第一章</h3>      <ol><li>试比较分组交换和电路交换的主要优缺点。</li></ol><ul><li><p>分组交换</p><ul><li>概念：每次绘画预留延其路径所需的独占资源</li><li>优点<ol><li>性能较高：电路及性能</li></ol></li><li>缺点<ol><li>利用率较低：分片没有会话使用的情况下分片空载</li><li>需要在每个连续预留呼叫建立的线路</li></ol></li></ul></li><li><p>电路交换</p><ul><li>概念：数据以离散的数据块通过网络来发送</li></ul></li><li><p>优点</p><ol><li>利用率高：每个分组使用全部的链路宽带<ol><li>服务用户更多：分组交换允许更多的用户使用网络</li></ol></li><li>资源贡献<ol><li>简单，不需要建立连接</li></ol></li></ol></li><li>缺点<ol><li>过度竞争导致分组延迟与丢失<ol><li>需要可靠数据传输，拥塞控制协议</li></ol></li></ol></li></ul><ol><li><p>网络协议的三要素是什么？协议和服务的区别是什么</p><p>网络协议：为进行网络中的数据交换而建立的规则、标准或约定。由以下三个要素组成：<br>（1）语法：即数据与控制信息的结构或格式。<br>（2）语义：即需要发出何种控制信息，完成何种动作以及做出何种响应。<br>（3）同步：即事件实现顺序的详细说明。协议是控制两个对等实体进行通信的规则的集合。在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务，而要实现本层协议，还需要使用下面一层提供服务。</p><p>协议和服务的概念的区分：<br>1、协议的实现保证了能够向上一层提供服务。本层的服务用户只能看见服务而无法看见下面的协议。下面的协议对上面的服务用户是透明的。<br>2、协议是“水平的”，即协议是控制两个对等实体进行通信的规则。但服务是“垂直的”，即服务是由下层通过层间接口向上层提供的。上层使用所提供的服务必须与下层交换一些命令，这些命令在OSI中称为服务原语。</p></li><li><p>收发两端之间的传输距离为1000km, 信号在媒体上的传播速率为2 x 10^8 m/s。试计算以下两种情况的传输时延和传播时延。</p><p>(1) 数据长度为10^7 bit， 数据传输速率为100kb/s。</p><p>(2) 数据长度为10^3 bit， 数据传输速率为1Gb/s。</p><p>答：</p><p>（1）发送延迟=10\^7/（100×1000）=100s<br>传播延迟=1000×1000/（2×10\^8）=5×10s=5ms<br>（2）发送延迟=10\^3/（10\^9）=10\^-6s=1us<br>传播延迟=1000×1000/（2×10\^8）=5×10\^-3s=5ms<br>结论：若数据长度大而发送速率低，则在总的时延中，发送时延往往大于传播时延。但若数据长度短而发送速率高，则传播时延就可能是总时延中的主要成分。</p></li><li><p>考虑路由器缓存的排队时延。令 I 表示流量强度；即 I = La / R。假定排队时延的形式为 IL / R(1-I)，其中，I &lt; 1。写出总时延公式，即排队时延加上传输时延。</p></li></ol><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210624194531.png" alt="image-20210624194531588"></p><ol><li><p>什么是应用层报文，什么是运输层报文段，什么是网络层数据报，什么是链路层帧？</p><p>应用层———消息<br>传输层———数据段（segment）<br>网络层———-分组、数据包（packet）<br>链路层———-帧<br>物理层———-PDU（bit比特）</p><p>1、报文<br>报文是网络中交换和传输的数据单元，也是网络传输的单元。报文包含了将要发送的完整的数据信息，其长短不需一致。报文在传输过程中会不断地封装成分组、包、帧来传输，封装的方式就是添加一些控制信息组成的首部，那就是报文头。<br>2、分组<br>分组是在网络中传输的二进制格式的单元。用户发送的数据会被分成多个更小的部分，在每个部分的前面加上一些必要的控制信息组成的首部，有时也会加上尾部，就构成了一个分组。<br>3、数据包<br>数据包是tcp/ip协议通信传输中的数据单元，也称为包。数据包是从最上层，一层一层封装，知道网络层的，最后借助数据链路层发送出去的数据单元。<br>4、数据报<br>面向无连接（UDP）的数据传输，工作过程类似于报文交换。采用数据报方式传输时，被传输的分组称为数据报。<br>5、帧<br>帧是数据链路层的传输单元。将上层传输的数据添加一个头部和尾部，组成了帧。</p></li></ol>        <h3 id="第二章"   >          <a href="#第二章" class="heading-link"><i class="fas fa-link"></i></a>第二章</h3>      <ol><li><p>什么是持久性连接？什么是非持久性连接？持久性连接与非持久性连接区别如何？</p><p>参考答案：每个请求/响应对是经一个单独的HTTP连接发送，该过程被称为非持久连接。（5分） 所有请求/响应对是经相同的HTTP连接发送，该过程被称为持久连接。（5分）非持久性连接（Nonpersistent HTTP）中每个HTTP连接最多允许传输一个对象，每一次传输文件都需要重新建立新的HTTP连接。持久性连接中每个HTTP连接允许传输多个对象，客户端发送响应后，服务器保持HTTP连接打开，后续的HTTP消息可以通过这个连接发送。（10分）</p></li><li><p>请说明web缓存技术的工作原理?</p><p>参考答案：用户设定浏览器通过缓存进行web访问浏览器时，向缓存/代理服务器发送所有HTTP请求。（5分）如果所请求对象在缓存中，返回缓存对象。（5分）如果对象在缓存中，则缓存服务器向原始服务器发送HTTP请求（5分），获取对象并返回给客户端，同时保存该对象。（5分）</p><p>我的答案：</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210624200159.jpg" alt=""></p><p>Web缓存有数据库缓存，服务器缓存，客户端缓存</p><p>客户端缓存是指浏览器缓存，浏览器发送http请求的时候, 如果缓存中有相应的内容就不会向服务器发起请求，转而将缓存中的资源取出</p><p>服务器缓存时指http请求被发送给缓存/代理服务器，如果所请求对象在缓存中，返回缓存对象。如果对象在缓存中，则缓存服务器向原始服务器发送HTTP请求，获取对象并返回给客户端，同时保存该对象。</p><p>数据库缓存时数据库内容量很大的时候就会将查询的结构暂存在缓存中，下次查询可以更快的获取数据，比如redis。</p></li><li><p>电子邮件发送过程中用的什么协议？请叙述下发送过程是什么样子的？</p><p>电子邮件发送过程中使用的是HTTP和SMTP协议</p><p>发送过程是：</p><p>1）发送方通过用户代理形式，通过SMTP协议将邮件上传到发送方邮件服务器 </p><p>2）发送方邮件服务器将邮件通过SMTP协议传送到接收方邮件服务器 </p><p>3）接收方邮件服务器通过HTTP协议将邮件分发到接收方的邮箱中</p></li><li><p>假定你在浏览器中点击一个超链接获得web页面。假设相关得URL得IP地址没有缓存在本地主机上，因此必须进行DNS查询从而获得IP地址。如果主机从DNS得到IP地址前，已经访问了n个DNS服务器，相继产生得RTT依次为T1,T2,T3….TN,进一步假定与链路相关的web页面只包含一个对象，即少量的HTML文件。另RTT0表示本地主机与包含对象的服务器之间的RTT值。假定该对象传输时间为0，则从客户机点击超链接到它接收到该对象需要多长时间？</p><p>参考答案：2T0+T1+T2+….+TN</p></li><li><p>域名系统的主要功能是什么？域名系统中的本地域名服务器、根域名服务器、顶级域名服务器有何区别？</p><p>答</p><p>域名是IP地址的别名，域名系统的功能是将域名解析为IP地址</p><p>域名是按照一定层次划分的，域名的层次从右往左，以点分割</p><p>当访问一个域名的时候，就会向本地域名服务器发起DNS请求，本地域名服务器会查询自己的记录中有没有该域名的IP，如果有就返回，如果没有本地域名服务器就会向根域名服务器发起请求，根域名服务器会返回对应的顶级域名服务器的地址，本地域名服务器再向对应的顶级域名服务器发起请求，顶级域名服务器返回域名对应的二级域名的权威域名服务器地址/本地域名服务器地址，然后权威域名服务器就给本地域名服务器返回域名的IP。</p><p>本地域名服务器、根域名服务器、顶级域名服务器的区别：</p><p>因特网上的域名服务器系统也是按照域名的层次来安排的。每一个域名服务器都只对域名体系中的一部分进行管辖。共有三种不同类型的域名服务器。即本地域名服务器、根域名服务器、顶级域名服务器。当一个本地域名服务器不能立即回答某个主机的查询时，该本地域名服务器就以DNS客户的身份向某一个根域名服务器查询。若根域名服务器有被查询主机的信息，就发送DNS回答报文给本地域名服务器，然后本地域名服务器再回答发起查询的主机。但当根域名服务器没有被查询的主机的信息时，它一定知道某个保存有被查询的主机名字映射的授权域名服务器的IP地址。通常根域名服务器用来管辖顶级域。根域名服务器并不直接对顶级域下面所属的所有的域名进行转换，但它一定能够找到下面的所有二级域名的域名服务器</p></li></ol>        <h3 id="第三章"   >          <a href="#第三章" class="heading-link"><i class="fas fa-link"></i></a>第三章</h3>      <ol><li><p>主机甲和主机乙之间已建立一个TCP连接，TCP最大段长度为1000字节，若主机甲的当前拥塞窗口为5000字节，在主机甲向主机乙连接发送2个最大段后，成功收到主机乙发送的第一段的确认段，确认段中通告的接收窗口大小为3000字节，则此时主机甲还可以向主机乙发送的最大字节数是？</p><p>参考答案：<br>发送窗口 ： min{5000,3000} = 3000B（10分）由于甲还未收到第二个MSS的确认，则此时主机甲还可以向主机乙发送的最大字节数是：3000 - 1000 = 2000B（10分）</p></li><li><p>主机甲和主机乙已建立TCP连接，甲始终以MSS=1KB大小的段发送数据，并一直有数据发送；乙每收到一个数据段都会发出一个接收窗口为10KB的确认段。若甲在t时刻发生超时，其拥塞窗口为8KB。则从t时刻开始，不再发生超时情况下，经过10个RTT后，甲的发送窗口是多少？</p><p>t时刻超时，所以根据拥塞控制算法，慢启动阈值调整为拥塞窗口的一半，就是4MSS，然后将发送窗口置为1MSS，然后拥塞窗口指数增长1，2，4达到慢开始门限，开始线性增长5，6，7，8，9，10，11，12由因为接收窗口为10MSS，所以，最终发送窗口是10MSS</p></li><li><p>请描述TCP协议中标志位ACK、SYN、FIN、RST的含义，并叙述下TCP三次握手建立连接的过程</p><p>ACK是响应，是根据连接的另一方的信息和发送信息的大小确定的</p><p>SYN是建立连接发送信息的序列号</p><p>FIN表示关闭</p><p>RST表示重置</p><p>三次握手：</p><p>第一次握手：客户端发SYN=x，服务端接收后可以确认”客户端可以给服务端发送信息”</p><p>第二次握手：服务端发SYN=y，ACK=x+1，客户端接收后可以确认“服务端可以正确的接受到客户端的信息并向客户端发出信息”</p><p>第三次握手：客户端发ACk=y+1，服务端接收可以确认“服务端给客户端发送的信息可以被正确接收”</p></li><li><p>什么是多路复用？什么是多路分解？请分别说明二者概念同时叙述下运输层的多路复用与多路分解有哪几种？</p><p>多路复用：</p><p>在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息（封装源端口号和目的端口号，这将在以后用于分解）从而生成报文段，然后将报文段传递到网络层。</p><p>多路分解：</p><p>每个运输层报文段中具有几个字段（就是指上面的源端口号和目的端口号）。在接收端，运输层检查这些字段，标识出接收套接字并与套接字的标识信息进行比对，如果符合则将报文段定向到该套接字。</p><p>有如下几种：</p><p>1无连接的多路复用与多路分解</p><p>2面向连接的多路复用与多路分解</p></li><li><p>TCP和UDP的区别？</p><p>区别一、是否基于连接</p><p>TCP是面向连接的协议，而UDP是无连接的协议。即TCP面向连接;UDP是无连接的，即发送数据之前不需要建立连接。</p></li></ol><p>   区别二、可靠性 和 有序性 区别</p><p>   TCP 提供交付保证（Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输），无差错，不丢失，不重复，且按序到达，也保证了消息的有序性。该消息将以从服务器端发出的同样的顺序发送到客户端，尽管这些消息到网络的另一端时可能是无序的。TCP协议将会为你排好序。</p><p>   UDP不提供任何有序性或序列性的保证。UDP尽最大努力交付，数据包将以任何可能的顺序到达。</p><p>   TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</p><p>   区别三、实时性</p><p>   UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</p><p>   区别四、协议首部大小</p><p>   TCP首部开销20字节; UDP的首部开销小，只有8个字节 。</p><p>   区别五、运行速度</p><p>   TCP速度比较慢，而UDP速度比较快，因为TCP必须创建连接，以保证消息的可靠交付和有序性，毕竟TCP协议比UDP复杂。</p><p>   区别六、拥塞机制</p><p>   UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</p><p>   区别七、流模式（TCP）与数据报模式(UDP);</p><p>   TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;</p><p>   UDP是面向报文的 。</p><p>   区别八、资源占用</p><p>   TCP对系统资源要求较多，UDP对系统资源要求较少。</p><p>   TCP被认为是重量级的协议，而与之相比，UDP协议则是一个轻量级的协议。因为UDP传输的信息中不承担任何间接创造连接，保证交货或秩序的的信息。这也反映在用于承载元数据的头的大小。</p><p>   区别九、应用</p><p>   每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信 。基于UDP不需要建立连接，所以且适合多播的环境，UDP是大量使用在游戏和娱乐场所。</p><p>   优缺点</p><p>   基于上面的区别；TCP和UDP的优缺点也很明显了。</p><p>   UDP 优点：简单、传输快。</p><p>   （1）网速的提升给UDP的稳定性提供可靠网络保障，丢包率很低，如果使用应用层重传，能够确保传输的可靠性。</p><p>   （2）TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程，由于TCP内置的系统协议栈中，极难对其进行改进。采用TCP，一旦发生丢包，TCP会将后续的包缓存起来，等前面的包重传并接收到后再继续发送，延时会越来越大，基于UDP对实时性要求较为严格的情况下，采用自定义重传机制，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成影响。</p><p>   缺点：不可靠，不稳定；</p><p>   UDP应用场景：</p><p>   1.面向数据报方式</p><p>   2.网络数据大多为短消息</p><p>   3.拥有大量Client</p><p>   4.对数据安全性无特殊要求</p><p>   5.网络负担非常重，但对响应速度要求高</p><p>   TCP：</p><p>   优点：可靠 稳定</p><p>   TCP的可靠体现在TCP在传输数据之前，会有三次握手来建立连接，而且在数据传递时，有确认. 窗口. 重传. 拥塞控制机制，在数据传完之后，还会断开来连接用来节约系统资源。</p><p>   缺点：慢，效率低，占用系统资源高，易被攻击</p><p>   TCP应用场景：</p><p>   当对网络质量有要求时，比如HTTP，HTTPS，FTP等传输文件的协议；POP，SMTP等邮件传输的协议。</p>        <h3 id="第四章"   >          <a href="#第四章" class="heading-link"><i class="fas fa-link"></i></a>第四章</h3>      <ol><li><p>考虑如图1示的网络。</p><p>a.假定网络是一个数据报网络。显示路由器A中的转发表，其中所有指向主机H3的流量通过接口3转发。</p><p>b.假定网络是一个数据报网络。你能写出路由器A中的转发表吗?其中所有从H1指向主机H3的流量通过接口3转发，而所有从H2指向主机H3的流量通过接口4转发。(提示：这是一个技巧问题。)</p><p>c.现在假定网络是虚电路网络，在H1和H3之间有一个进行中的呼叫，H2和H3之间有另一个进行中的呼叫。写出路由器A中的转发表，其中所有从H1指向主机H3的流量通过接口3转发，而所有H2指向主机H3的流量通过接口4转发。</p><p>d.假设场景与(c)中相同，写出在结点B、C和D中的转发表。</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210624215725.png" alt="image-20210624215725091" style="zoom: 80%;" /></p><center>图1 网络拓扑</center><p>答案:</p><ol><li><p>路由器A的转发表:</p><p>| 目标地址 | 链路接口 |<br>| ———— | ———— |<br>| H3       | 3        |</p></li><li><p>不能,数据包网络的路由表只能设置目的地址的接口</p></li><li><p>路由器A的VC转发表</p><p>| 接入端口 | 进入的VC号 | 输出端口 | 输出VC号 |<br>| ———— | ————— | ———— | ———— |<br>| 1        | 12         | 3        | 13       |<br>| 2        | 17         | 4        | 18       |</p></li><li><p>一种可能的VC转发表</p><p>路由器B</p><p>| 接入端口 | 进入的VC号 | 输出端口 | 输出VC号 |<br>| ———— | ————— | ———— | ———— |<br>| 1        | 13         | 2        | 14       |</p><p>路由器C</p><p>| 接入端口 | 进入的VC号 | 输出端口 | 输出VC号 |<br>| ———— | ————— | ———— | ———— |<br>| 1        | 18         | 2        | 19       |</p><p>路由器D</p><p>| 接入端口 | 进入的VC号 | 输出端口 | 输出VC号 |<br>| ———— | ————— | ———— | ———— |<br>| 1        | 14         | 3        | 15       |<br>| 2        | 19         | 3        | 20       |</p></li></ol></li><li><p>考虑使用8比特主机地址的某数据报网络。假定一台路由器使用最长前缀匹配并具有如图2所示的转发表：</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210625095418.png" alt="image-20210625095145310" style="zoom:80%;" /></p><center>图2 转发表</center><p>对这4个接口中的每个，给出响应的目的主机地址的范围和在该范围中的地址数量。</p><p>答案:</p><p>| 目的主机地址范围      | 链路接口 | 地址数量       |<br>| ——————————- | ———— | ——————— |<br>| 0000 0000 ~ 0011 1111 | 0        | 2^6 = 64       |<br>| 0100 0000 ~ 0101 1111 | 1        | 2^5 = 32       |<br>| 0110 0000 ~ 0111 1111 | 2        | 2^5 = 32       |<br>| 1000 0000 ~ 1011 1111 | 2        | 2^6 + 2^5 = 96 |<br>| 1100 0000 ~ 1111 1111 | 3        | 2^6 = 64       |</p></li><li><p>考虑互联3个子网(子网1、子网2和子网3)的一台路由器。假定在这3个子网的每个子网中的所有接口要求具有前缀223.1.17/24。还假定子网1要求支持多达60个接口,子网2要求支持多达90个接口和子网3要求支持多达12个接口。提供3个满足这些限制的网络地址(形式为a.b.c.d/x)。</p><p>答案:</p><p>| 子网编号 | 网络地址        | 网络地址范围              |<br>| ———— | ———————- | ————————————- |<br>| 1        | 223.1.17.0/26   | 223.1.17.0~223.1.17.63    |<br>| 2        | 223.1.17.128/25 | 223.1.17.128~223.1.17.255 |<br>| 3        | 223.1.17.192/28 | 223.1.17.192~223.1.17.207 |</p></li></ol><ol><li><p>假设你有兴趣检测NAT后面的主机数量。你观察到在每个IP分组上IP层顺序地标出一个标识号。由一台主机生成的第一个IP分组的标识号是一个随机数,后继IP分组的标识号是顺序分配的。假设由NAT后面主机产生的所有IP分组都发往外部。</p><p>a.基于这个观察,假定你能够俘获由NAT向外部发送的所有分组,你能概要给出一种简单的技术来检测NAT后面不同主机的数量吗?评估你的答案。</p><p>b.如果标识号不是顺序分配而是随机分配的,这种技术还能正常工作吗?评估你的答案。</p><p>答案:</p><p>因为所有的P数据包都发送到外部，所以我们可以使用包嗅探器来记录NAT后面的主机生成的所有IP数据包。由于每个主机生成具有序列号和不同的（很可能，因为它们是从一个很大的空间中随机选择的）初始标识号（ID)的IP分组序列，因此可以将具有连续ID的P分组分组分组到一系列簇中。簇的数量是NAT后面的主机数量。</p><p>如果这些标识号不是顺序分配而是随机分配，那么a.部分建议的技术就不会起作用，因为在嗅探数据中不会有簇。</p></li><li><p>基于Dijkstra算法计算路由器A的算法表</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210625100245.png" alt="image-20210625100245276" style="zoom:80%;" /></p><p>答案:</p><p>| 迭代路径 | B    | C        | D        | E    | F    | G        | H        |<br>| ———— | —— | ———— | ———— | —— | —— | ———— | ———— |<br>| A        | 4,A  | $\infin$ | $\infin$ | 1,A  | 3,A  | $\infin$ | $\infin$ |<br>| AE       | 4,A  | $\infin$ | $\infin$ |      | 3,A  | $\infin$ | $\infin$ |<br>| AEF      | 4,A  | $\infin$ | 8,F      |      |      | 6,F      | $\infin$ |<br>| AEFB     |      | 7,B      | 8,F      |      |      | 5,B      | $\infin$ |<br>| AEFBG    |      | 6,G      | 8,F      |      |      |          | 7,G      |<br>| AEFBGC   |      |          | 8,F      |      |      |          | 7,G      |<br>| AEFBGCH  |      |          | 8,F      |      |      |          |          |<br>| AEFBGCHD |      |          | 8,F      |      |      |          |          |</p></li></ol>        <h3 id="第五章"   >          <a href="#第五章" class="heading-link"><i class="fas fa-link"></i></a>第五章</h3>      <ol><li><p>在某网络中标识为A到E的5个结点以星形与一台交换机连接，考虑在该网络环境中某个正在学习的交换机的运行情况。假定：该交换机表初始为空。B向E发送一个帧，此时交换机将该数据帧转发到（）端口，当E收到数据帧以后，返回一个数据帧给B，则当数据帧到达交换机后，该数据帧将被转发到（）端口。</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210625110434.png" alt="image-20210625110434790" style="zoom:80%;" /></p></li></ol><p>   所有其他端口，也就是a, c, d, e</p><p>   b</p><ol><li><p>有如图所示的拓扑结构，主机E向主机B发送一个IP数据报，假设所有主机的ARP缓存表和交换机转发表都是最新的，则E发出的数据帧的目的MAC地址和目的IP地址分别是（）和（），源MAC地址和源IP地址分别是（）和（）；Router2收到数据帧以后，将继续转发该数据帧，转发的数据帧的目的MAC地址和目的IP地址分别是（）和（），源MAC地址和源IP地址分别是（）和（）；Router1收到该数据帧以后将继续转发该数据帧给主机B，Router1转发的数据帧的目的MAC地址和目的IP地址分别是（）和（），源MAC地址和源IP地址分别是（）和（）。</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210625110511.png" alt="image-20210625110511863" style="zoom:80%;" /></p><p>答案：</p><p>目的MAC地址:88-88-88-88-88-88，目的IP地址:192.168.1.003;</p><p>源MAC地址:77-77-77-77-77-77，源IP地址:192.168.3.001;</p><p>目的 MAC地址:33-33-33-33-33-33，目的IP地址:192.168.1.003;</p><p>源MAC地址:55-55-55-55-55-55，源IP地址:192.168.3.001;</p><p>目的MAC地址:11-11-11-11-11-11，目的IP地址:192.168.1.003;</p><p>源MAC地址:22-22-22-22-22-2，源IP地址:192.168.3.001;</p></li><li><p>如图，假设主机E发送IP数据报给主机F，主机E将请求路由器Router2帮助转发该数据报吗？（）（会/不会），这是因为（）。E发出的数据帧的目的MAC地址是（）。</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210625110546.png" style="zoom: 80%;" /></p><p>不会；因为E判断接收主机F与自己在一个网段，因此该数据帧不会转发到Router2</p><p>目的MAC地址：99-99-99-99-99-99</p></li><li><p>如图，假设主机E向主机D发送IP数据报，主机E的ARP缓存表中没有主机D的MAC地址，E将执行ARP查询来发现D的MAC地址吗？（）（会/不会），这是因为（）。Router2收到的数据帧的目的MAC地址是（）</p><p><img src="https://raw.githubusercontent.com/z-jeff953/picsBed/main/image/20210625110619.png" style="zoom:80%;" /></p><p>不会, 因为E判断D与自己不在一个网段，ARP请求限制在统一路由器下, 因此会将该数据帧发到默认路由器的对应端口</p><p>目的MAC地址是88-88-88-88-88-88</p></li><li><p>主机C发送IP数据报给主机D，C的ARP缓存不包含D的MAC地址，D的ARP缓存不包含C的MAC地址，进一步假设与C、D相连的交换机的转发表只包含D和路由器R2的表项，因此C将广播一个ARP请求报文。中间的交换机收到C的ARP请求报文，将执行的操作是（），这个请求报文会到达路由器Router2吗？（）（会/不会）Router2会继续转发该报文到右边的交换机吗？（）（会/不会）主机D收到ARP请求报文后，会返回一个ARP响应报文给主机C，它需要发送一个ARP请求报文来获得C的MAC地址吗？（）（需要/不需要），这是因为（），中间交换机收到ARP响应报文的数据帧后，将直接转发该数据帧给主机C，这是因为（）</p><p>答案：</p><p>交换机将向除到达端口之外的所有3个端口广播这个数据帧</p><p>这个请求报文会到达路由器 Router2</p><p>Router2不会继续转发该报文到右边的交换机</p><p>主机D不需要发送一个ARP请求报文来获得C的MAC地址</p><p>这是因为D已经从ARP请求报文的数据帧的源MAC地址知道C的MAC地址</p><p>中间交换机收到主机D的ARP响应报文的数据帧后，将直接转发该数据帧给主机C，这是因为交换机已经在收到C的ARP请求报文的数据帧时，通过自学习学习到主机C的MAC地址对应的端口</p></li></ol><p><strong>Keep Curious , Keep Learning !</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;计算机网络-09-计网大题&quot;   &gt;
          &lt;a href=&quot;#计算机网络-09-计网大题&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;计算机网络 - 09 计网大题&lt;/h1&gt;
      &lt;p&gt;编程题看06 , 简答题和综合体可能考点进行梳理, 自底向下梳理&lt;/p&gt;</summary>
    
    
    
    <category term="基础知识" scheme="http://zjeff-953.gitee.io/zjeff/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="前端" scheme="http://zjeff-953.gitee.io/zjeff/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="后端" scheme="http://zjeff-953.gitee.io/zjeff/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="计算机网络" scheme="http://zjeff-953.gitee.io/zjeff/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
