<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon.png?v=2.1.1" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon.png?v=2.1.1" type="image/png" sizes="32x32"><meta name="description" content="描述">
<meta property="og:type" content="article">
<meta property="og:title" content="刷面筋 - 01 大问题">
<meta property="og:url" content="http://zjeff-953.gitee.io/zjeff/2021/10/12/%E9%9D%A2%E8%AF%95/%E5%88%B7%E9%9D%A2%E7%AD%8B%20-%2001%20%E5%A4%A7%E9%97%AE%E9%A2%98/index.html">
<meta property="og:site_name" content="Jeff&#39;s blog">
<meta property="og:description" content="描述">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/zjeff-953/picsBed/raw/master/image/20210506144222.jpg">
<meta property="og:image" content="https://gitee.com/zjeff-953/picsBed/raw/master/image/20210507001528.png">
<meta property="og:image" content="https://gitee.com/zjeff-953/picsBed/raw/master/image/20210505235336.svg">
<meta property="og:image" content="https://gitee.com/zjeff-953/picsBed/raw/master/image/20210518082316.webp">
<meta property="og:image" content="https://gitee.com/zjeff-953/picsBed/raw/master/image/20210518133143.png">
<meta property="article:published_time" content="2021-10-12T06:34:25.660Z">
<meta property="article:modified_time" content="2021-06-10T02:42:26.000Z">
<meta property="article:author" content="Jeffords zuo">
<meta property="article:tag" content="标签">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/zjeff-953/picsBed/raw/master/image/20210506144222.jpg"><title>刷面筋 - 01 大问题 | Jeff's blog</title><link ref="canonical" href="http://zjeff-953.gitee.io/zjeff/2021/10/12/%E9%9D%A2%E8%AF%95/%E5%88%B7%E9%9D%A2%E7%AD%8B%20-%2001%20%E5%A4%A7%E9%97%AE%E9%A2%98/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.1.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":5},
  header: {"enable":true,"showOnPost":false,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Jeff's blog" type="application/atom+xml">
</head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/reading/"><span class="header-nav-menu-item__icon"><i class="fas fa-book"></i></span><span class="header-nav-menu-item__text">阅读</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user-tie"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">刷面筋 - 01 大问题</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-12</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-06-10</span></span></div></header><div class="post-body">
        <h1 id="刷面筋-01-大问题"   >
          <a href="#刷面筋-01-大问题" class="heading-link"><i class="fas fa-link"></i></a>刷面筋 - 01 大问题</h1>
      <p>八股文还是要备的</p>
<span id="more"></span>

        <h2 id="1-网络基础-浏览器输入网址之后发生了什么"   >
          <a href="#1-网络基础-浏览器输入网址之后发生了什么" class="heading-link"><i class="fas fa-link"></i></a>1. 网络基础 - 浏览器输入网址之后发生了什么</h2>
      <p>考点: 浏览器工作原理, 计算机网络, 前端历史</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/43369093" >https://zhuanlan.zhihu.com/p/43369093</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://juejin.cn/post/6953070090623549447#heading-7" >https://juejin.cn/post/6953070090623549447#heading-7</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="1-1-网络传输html文件和assets"   >
          <a href="#1-1-网络传输html文件和assets" class="heading-link"><i class="fas fa-link"></i></a>1.1 网络传输html文件和assets</h3>
      
        <h4 id="1-1-1-查看缓存"   >
          <a href="#1-1-1-查看缓存" class="heading-link"><i class="fas fa-link"></i></a>1.1.1 查看缓存</h4>
      <p>浏览器查看<strong>缓存</strong>，如果请求资源在缓存中并且新鲜，跳转到转码步骤</p>
<ol>
<li>如果资源未缓存，发起新请求</li>
<li>如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。</li>
<li>检验新鲜通常有两个 HTTP 头进行控制<code>Expires</code>和<code>Cache-Control</code>：<ul>
<li>HTTP1.0 提供 Expires，值为一个绝对时间表示缓存新鲜日期</li>
<li>HTTP1.1 增加了 Cache-Control: max-age=,值为以秒为单位的最大新鲜时间</li>
</ul>
</li>
</ol>

        <h4 id="1-1-2-获取IP地址"   >
          <a href="#1-1-2-获取IP地址" class="heading-link"><i class="fas fa-link"></i></a>1.1.2 获取IP地址</h4>
      <p>URL是统一资源定位符, 他定位了互联网上一个资源存在的地址</p>
<p>由4部分组成：协议、主机、端口、路径</p>
<blockquote>
<p>URL的一般语法格式为：(带方括号[]的为可选项)：</p>
<p>protocol :// hostname[:port] / path / [;parameters][?query]#fragment</p>
<blockquote>
<p># fragement 可以叫做锚点</p>
<p>fragment 对于 HTML 文档来说就是页面内的定位标识符，可以实现 HTML 页面内的定位。当然浏览器针对不同类型的资源会有区分的处理 fragment</p>
</blockquote>
</blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=javascript" >https://www.baidu.com/s?wd=javascript</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 以这个url为例, 可以分为五个部分</p>
<p>① https :// ②www . ③baidu.com ④/s ⑤?wd=javascript</p>
<p>这五个部分分别是 : </p>
<p>① https 叫做协议名, 类似的有http, ftp 等</p>
<p>② www 叫做服务器名</p>
<p>③ baidu.com 叫做域名</p>
<p>④ /s 叫做路径</p>
<p>⑤ ?wd=javascript 叫做参数</p>
<blockquote>
<p>DNS解析详解</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/yaoyao-sun/p/10387864.html" >https://www.cnblogs.com/yaoyao-sun/p/10387864.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/qinlulu/p/12796911.html" >https://www.cnblogs.com/qinlulu/p/12796911.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>我们首先需要根据域名找到万维网上这个域名对应的<strong>IP地址</strong>, 才能找到对应的计算机的服务在哪里, 所以需要使用<strong>DNS</strong> ( Domain Name System/ 域名系统 ) 进行<strong>域名解析</strong>, 把域名转化成IP地址.</p>
<p><img src="https://gitee.com/zjeff-953/picsBed/raw/master/image/20210506144222.jpg" alt=""></p>
<blockquote>
<p>递归查询与迭代查询</p>
<p> <strong>一、主机向本地域名服务器的查询一般都是采用递归查询。</strong></p>
<p>​    所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，</p>
<p>​    向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。</p>
<p>​    因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。</p>
<p><strong>二、本地域名服务器向根域名服务器的查询的迭代查询。</strong></p>
<p>​    迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。</p>
<p>​    </p>
<p><img src="https://gitee.com/zjeff-953/picsBed/raw/master/image/20210507001528.png" alt="image-20210507001527983"></p>
<p>DNS负载均衡和http负载均衡</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://www.360doc.com/content/17/1215/10/157056_713254970.shtml" >http://www.360doc.com/content/17/1215/10/157056_713254970.shtml</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.zhihu.com/question/22587247" >https://www.zhihu.com/question/22587247</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38800668/article/details/106200238" >https://blog.csdn.net/weixin_38800668/article/details/106200238</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44256848/article/details/102892076" >https://blog.csdn.net/weixin_44256848/article/details/102892076</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="1-1-3-建立TCP连接"   >
          <a href="#1-1-3-建立TCP连接" class="heading-link"><i class="fas fa-link"></i></a>1.1.3 建立TCP连接</h4>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38623623/article/details/81214220" >https://blog.csdn.net/qq_38623623/article/details/81214220</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/yu876876/article/details/81560122" >https://blog.csdn.net/yu876876/article/details/81560122</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="1-1-4-进行http请求和响应"   >
          <a href="#1-1-4-进行http请求和响应" class="heading-link"><i class="fas fa-link"></i></a>1.1.4 进行http请求和响应</h4>
      
        <h4 id="1-1-5-关闭TCP连接"   >
          <a href="#1-1-5-关闭TCP连接" class="heading-link"><i class="fas fa-link"></i></a>1.1.5 关闭TCP连接</h4>
      
        <h4 id="1-1-6-浏览器进行缓存"   >
          <a href="#1-1-6-浏览器进行缓存" class="heading-link"><i class="fas fa-link"></i></a>1.1.6 浏览器进行缓存</h4>
      <p><img src="https://gitee.com/zjeff-953/picsBed/raw/master/image/20210505235336.svg" alt="HTTP访问过程"></p>

        <h3 id="1-2-浏览器渲染页面"   >
          <a href="#1-2-浏览器渲染页面" class="heading-link"><i class="fas fa-link"></i></a>1.2 浏览器渲染页面</h3>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" >https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/47407398" >https://zhuanlan.zhihu.com/p/47407398</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><strong>概述：浏览器渲染一共有五步</strong></p>
<ol>
<li>处理 <code>HTML</code> 并构建 <code>DOM</code> 树。</li>
<li>处理 <code>CSS</code>构建 <code>CSSOM</code> 树。</li>
<li>将 <code>DOM</code> 与 <code>CSSOM</code> 合并成一个渲染树。</li>
<li>根据渲染树来布局，计算每个节点的位置。</li>
<li>调用 <code>GPU</code> 绘制，合成图层，显示在屏幕上</li>
</ol>

        <h4 id="1-2-1-资源解码并判断类型"   >
          <a href="#1-2-1-资源解码并判断类型" class="heading-link"><i class="fas fa-link"></i></a>1.2.1 资源解码并判断类型</h4>
      <ol>
<li>对响应的资源进行<strong>解码</strong>（例如 gzip 压缩）</li>
<li>根据资源类型决定如何处理（假设资源为 HTML 文档）</li>
</ol>

        <h4 id="1-2-2-解析HTML-下载资源"   >
          <a href="#1-2-2-解析HTML-下载资源" class="heading-link"><i class="fas fa-link"></i></a>1.2.2 解析HTML, 下载资源</h4>
      <p><img src="https://gitee.com/zjeff-953/picsBed/raw/master/image/20210518082316.webp" alt="1480597-365009d6fa2d4b77"></p>
<ol>
<li><strong>解析 HTML 文档，构件 DOM 树，下载资源，构造 CSSOM 树，执行 js 脚本</strong>，这些操作没有严格的先后顺序，以下分别解释</li>
<li><strong>构建 DOM 树</strong>：<ol>
<li><strong>Tokenizing</strong>：根据 HTML 规范将字符流解析为标记</li>
<li><strong>Lexing</strong>：词法分析将标记转换为对象并定义属性和规则</li>
<li><strong>DOM construction</strong>：根据 HTML 标记关系将对象组成 DOM 树</li>
</ol>
</li>
<li>解析过程中遇到图片、样式表、js 文件，<strong>启动下载</strong></li>
<li>构建<strong>CSSOM 树</strong>：<ol>
<li><strong>Tokenizing</strong>：字符流转换为标记流</li>
<li><strong>Node</strong>：根据标记创建节点</li>
<li><strong>CSSOM</strong>：节点创建 CSSOM 树</li>
</ol>
</li>
<li><strong><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction" >根据 DOM 树和 CSSOM 树构建渲染树</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong>:<ol>
<li>从 DOM 树的根节点遍历所有<strong>可见节点</strong>，不可见节点包括：1）<code>script</code>,<code>meta</code>这样本身不可见的标签。2)被 css 隐藏的节点，如<code>display: none</code></li>
<li>对每一个可见节点，找到恰当的 CSSOM 规则并应用</li>
<li>发布可视节点的内容和计算样式</li>
</ol>
</li>
<li><strong>js 解析如下</strong>：<ol>
<li>浏览器创建 Document 对象并解析 HTML，将解析到的元素和文本节点添加到文档中，此时<strong>document.readystate 为 loading</strong></li>
<li>HTML 解析器遇到<strong>没有 async 和 defer 的 script 时</strong>，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用 document.write()把文本插入到输入流中。<strong>同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作 script 和他们之前的文档内容</strong></li>
<li>当解析器遇到设置了<strong>async</strong>属性的 script 时，开始下载脚本并继续解析文档。脚本会在它<strong>下载完成后尽快执行</strong>，但是<strong>解析器不会停下来等它下载</strong>。异步脚本<strong>禁止使用 document.write()</strong>，它们可以访问自己 script 和之前的文档元素</li>
<li>当文档完成解析，document.readState 变成 interactive</li>
<li>所有<strong>defer</strong>脚本会<strong>按照在文档出现的顺序执行</strong>，延迟脚本<strong>能访问完整文档树</strong>，禁止使用 document.write()</li>
<li>浏览器<strong>在 Document 对象上触发 DOMContentLoaded 事件</strong></li>
<li>此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些<strong>内容完成载入并且所有异步脚本完成载入和执行</strong>，document.readState 变为 complete,window 触发 load 事件</li>
</ol>
</li>
<li><strong>显示页面</strong>（HTML 解析过程中会逐步显示页面）</li>
</ol>

        <h5 id="页面重绘和回流"   >
          <a href="#页面重绘和回流" class="heading-link"><i class="fas fa-link"></i></a>页面重绘和回流</h5>
      <blockquote>
<p>重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大</p>
</blockquote>
<ul>
<li><p>重绘是当节点需要更改外观而不会影响布局的，比如改变 <code>color</code> 就叫称为重绘</p>
</li>
<li><p>回流是布局或者几何属性需要改变就称为回流。</p>
</li>
</ul>
<blockquote>
<p>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流</p>
</blockquote>
<p><strong>以下几个动作可能会导致性能问题</strong></p>
<ul>
<li>改变 <code>window</code> 大小</li>
<li>改变字体</li>
<li>添加或删除样式</li>
<li>文字改变</li>
<li>定位或者浮动</li>
<li>盒模型</li>
</ul>
<p><strong>很多人不知道的是，重绘和回流其实和 Event loop 有关</strong></p>
<ul>
<li>当 <code>Event loop</code> 执行完<code>Microtasks</code> 后，会判断 <code>document</code> 是否需要更新。因为浏览器是 <code>60Hz</code> 的刷新率，每 <code>16ms</code> 才会更新一次。</li>
<li>然后判断是否有 <code>resize</code> 或者 <code>scroll</code> ，有的话会去触发事件，所以 <code>resize</code> 和 <code>scroll</code> 事件也是至少 <code>16ms</code>才会触发一次，并且自带节流功能。</li>
<li>判断是否触发了 <code>media query</code></li>
<li>更新动画并且发送事件</li>
<li>判断是否有全屏操作事件</li>
<li>执行 <code>requestAnimationFrame</code> 回调</li>
<li>执行 <code>IntersectionObserver</code> 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好</li>
<li>更新界面</li>
<li>以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 <code>requestIdleCallback</code> 回调</li>
</ul>
<p><strong>常见的引起重绘的属性</strong></p>
<ul>
<li><code>color</code></li>
<li><code>border-style</code></li>
<li><code>visibility</code></li>
<li><code>background</code></li>
<li><code>text-decoration</code></li>
<li><code>background-image</code></li>
<li><code>background-position</code></li>
<li><code>background-repeat</code></li>
<li><code>outline-color</code></li>
<li><code>outline</code></li>
<li><code>outline-style</code></li>
<li><code>border-radius</code></li>
<li><code>outline-width</code></li>
<li><code>box-shadow</code></li>
<li><code>background-size</code></li>
</ul>
<p><strong>常见引起回流属性和方法</strong></p>
<blockquote>
<p>任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发重排，下面列一些栗子</p>
</blockquote>
<ul>
<li>添加或者删除可见的<code>DOM</code>元素；</li>
<li>元素尺寸改变——边距、填充、边框、宽度和高度</li>
<li>内容变化，比如用户在<code>input</code>框中输入文字</li>
<li>浏览器窗口尺寸改变——<code>resize</code>事件发生时</li>
<li>计算 <code>offsetWidth</code> 和 <code>offsetHeight</code> 属性</li>
<li>设置 <code>style</code> 属性的值</li>
</ul>
<p><strong>回流影响的范围</strong></p>
<blockquote>
<p>由于浏览器渲染界面是基于.流式布局模型的，所以触发重排时会对周围DOM重新排列，影响的范围有两种</p>
</blockquote>
<ul>
<li>全局范围：从根节点<code>html</code>开始对整个渲染树进行重新布局。</li>
<li>局部范围：对渲染树的某部分或某一个渲染对象进行重新布局</li>
</ul>
<p><strong>全局范围回流</strong></p>
<figure class="highlight html"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>Name:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>BDing<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h5</span>&gt;</span>male<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>coding<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>loving<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></div></figure>
<blockquote>
<p>当<code>p</code>节点上发生<code>reflow</code>时，<code>hello</code>和<code>body</code>也会重新渲染，甚至<code>h5</code>和<code>ol</code>都会收到影响</p>
</blockquote>
<p><strong>局部范围回流</strong></p>
<blockquote>
<p>用局部布局来解释这种现象：把一个<code>dom</code>的宽高之类的几何信息定死，然后在<code>dom</code>内部触发重排，就只会重新渲染该<code>dom</code>内部的元素，而不会影响到外界</p>
</blockquote>
<p><strong>如何减少重绘和回流</strong></p>
<blockquote>
<p>使用 <code>translate</code> 替代 <code>top</code></p>
</blockquote>
<figure class="highlight html"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.test</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">        <span class="attribute">top</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 引起回流</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.test&#x27;</span>).style.top = <span class="string">&#x27;100px&#x27;</span></span></span><br><span class="line"><span class="javascript">    &#125;, <span class="number">1000</span>)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></div></figure>
<ul>
<li>使用 <code>visibility</code> 替换 <code>display: none</code> ，因为前者只会引起重绘，后者会引发回流（改变了布局）</li>
<li>把 <code>DOM</code> 离线后修改，比如：先把 <code>DOM</code> 给 <code>display:none</code> (有一次 <code>Reflow)</code>，然后你修改<code>100</code>次，然后再把它显示出来</li>
<li>不要把 <code>DOM</code> 结点的属性值放在一个循环里当成循环里的变量</li>
</ul>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 获取 offsetTop 会导致回流，因为需要去获取正确的值</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">&#x27;.test&#x27;</span>).style.offsetTop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ul>
<li>不要使用 <code>table</code> 布局，可能很小的一个小改动会造成整个 <code>table</code> 的重新布局</li>
<li>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 <code>requestAnimationFrame</code></li>
<li><code>CSS</code>选择符从右往左匹配查找，避免 <code>DOM</code>深度过深</li>
<li>将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 <code>video</code>标签，浏览器会自动将该节点变为图层。</li>
</ul>

        <h4 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h4>
      <p>浏览器工作流程：构建DOM -&gt; 构建CSSOM -&gt; 构建渲染树 -&gt; 布局 -&gt; 绘制。</p>
<p>CSSOM会阻塞渲染，只有当CSSOM构建完毕后才会进入下一个阶段构建渲染树。</p>
<p>通常情况下DOM和CSSOM是并行构建的，但是当浏览器遇到一个不带defer或async属性的script标签时，DOM构建将暂停，如果此时又恰巧浏览器尚未完成CSSOM的下载和构建，由于JavaScript可以修改CSSOM，所以需要等CSSOM构建完毕后再执行JS，最后才重新DOM构建。</p>

        <h2 id="2-Js原理-Js的单线程模型"   >
          <a href="#2-Js原理-Js的单线程模型" class="heading-link"><i class="fas fa-link"></i></a>2. Js原理 - Js的单线程模型</h2>
      <p>考点 : 异步编程, 事件循环</p>

        <h2 id="3-框架原理-React设计思想"   >
          <a href="#3-框架原理-React设计思想" class="heading-link"><i class="fas fa-link"></i></a>3. 框架原理 - React设计思想</h2>
      <p>考点 : SPA 思想, VDOM, Webpack, 前端工程化</p>

        <h2 id="4-前端工程化"   >
          <a href="#4-前端工程化" class="heading-link"><i class="fas fa-link"></i></a>4. 前端工程化</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/5k_YZBFdMivYstu7Q-Qn0g" >https://mp.weixin.qq.com/s/5k_YZBFdMivYstu7Q-Qn0g</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="什么是前端工程化？"   >
          <a href="#什么是前端工程化？" class="heading-link"><i class="fas fa-link"></i></a>什么是前端工程化？</h3>
      <p>工程化是一种思想，而不是某种技术。其主要目的为了提高效率和降低成本，即提高开发过程中的开发效率，减少不必要的重复工作时间等</p>
<p><strong>栗子</strong></p>
<p>要盖一栋大楼，假如我们不进行工程化的考量那就是一上来掂起瓦刀、砖块就开干，直到把大楼垒起来，这样做往往意味着中间会出现错误，要推倒重来或是盖好以后结构有问题但又不知道出现在哪谁的责任甚至会在某一天轰然倒塌，那我们如果用工程化的思想去做，就会先画图纸、确定结构、确定用料和预算以及工期，另外需要用到什么工种多少人等等，我们会先打地基再建框架再填充墙体这样最后建立起来的高楼才是稳固的合规的，什么地方出了问题我们也能找到源头和负责人。</p>
<p>那么前端工程化需要考虑哪些因素呢？</p>
<p>应该从模块化、组件化、规范化、自动化4个方面去思考</p>

        <h3 id="模块化"   >
          <a href="#模块化" class="heading-link"><i class="fas fa-link"></i></a>模块化</h3>
      <p>模块化就是把一个大的文件，拆分成多个相互依赖的小文件，按一个个模块来划分</p>

        <h3 id="组件化"   >
          <a href="#组件化" class="heading-link"><i class="fas fa-link"></i></a>组件化</h3>
      <p>页面上所有的东西都可以看成组件，页面是个大型组件，可以拆成若干个中型组件，然后中型组件还可以再拆，拆成若干个小型组件</p>
<ul>
<li>组件化≠模块化。模块化只是在文件层面上，对代码和资源的拆分；组件化是在设计层面上，对于UI的拆分</li>
<li>目前市场上的组件化的框架，主要的有Vue，React，Angular2</li>
</ul>

        <h3 id="规范化"   >
          <a href="#规范化" class="heading-link"><i class="fas fa-link"></i></a>规范化</h3>
      <p>在项目规划初期制定的好坏对于后期的开发有一定影响。包括的规范有</p>
<ul>
<li>目录结构的制定</li>
<li>编码规范</li>
<li>前后端接口规范</li>
<li>文档规范</li>
<li>组件管理</li>
<li>Git分支管理</li>
<li>Commit描述规范</li>
<li>定期codeReview</li>
<li>视觉图标规范</li>
</ul>

        <h3 id="自动化"   >
          <a href="#自动化" class="heading-link"><i class="fas fa-link"></i></a>自动化</h3>
      <p>也就是简单重复的工作交给机器来做，自动化也就是有很多自动化工具代替我们来完成，例如持续集成、自动化构建、自动化部署、自动化测试等等</p>

        <h2 id="5-前端性能优化"   >
          <a href="#5-前端性能优化" class="heading-link"><i class="fas fa-link"></i></a>5. 前端性能优化</h2>
      <p><strong>性能优化小册子 , 读完总结一下</strong></p>
<p><strong><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000022956784?utm_source=sf-similar-article" >https://segmentfault.com/a/1190000022956784?utm_source=sf-similar-article</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
<p>首先什么是前端的性能指标 , 之前看winter老师的文章说他们团队总结出的实践经验是</p>
<ol>
<li>页面加载性能；</li>
<li>动画与操作性能；</li>
<li>内存、电量消耗</li>
</ol>
<p>这些本质上是用户体验, IBM研究院的报告指出, 页面开启时间超过1s , 大部分用户是不愿意继续等的</p>
<p>为了优化这些东西, 我们可以从三个角度入手,</p>
<ol>
<li><p>网络请求 - 减小体积, 减少次数</p>
<ol>
<li><p>缓存控制</p>
</li>
<li><p>网络优化</p>
<ol>
<li><p>使用CDN</p>
<blockquote>
<p>CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。</p>
</blockquote>
</li>
<li><p>DNS预解析</p>
<blockquote>
<p>　　DNS Prefetch，即DNS预解析就是根据浏览器定义的规则，提前解析之后可能会用到的域名，使解析结果缓存到<code>系统缓存</code>中，缩短DNS解析时间，来提高网站的访问速度</p>
<p>　　方法是在 head 标签里面写上几个 link 标签</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;dns-prefecth&quot; href=&quot;https://www.google.com&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefecth&quot; href=&quot;https://www.google-analytics.com&quot;&gt;</span><br></pre></td></tr></table></div></figure>
<p>　　对以上几个网站提前解析 DNS，由于它是并行的，不会堵塞页面渲染，这样可以缩短资源加载的时间</p>
</blockquote>
</li>
<li><p>持久连接</p>
<blockquote>
<p>　　使用keep-alive或presistent来建立持久连接，持久连接降低了时延和连接建立的开销，将连接保持在已调谐状态，而且减少了打开连接的潜在数量</p>
</blockquote>
</li>
</ol>
</li>
<li><p>资源处理</p>
<ol>
<li><p>图片 webp 格式 , 转svg ,转base64 , 懒加载</p>
</li>
<li><p>css , js ,  html  使用 gzip</p>
</li>
<li><p>资源加载顺和时机要合理</p>
<blockquote>
<p>　　通过优化资源加载位置，更改资源加载时机，使尽可能快地展示出页面内容，尽可能快地使功能可用</p>
<p>　　1、CSS文件放在head中，先外链，后本页</p>
<p>　　2、JS文件放在body底部，先外链，后本页</p>
<p>　　3、处理页面、处理页面布局的JS文件放在head中，如babel-polyfill.js文件、flexible.js文件</p>
<p>　　4、body中间尽量不写style标签和script标签</p>
<p>【资源加载时机】</p>
<p>　　1、异步script标签</p>
<p>　　defer: 异步加载，在HTML解析完成后执行。defer的实际效果与将代码放在body底部类似</p>
<p>　　async: 异步加载，加载完成后立即执行</p>
<p>　　2、模块按需加载</p>
<p>　　在SPA等业务逻辑比较复杂的系统中，需要根据路由来加载当前页面需要的业务模块</p>
<p>　　按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载</p>
<p>　　webpack 提供了两个类似的技术，优先选择的方式是使用符合 ECMAScript 提案 的 import() 语法。第二种则是使用 webpack 特定的 require.ensure</p>
<p>　　3、使用资源预加载preload和资源预读取prefetch</p>
<p>　　preload让浏览器提前加载指定资源，需要执行时再执行，可以加速本页面的加载速度</p>
<p>　　prefetch告诉浏览器加载下一页面可能会用到的资源，可以加速下一个页面的加载速度</p>
<p>　　4、资源懒加载与资源预加载</p>
<p>　　资源延迟加载也称为懒加载，延迟加载资源或符合某些条件时才加载某些资源</p>
<p>　　资源预加载是提前加载用户所需的资源，保证良好的用户体验</p>
<p>　　资源懒加载和资源预加载都是一种错峰操作，在浏览器忙碌的时候不做操作，浏览器空间时，再加载资源，优化了网络性能</p>
</blockquote>
</li>
</ol>
</li>
<li><p>代码分割(code spliting)，可以基于路由或动态加载</p>
</li>
</ol>
</li>
<li><p>浏览器优化 - 减少重绘和回流 , 充分使用Js异步的特性</p>
<ol>
<li><p>减少重绘重流</p>
<ol>
<li><p>涉及到样式，尺寸，节点增减的操作，都会触发reflow和repaint。</p>
<p>1.1 用变量缓存dom样式，不要频繁读取<br>1.2 通过DocumentFragment或innerHTML批量操作dom<br>1.3 dom隐藏，或复制到内存中，类似virtual dom，进行修改，完成后再替换回去<br>1.4 动画元素一定要absolute，脱离文档流，不影响其他元素。动画不要用left，top等操作，要使用transform和opacity，同时开启渲染层(will-change或translate3d(0,0,0))<br>1.5 动画尽量用requestAnimationFrame，不要用定时器<br>1.6 移动端硬件加速，触发GPU渲染，还是translate3d(0,0,0)</p>
</li>
<li><p>尽量用css动画代替js动画，canvas动画代替js动画</p>
</li>
<li>初始渲染，可以使用骨架屏或loading，提升体验</li>
<li>PWA，可以本地缓存资源，提升体验</li>
<li>频繁触发的事件，防抖、节流，例如：scroll，input等</li>
<li>长列表，使用分页或滚动加载，虚拟列表，移除屏外dom</li>
</ol>
</li>
<li><p>合适技术选型, 根据用户停留时间选择SPA还是SSR</p>
</li>
<li><p>JS性能优化</p>
<ol>
<li>防抖节流</li>
<li>事件代理</li>
<li>wasm</li>
<li>canvas</li>
</ol>
</li>
<li><p>打包优化</p>
<p>主要是webpack优化</p>
<ol>
<li>拆包 externals dllPlugin</li>
<li>提取公共包 commonChunkPlugin或splitChunks</li>
<li>缩小范围 各种loader配置include和exclude，noParse跳过文件</li>
<li>开启缓存 各种loader开启cache</li>
<li>多线程加速 happypack或thead-loader</li>
<li>tree-shaking ES模块分析，移除死代码</li>
<li>Scope Hoisting ES6模块分析，将多个模块合并到一个函数里，减少内存占用，减小体积，提示运行速度</li>
<li>webpack长缓存优化</li>
<li>js文件使用chunkhash，不使用hash</li>
<li>css文件使用contenthash，不使用chunkhash，不受js变化影响</li>
<li>提取vendor，公共库不受业务模块变化影响</li>
<li>内联webpack runtime到页面，chunkId变化不影响vendor</li>
<li>保证module Id稳定，不使用数字作为模块id，改用文件内容的hash值，使用HashedModuleIdsPlugin，模块的新增或删除，会导致其后面的所有模块id重新排序，为避免这个问题</li>
<li>保证chunkhash稳定，使用webpack-chunk-hash，替代webpack自己的hash算法。webpack自己的hash算法，对于同一个文件，在不同开发环境下，会计算出不用的hash值，不能满足跨平台需求。</li>
</ol>
</li>
<li><p>vue优化</p>
<ol>
<li>路由懒加载组件</li>
<li>keep-alive缓存组件，保持原显示状态</li>
<li>列表项添加key，保证唯一</li>
<li>列表项绑定事件，使用事件代理(v-for)</li>
<li>v-if和v-for不要用在一个标签上，它会在每个项上进行v-if判断</li>
</ol>
<p><strong>9. react优化</strong></p>
<ol>
<li>路由组件懒加载，使用react-loadable</li>
<li>类组件添加shouldComponent或PureComponent</li>
<li>函数组件添加React.memo</li>
<li>列表项添加key，保证唯一</li>
<li>函数组件使用hook优化，useMemo，useCallback</li>
</ol>
</li>
<li><p><strong>SEO优化</strong></p>
<ol>
<li>添加各种meta信息</li>
<li>预渲染</li>
<li>服务端渲染</li>
</ol>
</li>
</ol>
</li>
<li><p>根据业务优化和用户交互设计</p>
<ol>
<li>loading 页</li>
<li>合理使用异常处理</li>
<li>将频繁访问的数据预先请求, 缓存频繁发送的请求, 防止重复请求</li>
</ol>
</li>
</ol>
<p><img src="https://gitee.com/zjeff-953/picsBed/raw/master/image/20210518133143.png" alt="image-20210518133143713"></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaohuochai/p/9178390.html" >https://www.cnblogs.com/xiaohuochai/p/9178390.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="6-NodeJs-带来的变化"   >
          <a href="#6-NodeJs-带来的变化" class="heading-link"><i class="fas fa-link"></i></a>6. NodeJs 带来的变化</h2>
      </div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="http://zjeff-953.gitee.io/zjeff">Jeffords zuo</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="http://zjeff-953.gitee.io/zjeff/2021/10/12/%E9%9D%A2%E8%AF%95/%E5%88%B7%E9%9D%A2%E7%AD%8B%20-%2001%20%E5%A4%A7%E9%97%AE%E9%A2%98/">http://zjeff-953.gitee.io/zjeff/2021/10/12/%E9%9D%A2%E8%AF%95/%E5%88%B7%E9%9D%A2%E7%AD%8B%20-%2001%20%E5%A4%A7%E9%97%AE%E9%A2%98/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://zjeff-953.gitee.io/zjeff/tags/%E6%A0%87%E7%AD%BE/">标签</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2021/10/12/%E9%9D%A2%E8%AF%95/%E5%88%B7%E9%9D%A2%E7%AD%8B%20-%2002%20%E7%9F%AD%E9%97%AE%E9%A2%98/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">刷面筋 - 02 短问题</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2021/10/12/%E9%9D%A2%E8%AF%95/%E5%88%B7%E9%9D%A2%E7%AD%8B%20-%2010%20%E5%BE%AE%E8%BD%AF%E9%9D%A2%E7%BB%8F/"><span class="paginator-prev__text">刷面筋 - 10 微软面经</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%B7%E9%9D%A2%E7%AD%8B-01-%E5%A4%A7%E9%97%AE%E9%A2%98"><span class="toc-text">
          刷面筋 - 01 大问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-text">
          1. 网络基础 - 浏览器输入网址之后发生了什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93html%E6%96%87%E4%BB%B6%E5%92%8Cassets"><span class="toc-text">
          1.1 网络传输html文件和assets</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-%E6%9F%A5%E7%9C%8B%E7%BC%93%E5%AD%98"><span class="toc-text">
          1.1.1 查看缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-%E8%8E%B7%E5%8F%96IP%E5%9C%B0%E5%9D%80"><span class="toc-text">
          1.1.2 获取IP地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-%E5%BB%BA%E7%AB%8BTCP%E8%BF%9E%E6%8E%A5"><span class="toc-text">
          1.1.3 建立TCP连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-4-%E8%BF%9B%E8%A1%8Chttp%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94"><span class="toc-text">
          1.1.4 进行http请求和响应</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-5-%E5%85%B3%E9%97%ADTCP%E8%BF%9E%E6%8E%A5"><span class="toc-text">
          1.1.5 关闭TCP连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-6-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E8%A1%8C%E7%BC%93%E5%AD%98"><span class="toc-text">
          1.1.6 浏览器进行缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2"><span class="toc-text">
          1.2 浏览器渲染页面</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E8%B5%84%E6%BA%90%E8%A7%A3%E7%A0%81%E5%B9%B6%E5%88%A4%E6%96%AD%E7%B1%BB%E5%9E%8B"><span class="toc-text">
          1.2.1 资源解码并判断类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E8%A7%A3%E6%9E%90HTML-%E4%B8%8B%E8%BD%BD%E8%B5%84%E6%BA%90"><span class="toc-text">
          1.2.2 解析HTML, 下载资源</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81"><span class="toc-text">
          页面重绘和回流</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">
          总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Js%E5%8E%9F%E7%90%86-Js%E7%9A%84%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">
          2. Js原理 - Js的单线程模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86-React%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="toc-text">
          3. 框架原理 - React设计思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96"><span class="toc-text">
          4. 前端工程化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%EF%BC%9F"><span class="toc-text">
          什么是前端工程化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-text">
          模块化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%8C%96"><span class="toc-text">
          组件化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E8%8C%83%E5%8C%96"><span class="toc-text">
          规范化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8C%96"><span class="toc-text">
          自动化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">
          5. 前端性能优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-NodeJs-%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-text">
          6. NodeJs 带来的变化</span></a></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://gitee.com/zjeff-953/picsBed/raw/master/image/cat.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">Keep Curious</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/github" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">知</span></a><a class="sidebar-ov-social-item" href="1572754810" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="https://gitee.com/zjeff-953" target="_blank" rel="noopener" data-popover="码云" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-git"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">195</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">38</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">53</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Jeffords zuo</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.4.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.1.1</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.1.1"></script><script src="/js/stun-boot.js?v=2.1.1"></script><script src="/js/scroll.js?v=2.1.1"></script><script src="/js/header.js?v=2.1.1"></script><script src="/js/sidebar.js?v=2.1.1"></script></body></html>