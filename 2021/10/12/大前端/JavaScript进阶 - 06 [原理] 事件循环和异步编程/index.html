<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon.png?v=2.1.1" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon.png?v=2.1.1" type="image/png" sizes="32x32"><meta name="description" content="JavaScript进阶 - 06 [原理] 事件循环和异步编程">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript进阶 - 06 [原理] 事件循环和异步编程">
<meta property="og:url" content="http://zjeff-953.gitee.io/zjeff/2021/10/12/%E5%A4%A7%E5%89%8D%E7%AB%AF/JavaScript%E8%BF%9B%E9%98%B6%20-%2006%20[%E5%8E%9F%E7%90%86]%20%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Jeff&#39;s blog">
<meta property="og:description" content="JavaScript进阶 - 06 [原理] 事件循环和异步编程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/zjeff-953/picsBed/raw/master/image/20210427141215.png">
<meta property="og:image" content="https://gitee.com/zjeff-953/picsBed/raw/master/image/20210507220119.jpg">
<meta property="og:image" content="https://gitee.com/zjeff-953/picsBed/raw/master/image/20210507220119.jpg">
<meta property="article:published_time" content="2021-10-12T06:34:25.148Z">
<meta property="article:modified_time" content="2021-06-13T12:03:52.000Z">
<meta property="article:author" content="Jeffords zuo">
<meta property="article:tag" content="面向对象">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/zjeff-953/picsBed/raw/master/image/20210427141215.png"><title>JavaScript进阶 - 06 [原理] 事件循环和异步编程 | Jeff's blog</title><link ref="canonical" href="http://zjeff-953.gitee.io/zjeff/2021/10/12/%E5%A4%A7%E5%89%8D%E7%AB%AF/JavaScript%E8%BF%9B%E9%98%B6%20-%2006%20[%E5%8E%9F%E7%90%86]%20%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.1.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":5},
  header: {"enable":true,"showOnPost":false,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Jeff's blog" type="application/atom+xml">
</head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/reading/"><span class="header-nav-menu-item__icon"><i class="fas fa-book"></i></span><span class="header-nav-menu-item__text">阅读</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user-tie"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">JavaScript进阶 - 06 [原理] 事件循环和异步编程</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-12</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-06-13</span></span></div></header><div class="post-body">
        <h1 id="JavaScript进阶-06-原理-事件循环和异步编程"   >
          <a href="#JavaScript进阶-06-原理-事件循环和异步编程" class="heading-link"><i class="fas fa-link"></i></a>JavaScript进阶 - 06 [原理] 事件循环和异步编程</h1>
      <p>Js的灵魂</p>
<span id="more"></span>
<p><img src="https://gitee.com/zjeff-953/picsBed/raw/master/image/20210427141215.png" alt="image-20210427141215829"></p>

        <h2 id="1-事件循环EventLoop"   >
          <a href="#1-事件循环EventLoop" class="heading-link"><i class="fas fa-link"></i></a>1. 事件循环EventLoop</h2>
      
        <h2 id="2-Promise-使用"   >
          <a href="#2-Promise-使用" class="heading-link"><i class="fas fa-link"></i></a>2. Promise 使用</h2>
      
        <h3 id="2-1-以前的异步实现方式-—-回调函数"   >
          <a href="#2-1-以前的异步实现方式-—-回调函数" class="heading-link"><i class="fas fa-link"></i></a>2.1 以前的异步实现方式 — 回调函数</h3>
      <ol>
<li><p>事件: 某个对象的属性是一个函数, 当发生一件事时, 运行该函数</p>
</li>
<li><p>callback回调函数: 运行某个函数以实现某个功能的时候, 传入一个函数作为参数, 当某个特定的条件下的时候, 就会触发该函数</p>
</li>
</ol>
<p><strong>从本质上来说, 事件和回调函数也没有什么太大的区别, 仅仅就是函数放置的位置不太一样而已</strong></p>
<p>使用回调函数不当造成的问题(回调函数的缺陷)</p>
<p>问题1: 回调地狱</p>
<blockquote>
<p>回调地狱: 某个异步操作需要等到之前的操作完成, 当这样的需求多了以后, 使的代码进入无尽的嵌套</p>
</blockquote>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来看下面这个需求: </span></span><br><span class="line"><span class="comment">// 1.我需要通过小明的学号请求到小明所在班级的信息</span></span><br><span class="line"><span class="comment">// 2. 然后通过小明所在班级信息中的班主任的工号请求到关于这个班主任的一些资料</span></span><br><span class="line"><span class="comment">// 3. 通过班主任的一些资料我希望拿到班主任毕业院校的id, 然后通过id去找到该院校的资料</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用回调函数大多数人势必会这样写</span></span><br><span class="line">$ajax(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/api/getClassInfo&#x27;</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">        $ajax(&#123;</span><br><span class="line">            <span class="attr">url</span>: <span class="string">&#x27;/api/getTeacherInfo&#x27;</span>,</span><br><span class="line">            <span class="attr">data</span>: &#123;</span><br><span class="line">                <span class="attr">id</span>: result.teacher.id</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">                $ajax(&#123;</span><br><span class="line">                    <span class="attr">url</span>: <span class="string">&#x27;/api/getSchoolInfo&#x27;</span>,</span><br><span class="line">                    <span class="attr">data</span>: &#123;</span><br><span class="line">                        <span class="attr">id</span>: result.school.id</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(result.info);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></div></figure>
<p>这种情况是比较常见的: 每一次的网络请求都是根据之前的网络请求的结果, 我只写了三层, 其实如果你阅读的话已经会发现有一些不太容易读的地方了, 那就更不用说嵌套七八层了</p>
<p>回调地狱使得我们的代码非常的难以阅读, 同时导致代码可维护性大大降低</p>
<p>问题2：异步和同步之间的联系问题</p>
<blockquote>
<p>当一个同步操作需要等待多个异步操作的结果, 这样会使得代码的逻辑变得 相对来说比较复杂, 让人抓耳挠腮</p>
</blockquote>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来看一个问题, 小明同时像两个女神表白, 然后等待两个女神回应他, </span></span><br><span class="line"><span class="comment">// 每个女神都会思考一下才回应她, 而小明希望自己能够得到两个女神的回应以后再做打算</span></span><br><span class="line"><span class="comment">// 所以这个任务我们要怎么写呢</span></span><br><span class="line"><span class="keyword">var</span> response = [];</span><br><span class="line"></span><br><span class="line">$ajax(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/getResponse&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;girl-1&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">resp</span>) </span>&#123;</span><br><span class="line">        response[<span class="number">1</span>] =resp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ajax(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/getResponse&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;girl-2&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">resp</span>) </span>&#123;</span><br><span class="line">        response[<span class="number">2</span>] =resp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们怎么能知道两个女神的回应什么时候来呢？ </span></span><br><span class="line"><span class="keyword">if</span>(response.length == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 这样肯定是不能行的, 由于之前是异步任务这里是同步任务, 所以这里会很快的就走掉</span></span><br><span class="line">    <span class="comment">// 这里的代码不出意外的话无论怎样都会在数据到来之前执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(response); <span class="comment">// 依旧是[]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以我们必须监控response的变化, 可能就要使用到Object.defineProperty或者Proxy, </span></span><br><span class="line"><span class="comment">// 或者我们继续写回调 0.0, oh my god</span></span><br><span class="line"><span class="comment">// 这样会让代码相对来说更加的复杂</span></span><br></pre></td></tr></table></div></figure>

        <h3 id="2-2-现在的Promise"   >
          <a href="#2-2-现在的Promise" class="heading-link"><i class="fas fa-link"></i></a>2.2 现在的Promise</h3>
      <p>针对之前在异步操作中容易出现的问题, 在ES6的新特性中, Promise如约而至</p>
<p>Promise 实际上是ES6提供的一个新的构造函数, 跟Date, Regex等标准构造函数一样, 我们需要用new构造Promise实例, 同时在Promise上有一些原型方法和一些静态方法供我们更加精准的来控制和处理异步任务</p>

        <h4 id="2-2-1-ES6提出的异步模型"   >
          <a href="#2-2-1-ES6提出的异步模型" class="heading-link"><i class="fas fa-link"></i></a>2.2.1 ES6提出的异步模型</h4>
      <p>ES6官方是参考了大量的异步场景, 和这些场景容易发生的问题, 总结出了一套在所有异步场景下都可以游刃有余的一套异步模型, 啥是模型: 模型粗浅的理解你可以认为是解决方案</p>
<p>es官方认为, 任何一件可能发生异步操作的事情, 都会分为两个阶段: Unsettled和Settled</p>
<p>Unsettled: 未决阶段, 表示事情还在进行前期的处理（比如网络请求还在请求的过程中, dom事件绑定但是用户还未进行点击）, 在处理中也就意味着这个事情还没有发生通向结果的那件事,就是还没有结果呗</p>
<p>Settled: 已决阶段, 事情的结果已经有了（比如网络请求的数据已经来到, 用户已经点击按钮）, 既然有了结果, 那么就是已决阶段, 同时无论这个结果是好是坏, 整件事情都无法逆转</p>
<blockquote>
<p>举个栗子: 你去找你同学玩, 你从出门到你同学家这中间是要花时间的, 是要有个走路的过程的, 这个过程称之为未决阶段, 你到了你同学家, 你同学说出来玩或者要写作业不出来玩, 无论你有没有得到你想要的答案, 这个结果是不可逆转的, 不出来和出来都代表你做这件事已经得到了一个结果了,或者说你中途摔跤了去医院了也代表这件事的结果已经来了今天你们玩不成了, 你也无法改变, 称之为已决</p>
</blockquote>
<p>事情总是要从未决阶段(Unsettled)走向已决(Settled)的, 时间不可能凝固, 而未决阶段一定拥有控制通向已决阶段的能力</p>
<blockquote>
<p>什么意思呢, 你去找他的路上, 你突然不想玩了, 你是不是可以直接回家, 并且马上获得结果就是今天玩不成, 而你突然遇到你同学他刚好也在外面, 你们愉快的玩耍是不是也是直接获得了结果呢</p>
</blockquote>
<p>同时在这套异步模型中, 官方提出将异步处理分为两个阶段以外, 还提供三个状态: pedding和resolved, rejected</p>
<p>pedding: 挂起状态（或者称之为等待状态）, 未决阶段的状态, 代表事情还在未决, 结果还没出来</p>
<p>resolved: 已处理（或者称之为处理成功）, 已决阶段的状态, 代表事情已经产生结果, 而且这个结果是一个可以按照预定逻辑走下去的结果</p>
<p>rejected: 已拒绝（或者称之为处理失败）, 已决阶段的状态, 代表事情已经产生结果, 但是这个结果跟预想的不太一样, 通常为发生错误</p>
<blockquote>
<p>拿一个网络请求来说, 请求的过程中为未决阶段: 状态为pedding, 而请求到了数据状态码为OK则是resolved状态, 而请求失败500服务器错误则是rejected状态</p>
</blockquote>
<p>由于我们之前说过, 未决阶段一定拥有控制通向已决阶段的能力, 所以:</p>
<ol>
<li>我们把事情推向已决阶段的resolved状态的方法叫做resolve, 推向该状态时可以传递一些数据</li>
<li>我们把事情推向已决阶段的rejected状态的方法叫做reject, 通常会附带一些错误信息</li>
</ol>
<p>当事情发生到已决阶段的resolved状态的时候, 我们做的后续处理叫做thenable, 后续处理就是函数, thenable就是给他的称呼</p>
<p>当事情发生到已决阶段的rejected状态的时候, 我们做的后续处理叫做catchable</p>
<p>后续处理可以有许多个, 会形成一个处理队列, 这个后说, 使用你就知道了</p>
<p>根据上方的一套模型（一套对异步的处理方案）, ES6设计出了Promise</p>

        <h4 id="2-2-2-Promise-的使用"   >
          <a href="#2-2-2-Promise-的使用" class="heading-link"><i class="fas fa-link"></i></a>2.2.2 Promise 的使用</h4>
      <p>Promise是个容器, 他会把构造函数传入的函数进行执行, 然后让你通过then去调用它</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 之前说到在未决阶段拥有将事情推向已决阶段的能力</span></span><br><span class="line"><span class="comment">// 所以这个函数参数又接收系统丢过来的resolve和reject参数用来手动将状态推向已决</span></span><br><span class="line"><span class="keyword">var</span> myPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这个函数中的代码会立即执行, 所以ajax请求等异步操作可以放在这儿</span></span><br><span class="line"><span class="comment">    我们也称这个函数为未决阶段</span></span><br><span class="line"><span class="comment">    通过调用resolve函数将Promise推向已决的resolved状态</span></span><br><span class="line"><span class="comment">    通过调用rejected将Promise推向已决的rejected状态</span></span><br><span class="line"><span class="comment">    resolve和reject都可以传递最多一个参数, 表示推向状态的数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myPromise); <span class="comment">// 看看Promise实例</span></span><br><span class="line"></span><br><span class="line">myPromise.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这是thenable函数, 如果当前的Promise已经是resolved状态, 该函数会立即执行,</span></span><br><span class="line"><span class="comment">    如果当前是未决状态, 则会加入作业队列, 等待Promise状态变为resolved会立即执行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这是catchable函数, 如果当前的Promise已经是rejected状态, 该函数会立即执行, </span></span><br><span class="line"><span class="comment">    如果当前是未决状态, 则会加入作业队列, 等待Promise状态变为rejected会立即执行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></div></figure>
<p>上方的Promis实例打印如下,实例上有两个属性[[PromiseStatus]]和[[PromiseValue]], 前者表示当前Promise实例的状态, 而后者表示当前Promise实例的已决结果 我们会发现一开始Promise实例状态为pedding, 由于还未到已决阶段, 所以Promise结果为undefined</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用Promise请求数据</span></span><br><span class="line"><span class="keyword">let</span> myPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    $ajax(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;/api/getUserInfo&#x27;</span>,</span><br><span class="line">        <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">resp</span>) </span>&#123;</span><br><span class="line">            resolve(resp); <span class="comment">// 数据请求成功, 我们将状态推向已决的resolved阶段</span></span><br><span class="line">            <span class="comment">// 这个成功的概念是不管数据有没有真实的拿到, 只要服务器返回给你东西了就算成功</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">            reject(error); <span class="comment">//数据请求失败, 将状态推向rejected状态</span></span><br><span class="line">            <span class="comment">// 这个失败的概念则是, 比如服务器宕机了, 或者你断网了导致这个数据请求连正常的结果都拿不到</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myPromise);</span><br><span class="line"></span><br><span class="line">myPromise.then(<span class="function"><span class="params">resp</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(resp); <span class="comment">// resolve一触发,这里就会输出, 类似于回调</span></span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// reject一触发,这里就会输出, 类似于回调</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们在这里输出一下Promise实例</span></span><br><span class="line">    <span class="built_in">console</span>.log(myPromise);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

        <h4 id="2-2-3-Promise的全面api详解"   >
          <a href="#2-2-3-Promise的全面api详解" class="heading-link"><i class="fas fa-link"></i></a>2.2.3 Promise的全面api详解</h4>
      
        <h5 id="then-catch-finally"   >
          <a href="#then-catch-finally" class="heading-link"><i class="fas fa-link"></i></a>then catch finally</h5>
      <figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;promise&quot;</span>)</span><br><span class="line">    <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="literal">false</span>)&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;huangbiao&#x27;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">debugger</span></span><br><span class="line">        reject(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line">  &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;catch&#x27;</span>);</span><br><span class="line">  &#125;).finally(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;finally&#x27;</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></div></figure>

        <h6 id="catch和then的第二个参数的区别"   >
          <a href="#catch和then的第二个参数的区别" class="heading-link"><i class="fas fa-link"></i></a>catch和then的第二个参数的区别</h6>
      <p>主要区别就是，如果在then的第一个函数里抛出了异常，后面的catch能捕获到，而then的第二个函数捕获不到。</p>
<p>catch只是一个语法糖而己 还是通过then 来处理的，大概如下所示</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">null</span>,fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>then的第二个参数和catch捕获错误信息的时候会就近原则，如果是promise内部报错，reject抛出错误后，then的第二个参数和catch方法都存在的情况下，只有then的第二个参数能捕获到，如果then的第二个参数不存在，则catch方法会捕获到。</p>

        <h5 id="常用静态方法"   >
          <a href="#常用静态方法" class="heading-link"><i class="fas fa-link"></i></a>常用静态方法</h5>
      <p>all</p>
<blockquote>
<p>all(iterable): 这个方法返回一个新的Promise对象, 该promise对象在iterable参数对象里所有的promise对象都成功的时候才会被触发成功, 一旦有任何一个在iterable里的promise对象失败则立马触发该promise对象的失败, 这个新的promise对象在触发成功状态以后, 会把一个包含iterable里所有promise返回值的数组作为成功回调的返回值, 顺序跟iterable保持一致,如果这个新的promise对象触发了失败状态, 那么他会把iterable里第一个触发失败的promise对象的失败信息作为他的失败错误信息, Promise.all方法常被用于处理多个promise对象的状态集合</p>
</blockquote>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们拿之前小明向多个女神表白的案例来说</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> getGirlResponse = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span> ? <span class="string">&#x27;同意了&#x27;</span> : <span class="string">&#x27;拒绝表白&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getSecGirlResponse = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span> ? <span class="string">&#x27;同意了&#x27;</span> : <span class="string">&#x27;拒绝表白&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getTrdGirlResponse = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span> ? <span class="string">&#x27;同意了&#x27;</span> : <span class="string">&#x27;拒绝表白&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们将三个女神相关的Promise实例放进一个数组, 作为Promise.all的参数</span></span><br><span class="line"><span class="built_in">Promise</span>.all([getGirlResponse, getSecGirlResponse, getTrdGirlResponse]).then(<span class="function"><span class="params">resp</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(resp); </span><br><span class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></div></figure>

        <h4 id="2-2-4-Promise-使用技巧"   >
          <a href="#2-2-4-Promise-使用技巧" class="heading-link"><i class="fas fa-link"></i></a>2.2.4 Promise 使用技巧</h4>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34224840" >https://zhuanlan.zhihu.com/p/34224840</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="后续-阅读Promise-A-模拟实现"   >
          <a href="#后续-阅读Promise-A-模拟实现" class="heading-link"><i class="fas fa-link"></i></a>后续 阅读Promise/A+, 模拟实现</h4>
      <p>Promise/A+ <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://promisesaplus.com/#notes" >https://promisesaplus.com/#notes</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>Promise模拟实现 见手写XXX</p>

        <h2 id="3-aync-await-使用"   >
          <a href="#3-aync-await-使用" class="heading-link"><i class="fas fa-link"></i></a>3. aync await 使用</h2>
      <p>async 是函数声明的时候用, 表示这个函数是异步的, 遇到了里面会有await的东西给阻塞了, 返回值是promise</p>
<p>await 是异步函数调用的时候使用的, 会把promise包裹的内容拿出来赋值到前面, 如果没有返回promise则会包一层promise</p>
<p>Promise是使用generator实现的</p>

        <h3 id="await和Promise混合读程序"   >
          <a href="#await和Promise混合读程序" class="heading-link"><i class="fas fa-link"></i></a>await和Promise混合读程序</h3>
      <figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> async2()</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> async2 = <span class="keyword">async</span> () =&gt;</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></div></figure>
<p>事实上问题的关键在于await后面的代码会如何执行</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// const data = await async2()</span></span><br><span class="line">  <span class="built_in">Promise</span>.resolve()</span><br><span class="line">    .then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">11</span>))</span><br><span class="line">    .then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">22</span>))</span><br><span class="line">    .then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">33</span>))</span><br><span class="line">    .then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">44</span>))</span><br><span class="line">    .then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">55</span>))</span><br><span class="line">    .then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">66</span>))</span><br><span class="line">    .then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">77</span>))</span><br><span class="line">    .then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">88</span>))</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> async2 = <span class="keyword">async</span> () =&gt;</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></div></figure>
<p>尝试实现一个纯Promise一样结果的</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>))</span><br><span class="line">  .then(<span class="function">() =&gt;</span> <span class="literal">null</span>)</span><br><span class="line">  .then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;5&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>))</span><br><span class="line">  .then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>))</span><br><span class="line">  .then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;6&#x27;</span>))</span><br></pre></td></tr></table></div></figure>

        <h2 id="4-往死里递归都不会爆栈的方法"   >
          <a href="#4-往死里递归都不会爆栈的方法" class="heading-link"><i class="fas fa-link"></i></a>4. 往死里递归都不会爆栈的方法</h2>
      <p>每次递归的时候都用setTimeout压入宏任务队列中, 这样就可以让事件循环一直进行下去</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mySetInterval = <span class="function">(<span class="params">callback,time</span>) =&gt;</span>&#123;</span><br><span class="line">  (fucntion <span class="function"><span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      callback()</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">      inner() <span class="comment">// 这里的递归没有退出条件, 但是也会正常运行下去</span></span><br><span class="line">    &#125;,time)</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="5-计时器-setTimeout和setInterval"   >
          <a href="#5-计时器-setTimeout和setInterval" class="heading-link"><i class="fas fa-link"></i></a>5. 计时器 setTimeout和setInterval</h2>
      
        <h3 id="5-1-计时器执行原理"   >
          <a href="#5-1-计时器执行原理" class="heading-link"><i class="fas fa-link"></i></a>5.1 计时器执行原理</h3>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000018226060" >https://segmentfault.com/a/1190000018226060</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/Charminglsy/article/details/91045084" >https://blog.csdn.net/Charminglsy/article/details/91045084</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="5-2-setInterval的弊端"   >
          <a href="#5-2-setInterval的弊端" class="heading-link"><i class="fas fa-link"></i></a>5.2 setInterval的弊端</h3>
      <p>一、弊端<br>1.setInterval对自己调用的代码是否报错漠不关心。即使调用的代码报错了，它依然会持续的调用下去<br>2.setInterval无视网络延迟。在使用ajax轮询服务器是否有新数据时，必定会有一些人会使用setInterval，然而无论网络状况如何，它都会去一遍又一遍的发送请求，如果网络状况不良，一个请求发出，还没有返回结果，它会坚持不懈的继续发送请求，最后导致的结果就是请求堆积。<br>3.setInterval并不定时。如果它调用的代码执行的时间小于定时的时间，它会跳过调用，这就导致无法按照你需要的执行次数或无法得到你想要的结果。</p>
<p>4 setInterval有个很烦的地方就是当js主程序空闲时候，执行代码队列里面的代码的时候，如果此时候我们有一个问题，定时器是等到回调执行完，才开始计时进行下次循环呢？还是只要一次计时完毕，插入回调之后不管回调执不执行就开始计时呢？答案显然是后者，这也就是我说setInterval坑比的原因啊，因为这会出现一种情况，当我们插入回调的时候前队列有别的代码在执行，这时候回调肯定是不会执行的，因此如果这个时候无限定时时间到了会再次插入回调，这个时候如果发现队列中的第一次回调没有执行，那么再次插入的回调浏览器就默认取消，（这是以防出现回调连续执行多次的情况）但是这又引发了新的情况就是有些回调是不能取消掉的？</p>
<p>二、解决方案<br>使用setTimeout代替setInterval。<br>可以给setTimeout设置时间后，在最后调用自身。如果希望“匀速”触发。可以计算代码执行时间，用希望的延迟减去上次执行的时间</p>
<p>注：有一种想法是将setInterval的延迟时间设置的长于上述的几种时间，来达到绝对的均速调用。但事实上，js的计时器因为自身机制的原因，存在4ms–15ms的误差</p>

        <h2 id="6-setTimeout和setInterval相互实现"   >
          <a href="#6-setTimeout和setInterval相互实现" class="heading-link"><i class="fas fa-link"></i></a>6. setTimeout和setInterval相互实现</h2>
      
        <h3 id="6-1-mySetTimeout"   >
          <a href="#6-1-mySetTimeout" class="heading-link"><i class="fas fa-link"></i></a>6.1 mySetTimeout</h3>
      <figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mySetTimeout = <span class="function">(<span class="params">callback,time</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> timer = setInteval(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(timer)</span><br><span class="line">    callback()</span><br><span class="line">  &#125;,time)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="6-2-mySetInterval"   >
          <a href="#6-2-mySetInterval" class="heading-link"><i class="fas fa-link"></i></a>6.2 mySetInterval</h3>
      <figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mySetInterval = <span class="function">(<span class="params">callback,time</span>) =&gt;</span>&#123;</span><br><span class="line">  (fucntion <span class="function"><span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      callback()</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">      inner()</span><br><span class="line">    &#125;,time)</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125; </span><br></pre></td></tr></table></div></figure>
<p>这里还有个缺点是, 这个setTimeout是每次宏任务调用的时候才会重新计时, 而setInterval是在主线程不断计时</p>

        <h3 id="6-3-实现完整的清除和构造定时器"   >
          <a href="#6-3-实现完整的清除和构造定时器" class="heading-link"><i class="fas fa-link"></i></a>6.3 实现完整的清除和构造定时器</h3>
      <p>代码</p>
<p><img src="https://gitee.com/zjeff-953/picsBed/raw/master/image/20210507220119.jpg" alt="v2-ec4e2a1b8733cc714450596ad2ae7578_720w"></p>
<p>效果</p>
<p><img src="https://gitee.com/zjeff-953/picsBed/raw/master/image/20210507220119.jpg" alt="v2-b81b32a2a60e1694a34852524f325e33_720w"></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/73204517" >你会用 settimeout，setinterval 互相实现吗？ - 知乎 (zhihu.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="7-Promise和setTimeout结合使用"   >
          <a href="#7-Promise和setTimeout结合使用" class="heading-link"><i class="fas fa-link"></i></a>7. Promise和setTimeout结合使用</h2>
      <p>一面最后一题</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">封装一个 <span class="built_in">setTimeout</span>，支持</span><br><span class="line">setTimeout1(<span class="number">200</span>, <span class="number">1000</span>)</span><br><span class="line">  .then(<span class="built_in">console</span>.log) </span><br><span class="line"><span class="comment">// 200</span></span><br></pre></td></tr></table></div></figure>
<p>md, mdn的promise构造函数的第一个例子就是这样的, 尬死我了</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">300</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise1.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="comment">// expected output: &quot;foo&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(promise1);</span><br><span class="line"><span class="comment">// expected output: [object Promise]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setTimeout2 = <span class="function">(<span class="params">num, time</span>) =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(num), time))</span><br></pre></td></tr></table></div></figure>
<p>参考资料:</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/wj-1314/articles/12055380.html" >https://www.cnblogs.com/wj-1314/articles/12055380.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/wj-1314/articles/12118771.html" >https://www.cnblogs.com/wj-1314/articles/12118771.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="8-准确计时器"   >
          <a href="#8-准确计时器" class="heading-link"><i class="fas fa-link"></i></a>8. 准确计时器</h2>
      <p>如何解决setTimeout 倒计时误差</p>
<p>曹豆芽 2020-03-16 12:03:38  799  收藏<br>分类专栏： js 文章标签： javascript html html5 css 前端<br>版权<br>setTimeout 倒计时误差<br>JS 是单线程的，所以 setTimeout 的误差其实是无法被完全解决的，原因有很多，可能是回调中的，有可能是浏览器中的各种事件导致。这也是为什么页面开久了，定时器会不准的原因，当然我们可以通过一定的办法去减少这个误差。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是一个相对准备的倒计时实现</span></span><br><span class="line"><span class="keyword">var</span> period = <span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span> * <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() + period</span><br><span class="line"><span class="keyword">var</span> interval = <span class="number">1000</span></span><br><span class="line"><span class="keyword">var</span> currentInterval = interval</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  count++</span><br><span class="line">  <span class="keyword">var</span> offset = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - (startTime + count * interval); <span class="comment">// 代码执行所消耗的时间</span></span><br><span class="line">  <span class="keyword">var</span> diff = end - <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">  <span class="keyword">var</span> h = <span class="built_in">Math</span>.floor(diff / (<span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span>))</span><br><span class="line">  <span class="keyword">var</span> hdiff = diff % (<span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span>)</span><br><span class="line">  <span class="keyword">var</span> m = <span class="built_in">Math</span>.floor(hdiff / (<span class="number">60</span> * <span class="number">1000</span>))</span><br><span class="line">  <span class="keyword">var</span> mdiff = hdiff % (<span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">var</span> s = mdiff / (<span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">var</span> sCeil = <span class="built_in">Math</span>.ceil(s)</span><br><span class="line">  <span class="keyword">var</span> sFloor = <span class="built_in">Math</span>.floor(s)</span><br><span class="line">  currentInterval = interval - offset <span class="comment">// 得到下一次循环所消耗的时间</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;时：&#x27;</span>+h, <span class="string">&#x27;分：&#x27;</span>+m, <span class="string">&#x27;毫秒：&#x27;</span>+s, <span class="string">&#x27;秒向上取整：&#x27;</span>+sCeil, <span class="string">&#x27;代码执行时间：&#x27;</span>+offset, <span class="string">&#x27;下次循环间隔&#x27;</span>+currentInterval) <span class="comment">// 打印 时 分 秒 代码执行时间 下次循环间隔</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(loop, currentInterval)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(loop, currentInterval)</span><br><span class="line"><span class="comment">// 原文链接：https://blog.csdn.net/qq_41108972/article/details/104896203</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="9-1s间隔输出1-5"   >
          <a href="#9-1s间隔输出1-5" class="heading-link"><i class="fas fa-link"></i></a>9. 1s间隔输出1-5</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39147099/article/details/83830587" >https://blog.csdn.net/weixin_39147099/article/details/83830587</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><strong>Keep Curious , Keep Learning !</strong></p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="http://zjeff-953.gitee.io/zjeff">Jeffords zuo</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="http://zjeff-953.gitee.io/zjeff/2021/10/12/%E5%A4%A7%E5%89%8D%E7%AB%AF/JavaScript%E8%BF%9B%E9%98%B6%20-%2006%20[%E5%8E%9F%E7%90%86]%20%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">http://zjeff-953.gitee.io/zjeff/2021/10/12/%E5%A4%A7%E5%89%8D%E7%AB%AF/JavaScript%E8%BF%9B%E9%98%B6%20-%2006%20[%E5%8E%9F%E7%90%86]%20%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://zjeff-953.gitee.io/zjeff/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a></span><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://zjeff-953.gitee.io/zjeff/tags/JavaScript/">JavaScript</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2021/10/12/%E5%A4%A7%E5%89%8D%E7%AB%AF/JavaScript%E8%BF%9B%E9%98%B6%20-%2007%20%5B%E5%8E%9F%E7%90%86%5D%20Js%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">[ 文章无标题 ]</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2021/10/12/%E5%A4%A7%E5%89%8D%E7%AB%AF/JavaScript%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%20-%2002%20%5BDSL%5D%E4%B8%8D%E7%9F%A5%E4%B8%8D%E8%A7%89%E5%B7%B2%E7%BB%8F%E6%B7%B1%E5%85%A5%E5%89%8D%E7%AB%AF%E7%9A%84%E6%96%B9%E6%96%B9%E9%9D%A2%E9%9D%A2%E7%9A%84%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"><span class="paginator-prev__text">JavaScript编程范式 - 02 [DSL]不知不觉已经深入前端的方方面面的编程范式</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript%E8%BF%9B%E9%98%B6-06-%E5%8E%9F%E7%90%86-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="toc-text">
          JavaScript进阶 - 06 [原理] 事件循环和异步编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFEventLoop"><span class="toc-text">
          1. 事件循环EventLoop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Promise-%E4%BD%BF%E7%94%A8"><span class="toc-text">
          2. Promise 使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%BB%A5%E5%89%8D%E7%9A%84%E5%BC%82%E6%AD%A5%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-%E2%80%94-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-text">
          2.1 以前的异步实现方式 — 回调函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%8E%B0%E5%9C%A8%E7%9A%84Promise"><span class="toc-text">
          2.2 现在的Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-ES6%E6%8F%90%E5%87%BA%E7%9A%84%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9E%8B"><span class="toc-text">
          2.2.1 ES6提出的异步模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-Promise-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">
          2.2.2 Promise 的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-Promise%E7%9A%84%E5%85%A8%E9%9D%A2api%E8%AF%A6%E8%A7%A3"><span class="toc-text">
          2.2.3 Promise的全面api详解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#then-catch-finally"><span class="toc-text">
          then catch finally</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">
          常用静态方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-Promise-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7"><span class="toc-text">
          2.2.4 Promise 使用技巧</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E7%BB%AD-%E9%98%85%E8%AF%BBPromise-A-%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0"><span class="toc-text">
          后续 阅读Promise&#x2F;A+, 模拟实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-aync-await-%E4%BD%BF%E7%94%A8"><span class="toc-text">
          3. aync await 使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#await%E5%92%8CPromise%E6%B7%B7%E5%90%88%E8%AF%BB%E7%A8%8B%E5%BA%8F"><span class="toc-text">
          await和Promise混合读程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%BE%80%E6%AD%BB%E9%87%8C%E9%80%92%E5%BD%92%E9%83%BD%E4%B8%8D%E4%BC%9A%E7%88%86%E6%A0%88%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">
          4. 往死里递归都不会爆栈的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%AE%A1%E6%97%B6%E5%99%A8-setTimeout%E5%92%8CsetInterval"><span class="toc-text">
          5. 计时器 setTimeout和setInterval</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E8%AE%A1%E6%97%B6%E5%99%A8%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-text">
          5.1 计时器执行原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-setInterval%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-text">
          5.2 setInterval的弊端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-setTimeout%E5%92%8CsetInterval%E7%9B%B8%E4%BA%92%E5%AE%9E%E7%8E%B0"><span class="toc-text">
          6. setTimeout和setInterval相互实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-mySetTimeout"><span class="toc-text">
          6.1 mySetTimeout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-mySetInterval"><span class="toc-text">
          6.2 mySetInterval</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E5%AE%9E%E7%8E%B0%E5%AE%8C%E6%95%B4%E7%9A%84%E6%B8%85%E9%99%A4%E5%92%8C%E6%9E%84%E9%80%A0%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">
          6.3 实现完整的清除和构造定时器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Promise%E5%92%8CsetTimeout%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-text">
          7. Promise和setTimeout结合使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%87%86%E7%A1%AE%E8%AE%A1%E6%97%B6%E5%99%A8"><span class="toc-text">
          8. 准确计时器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1s%E9%97%B4%E9%9A%94%E8%BE%93%E5%87%BA1-5"><span class="toc-text">
          9. 1s间隔输出1-5</span></a></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://gitee.com/zjeff-953/picsBed/raw/master/image/cat.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">Keep Curious</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/github" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">知</span></a><a class="sidebar-ov-social-item" href="1572754810" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="https://gitee.com/zjeff-953" target="_blank" rel="noopener" data-popover="码云" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-git"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">198</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">38</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">53</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Jeffords zuo</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.4.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.1.1</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.1.1"></script><script src="/js/stun-boot.js?v=2.1.1"></script><script src="/js/scroll.js?v=2.1.1"></script><script src="/js/header.js?v=2.1.1"></script><script src="/js/sidebar.js?v=2.1.1"></script></body></html>